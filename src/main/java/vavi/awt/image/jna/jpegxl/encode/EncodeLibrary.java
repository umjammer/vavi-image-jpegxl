package vavi.awt.image.jna.jpegxl.encode;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.PointerByReference;
import vavi.awt.image.jna.jpegxl.JxlBasicInfo;
import vavi.awt.image.jna.jpegxl.JxlColorEncoding;
import vavi.awt.image.jna.jpegxl.JxlMemoryManagerStruct;
import vavi.awt.image.jna.jpegxl.JxlPixelFormat;
import vavi.awt.image.jna.jpegxl.Library.JxlParallelRunner;


/**
 * JNA Wrapper for library <b>encode</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface EncodeLibrary extends Library {
	String JNA_LIBRARY_NAME = "jxl";
	NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(EncodeLibrary.JNA_LIBRARY_NAME);
	EncodeLibrary INSTANCE = Native.load(EncodeLibrary.JNA_LIBRARY_NAME, EncodeLibrary.class);
	/**
	 * <i>native declaration : jxl/encode.h</i><br>
	 * enum values
	 */
	interface JxlEncoderStatus {
		/** <i>native declaration : jxl/encode.h:40</i> */
		int JXL_ENC_SUCCESS = 0;
		/** <i>native declaration : jxl/encode.h:44</i> */
		int JXL_ENC_ERROR = 1;
		/** <i>native declaration : jxl/encode.h:48</i> */
		int JXL_ENC_NEED_MORE_OUTPUT = 2;
		/** <i>native declaration : jxl/encode.h:52</i> */
		int JXL_ENC_NOT_SUPPORTED = 3;
	}
	/**
	 * Encoder library version.<br>
	 * @return the encoder library version as an integer:<br>
	 * MAJOR_VERSION * 1000000 + MINOR_VERSION * 1000 + PATCH_VERSION. For example,<br>
	 * version 1.2.3 would return 1002003.<br>
	 * Original signature : <code>uint32_t JxlEncoderVersion()</code><br>
	 * <i>native declaration : jxl/encode.h:13</i>
	 */
	int JxlEncoderVersion();
	/**
	 * Creates an instance of JxlEncoder and initializes it.<br>
	 * @p memory_manager will be used for all the library dynamic allocations made<br>
	 * from this instance. The parameter may be NULL, in which case the default<br>
	 * allocator will be used. See jpegxl/memory_manager.h for details.<br>
	 * @param memory_manager custom allocator function. It may be NULL. The memory<br>
	 *        manager will be copied internally.<br>
	 * @return @c NULL if the instance can not be allocated or initialized<br>
	 * @return pointer to initialized JxlEncoder otherwise<br>
	 * Original signature : <code>JxlEncoder* JxlEncoderCreate(const JxlMemoryManager*)</code><br>
	 * <i>native declaration : jxl/encode.h:68</i>
	 */
	PointerByReference JxlEncoderCreate(JxlMemoryManagerStruct memory_manager);
	/**
	 * Re-initializes a JxlEncoder instance, so it can be re-used for encoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with JxlEncoderCreate, but the memory manager is kept.<br>
	 * @param enc instance to be re-initialized.<br>
	 * Original signature : <code>void JxlEncoderReset(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:77</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderReset(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderReset(Pointer enc);
	/**
	 * Re-initializes a JxlEncoder instance, so it can be re-used for encoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with JxlEncoderCreate, but the memory manager is kept.<br>
	 * @param enc instance to be re-initialized.<br>
	 * Original signature : <code>void JxlEncoderReset(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:77</i>
	 */
	void JxlEncoderReset(PointerByReference enc);
	/**
	 * Deinitializes and frees JxlEncoder instance.<br>
	 * @param enc instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlEncoderDestroy(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:84</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderDestroy(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderDestroy(Pointer enc);
	/**
	 * Deinitializes and frees JxlEncoder instance.<br>
	 * @param enc instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlEncoderDestroy(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:84</i>
	 */
	void JxlEncoderDestroy(PointerByReference enc);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * encoding.<br>
	 * @param enc encoder object.<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *        be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *        runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return JXL_ENC_SUCCESS if the runner was set, JXL_ENC_ERROR<br>
	 * otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetParallelRunner(JxlEncoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/encode.h:98</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetParallelRunner(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.Library.JxlParallelRunner, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlEncoderSetParallelRunner(Pointer enc, JxlParallelRunner parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * encoding.<br>
	 * @param enc encoder object.<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *        be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *        runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return JXL_ENC_SUCCESS if the runner was set, JXL_ENC_ERROR<br>
	 * otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetParallelRunner(JxlEncoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/encode.h:98</i>
	 */
	int JxlEncoderSetParallelRunner(PointerByReference enc, JxlParallelRunner parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Encodes JPEG XL file using the available bytes. @p *avail_out indicates how<br>
	 * many output bytes are available, and @p *next_out points to the input bytes.<br>
	 * *avail_out will be decremented by the amount of bytes that have been<br>
	 * processed by the encoder and *next_out will be incremented by the same<br>
	 * amount, so *next_out will now point at the amount of *avail_out unprocessed<br>
	 * bytes.<br>
	 * The returned status indicates whether the encoder needs more output bytes.<br>
	 * When the return value is not JXL_ENC_ERROR or JXL_ENC_SUCCESS, the encoding<br>
	 * requires more JxlEncoderProcessOutput calls to continue.<br>
	 * @param enc encoder object.<br>
	 * @param next_out pointer to next bytes to write to.<br>
	 * @param avail_out amount of bytes available starting from *next_out.<br>
	 * @return JXL_ENC_SUCCESS when encoding finished and all events handled.<br>
	 * return JXL_ENC_ERROR when encoding failed, e.g. invalid input.<br>
	 * return JXL_ENC_NEED_MORE_OUTPUT more output buffer is necessary.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderProcessOutput(JxlEncoder*, uint8_t**, size_t*)</code><br>
	 * <i>native declaration : jxl/encode.h:121</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderProcessOutput(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, int[])} instead
	 */
	@Deprecated 
	int JxlEncoderProcessOutput(Pointer enc, PointerByReference next_out, int[] avail_out);
	/**
	 * Encodes JPEG XL file using the available bytes. @p *avail_out indicates how<br>
	 * many output bytes are available, and @p *next_out points to the input bytes.<br>
	 * *avail_out will be decremented by the amount of bytes that have been<br>
	 * processed by the encoder and *next_out will be incremented by the same<br>
	 * amount, so *next_out will now point at the amount of *avail_out unprocessed<br>
	 * bytes.<br>
	 * The returned status indicates whether the encoder needs more output bytes.<br>
	 * When the return value is not JXL_ENC_ERROR or JXL_ENC_SUCCESS, the encoding<br>
	 * requires more JxlEncoderProcessOutput calls to continue.<br>
	 * @param enc encoder object.<br>
	 * @param next_out pointer to next bytes to write to.<br>
	 * @param avail_out amount of bytes available starting from *next_out.<br>
	 * @return JXL_ENC_SUCCESS when encoding finished and all events handled.<br>
	 * return JXL_ENC_ERROR when encoding failed, e.g. invalid input.<br>
	 * return JXL_ENC_NEED_MORE_OUTPUT more output buffer is necessary.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderProcessOutput(JxlEncoder*, uint8_t**, size_t*)</code><br>
	 * <i>native declaration : jxl/encode.h:121</i>
	 */
	int JxlEncoderProcessOutput(PointerByReference enc, PointerByReference next_out, int[] avail_out);
	/**
	 * Sets the buffer to read JPEG encoded bytes from for the next frame to encode.<br>
	 * If JxlEncoderSetBasicInfo has not yet been called, calling<br>
	 * JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the<br>
	 * added JPEG frame.<br>
	 * If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been<br>
	 * called, calling JxlEncoderAddJPEGFrame will implicitly call it with the<br>
	 * parameters of the added JPEG frame.<br>
	 * If the encoder is set to store JPEG reconstruction metadata using @ref<br>
	 * JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * @param options set of encoder options to use when encoding the frame.<br>
	 * @param buffer bytes to read JPEG from. Owned by the caller and its contents<br>
	 * are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddJPEGFrame(const JxlEncoderOptions*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:146</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderAddJPEGFrame(com.sun.jna.ptr.PointerByReference, byte[], int)} and {@link #JxlEncoderAddJPEGFrame(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlEncoderAddJPEGFrame(Pointer options, Pointer buffer, int size);
	/**
	 * Sets the buffer to read JPEG encoded bytes from for the next frame to encode.<br>
	 * If JxlEncoderSetBasicInfo has not yet been called, calling<br>
	 * JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the<br>
	 * added JPEG frame.<br>
	 * If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been<br>
	 * called, calling JxlEncoderAddJPEGFrame will implicitly call it with the<br>
	 * parameters of the added JPEG frame.<br>
	 * If the encoder is set to store JPEG reconstruction metadata using @ref<br>
	 * JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * @param options set of encoder options to use when encoding the frame.<br>
	 * @param buffer bytes to read JPEG from. Owned by the caller and its contents<br>
	 * are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddJPEGFrame(const JxlEncoderOptions*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:146</i>
	 */
	int JxlEncoderAddJPEGFrame(PointerByReference options, byte[] buffer, int size);
	/**
	 * Sets the buffer to read JPEG encoded bytes from for the next frame to encode.<br>
	 * If JxlEncoderSetBasicInfo has not yet been called, calling<br>
	 * JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the<br>
	 * added JPEG frame.<br>
	 * If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been<br>
	 * called, calling JxlEncoderAddJPEGFrame will implicitly call it with the<br>
	 * parameters of the added JPEG frame.<br>
	 * If the encoder is set to store JPEG reconstruction metadata using @ref<br>
	 * JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * @param options set of encoder options to use when encoding the frame.<br>
	 * @param buffer bytes to read JPEG from. Owned by the caller and its contents<br>
	 * are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddJPEGFrame(const JxlEncoderOptions*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:146</i>
	 */
	int JxlEncoderAddJPEGFrame(PointerByReference options, Pointer buffer, int size);
	/**
	 * Sets the buffer to read pixels from for the next image to encode. Must call<br>
	 * JxlEncoderSetBasicInfo before JxlEncoderAddImageFrame.<br>
	 * Currently only some pixel formats are supported:<br>
	 * - JXL_TYPE_UINT8<br>
	 * - JXL_TYPE_UINT16<br>
	 * - JXL_TYPE_FLOAT16, with nominal range 0..1<br>
	 * - JXL_TYPE_FLOAT, with nominal range 0..1<br>
	 * The color profile of the pixels depends on the value of uses_original_profile<br>
	 * in the JxlBasicInfo. If true, the pixels are assumed to be encoded in the<br>
	 * original profile that is set with JxlEncoderSetColorEncoding or<br>
	 * JxlEncoderSetICCProfile. If false, the pixels are assumed to be nonlinear<br>
	 * sRGB for integer data types (JXL_TYPE_UINT8, JXL_TYPE_UINT16), and linear<br>
	 * sRGB for floating point data types (JXL_TYPE_FLOAT16, JXL_TYPE_FLOAT).<br>
	 * @param options set of encoder options to use when encoding the frame.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddImageFrame(const JxlEncoderOptions*, const JxlPixelFormat*, const void*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:174</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderAddImageFrame(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlEncoderAddImageFrame(Pointer options, JxlPixelFormat pixel_format, Pointer buffer, int size);
	/**
	 * Sets the buffer to read pixels from for the next image to encode. Must call<br>
	 * JxlEncoderSetBasicInfo before JxlEncoderAddImageFrame.<br>
	 * Currently only some pixel formats are supported:<br>
	 * - JXL_TYPE_UINT8<br>
	 * - JXL_TYPE_UINT16<br>
	 * - JXL_TYPE_FLOAT16, with nominal range 0..1<br>
	 * - JXL_TYPE_FLOAT, with nominal range 0..1<br>
	 * The color profile of the pixels depends on the value of uses_original_profile<br>
	 * in the JxlBasicInfo. If true, the pixels are assumed to be encoded in the<br>
	 * original profile that is set with JxlEncoderSetColorEncoding or<br>
	 * JxlEncoderSetICCProfile. If false, the pixels are assumed to be nonlinear<br>
	 * sRGB for integer data types (JXL_TYPE_UINT8, JXL_TYPE_UINT16), and linear<br>
	 * sRGB for floating point data types (JXL_TYPE_FLOAT16, JXL_TYPE_FLOAT).<br>
	 * @param options set of encoder options to use when encoding the frame.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddImageFrame(const JxlEncoderOptions*, const JxlPixelFormat*, const void*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:174</i>
	 */
	int JxlEncoderAddImageFrame(PointerByReference options, JxlPixelFormat pixel_format, Pointer buffer, int size);
	/**
	 * Declares that this encoder will not encode anything further.<br>
	 * Must be called between JxlEncoderAddImageFrame/JPEGFrame of the last frame<br>
	 * and the next call to JxlEncoderProcessOutput, or JxlEncoderProcessOutput<br>
	 * won't output the last frame correctly.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseInput(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:187</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderCloseInput(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderCloseInput(Pointer enc);
	/**
	 * Declares that this encoder will not encode anything further.<br>
	 * Must be called between JxlEncoderAddImageFrame/JPEGFrame of the last frame<br>
	 * and the next call to JxlEncoderProcessOutput, or JxlEncoderProcessOutput<br>
	 * won't output the last frame correctly.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseInput(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:187</i>
	 */
	void JxlEncoderCloseInput(PointerByReference enc);
	/**
	 * Sets the original color encoding of the image encoded by this encoder. This<br>
	 * is an alternative to JxlEncoderSetICCProfile and only one of these two must<br>
	 * be used. This one sets the color encoding as a @ref JxlColorEncoding, while<br>
	 * the other sets it as ICC binary data.<br>
	 * @param enc encoder object.<br>
	 * @param color color encoding. Object owned by the caller and its contents are<br>
	 * copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetColorEncoding(JxlEncoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/encode.h:201</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetColorEncoding(com.sun.jna.ptr.PointerByReference, JxlColorEncoding)} instead
	 */
	@Deprecated 
	int JxlEncoderSetColorEncoding(Pointer enc, JxlColorEncoding color);
	/**
	 * Sets the original color encoding of the image encoded by this encoder. This<br>
	 * is an alternative to JxlEncoderSetICCProfile and only one of these two must<br>
	 * be used. This one sets the color encoding as a @ref JxlColorEncoding, while<br>
	 * the other sets it as ICC binary data.<br>
	 * @param enc encoder object.<br>
	 * @param color color encoding. Object owned by the caller and its contents are<br>
	 * copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetColorEncoding(JxlEncoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/encode.h:201</i>
	 */
	int JxlEncoderSetColorEncoding(PointerByReference enc, JxlColorEncoding color);
	/**
	 * Sets the original color encoding of the image encoded by this encoder as an<br>
	 * ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and<br>
	 * only one of these two must be used. This one sets the color encoding as ICC<br>
	 * binary data, while the other defines it as a @ref JxlColorEncoding.<br>
	 * @param enc encoder object.<br>
	 * @param icc_profile bytes of the original ICC profile<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetICCProfile(JxlEncoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:216</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetICCProfile(com.sun.jna.ptr.PointerByReference, byte[], int)} and {@link #JxlEncoderSetICCProfile(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlEncoderSetICCProfile(Pointer enc, Pointer icc_profile, int size);
	/**
	 * Sets the original color encoding of the image encoded by this encoder as an<br>
	 * ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and<br>
	 * only one of these two must be used. This one sets the color encoding as ICC<br>
	 * binary data, while the other defines it as a @ref JxlColorEncoding.<br>
	 * @param enc encoder object.<br>
	 * @param icc_profile bytes of the original ICC profile<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetICCProfile(JxlEncoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:216</i>
	 */
	int JxlEncoderSetICCProfile(PointerByReference enc, byte icc_profile[], int size);
	/**
	 * Sets the original color encoding of the image encoded by this encoder as an<br>
	 * ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and<br>
	 * only one of these two must be used. This one sets the color encoding as ICC<br>
	 * binary data, while the other defines it as a @ref JxlColorEncoding.<br>
	 * @param enc encoder object.<br>
	 * @param icc_profile bytes of the original ICC profile<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetICCProfile(JxlEncoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:216</i>
	 */
	int JxlEncoderSetICCProfile(PointerByReference enc, Pointer icc_profile, int size);
	/**
	 * Initializes a JxlBasicInfo struct to default values.<br>
	 * For forwards-compatibility, this function has to be called before values<br>
	 * are assigned to the struct fields.<br>
	 * The default values correspond to an 8-bit RGB image, no alpha or any<br>
	 * other extra channels.<br>
	 * @param info global image metadata. Object owned by the caller.<br>
	 * Original signature : <code>void JxlEncoderInitBasicInfo(JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:229</i>
	 */
	void JxlEncoderInitBasicInfo(JxlBasicInfo info);
	/**
	 * Sets the global metadata of the image encoded by this encoder.<br>
	 * @param enc encoder object.<br>
	 * @param info global image metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful,<br>
	 * JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetBasicInfo(JxlEncoder*, const JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:240</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetBasicInfo(com.sun.jna.ptr.PointerByReference, JxlBasicInfo)} instead
	 */
	@Deprecated 
	int JxlEncoderSetBasicInfo(Pointer enc, JxlBasicInfo info);
	/**
	 * Sets the global metadata of the image encoded by this encoder.<br>
	 * @param enc encoder object.<br>
	 * @param info global image metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful,<br>
	 * JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetBasicInfo(JxlEncoder*, const JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:240</i>
	 */
	int JxlEncoderSetBasicInfo(PointerByReference enc, JxlBasicInfo info);
	/**
	 * Configure the encoder to store JPEG reconstruction metadata in the JPEG XL<br>
	 * container.<br>
	 * The encoder must be configured to use the JPEG XL container format using @ref<br>
	 * JxlEncoderUseContainer for this to have any effect.<br>
	 * If this is set to true and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * @param enc encoder object.<br>
	 * @param store_jpeg_metadata true if the encoder should store JPEG metadata.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderStoreJPEGMetadata(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:258</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderStoreJPEGMetadata(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderStoreJPEGMetadata(Pointer enc, int store_jpeg_metadata);
	/**
	 * Configure the encoder to store JPEG reconstruction metadata in the JPEG XL<br>
	 * container.<br>
	 * The encoder must be configured to use the JPEG XL container format using @ref<br>
	 * JxlEncoderUseContainer for this to have any effect.<br>
	 * If this is set to true and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * @param enc encoder object.<br>
	 * @param store_jpeg_metadata true if the encoder should store JPEG metadata.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderStoreJPEGMetadata(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:258</i>
	 */
	int JxlEncoderStoreJPEGMetadata(PointerByReference enc, int store_jpeg_metadata);
	/**
	 * Configure the encoder to use the JPEG XL container format.<br>
	 * Using the JPEG XL container format allows to store metadata such as JPEG<br>
	 * reconstruction (@ref JxlEncoderStoreJPEGMetadata) or other metadata like<br>
	 * EXIF; but it adds a few bytes to the encoded file for container headers even<br>
	 * if there is no extra metadata.<br>
	 * @param enc encoder object.<br>
	 * @param use_container true if the encoder should output the JPEG XL container<br>
	 * format.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseContainer(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:275</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderUseContainer(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderUseContainer(Pointer enc, int use_container);
	/**
	 * Configure the encoder to use the JPEG XL container format.<br>
	 * Using the JPEG XL container format allows to store metadata such as JPEG<br>
	 * reconstruction (@ref JxlEncoderStoreJPEGMetadata) or other metadata like<br>
	 * EXIF; but it adds a few bytes to the encoded file for container headers even<br>
	 * if there is no extra metadata.<br>
	 * @param enc encoder object.<br>
	 * @param use_container true if the encoder should output the JPEG XL container<br>
	 * format.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseContainer(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:275</i>
	 */
	int JxlEncoderUseContainer(PointerByReference enc, int use_container);
	/**
	 * Sets lossless/lossy mode for the provided options. Default is lossy.<br>
	 * @param options set of encoder options to update with the new mode<br>
	 * @param lossless whether the options should be lossless<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetLossless(JxlEncoderOptions*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:286</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsSetLossless(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderOptionsSetLossless(Pointer options, int lossless);
	/**
	 * Sets lossless/lossy mode for the provided options. Default is lossy.<br>
	 * @param options set of encoder options to update with the new mode<br>
	 * @param lossless whether the options should be lossless<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetLossless(JxlEncoderOptions*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:286</i>
	 */
	int JxlEncoderOptionsSetLossless(PointerByReference options, int lossless);
	/**
	 * Set the decoding speed tier for the provided options. Minimum is 0 (highest<br>
	 * quality), and maximum is 4 (lowest quality). Default is 0.<br>
	 * @param options set of encoder options to update with the new decoding speed<br>
	 * tier.<br>
	 * @param tier the decoding speed tier to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetDecodingSpeed(JxlEncoderOptions*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:299</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsSetDecodingSpeed(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderOptionsSetDecodingSpeed(Pointer options, int tier);
	/**
	 * Set the decoding speed tier for the provided options. Minimum is 0 (highest<br>
	 * quality), and maximum is 4 (lowest quality). Default is 0.<br>
	 * @param options set of encoder options to update with the new decoding speed<br>
	 * tier.<br>
	 * @param tier the decoding speed tier to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetDecodingSpeed(JxlEncoderOptions*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:299</i>
	 */
	int JxlEncoderOptionsSetDecodingSpeed(PointerByReference options, int tier);
	/**
	 * Sets encoder effort/speed level without affecting decoding speed. Valid<br>
	 * values are, from faster to slower speed: 1:lightning 2:thunder 3:falcon<br>
	 * 4:cheetah 5:hare 6:wombat 7:squirrel 8:kitten 9:tortoise.<br>
	 * Default: squirrel (7).<br>
	 * @param options set of encoder options to update with the new mode.<br>
	 * @param effort the effort value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetEffort(JxlEncoderOptions*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:313</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsSetEffort(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderOptionsSetEffort(Pointer options, int effort);
	/**
	 * Sets encoder effort/speed level without affecting decoding speed. Valid<br>
	 * values are, from faster to slower speed: 1:lightning 2:thunder 3:falcon<br>
	 * 4:cheetah 5:hare 6:wombat 7:squirrel 8:kitten 9:tortoise.<br>
	 * Default: squirrel (7).<br>
	 * @param options set of encoder options to update with the new mode.<br>
	 * @param effort the effort value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetEffort(JxlEncoderOptions*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:313</i>
	 */
	int JxlEncoderOptionsSetEffort(PointerByReference options, int effort);
	/**
	 * Sets the distance level for lossy compression: target max butteraugli<br>
	 *  distance, lower = higher quality. Range: 0 .. 15.<br>
	 *  0.0 = mathematically lossless (however, use JxlEncoderOptionsSetLossless to<br>
	 *  use true lossless).<br>
	 *  1.0 = visually lossless.<br>
	 *  Recommended range: 0.5 .. 3.0.<br>
	 *  Default value: 1.0.<br>
	 *  If JxlEncoderOptionsSetLossless is used, this value is unused and implied<br>
	 *  to be 0.<br>
	 * @param options set of encoder options to update with the new mode.<br>
	 * @param distance the distance value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetDistance(JxlEncoderOptions*, float)</code><br>
	 * <i>native declaration : jxl/encode.h:332</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsSetDistance(com.sun.jna.ptr.PointerByReference, float)} instead
	 */
	@Deprecated 
	int JxlEncoderOptionsSetDistance(Pointer options, float distance);
	/**
	 * Sets the distance level for lossy compression: target max butteraugli<br>
	 *  distance, lower = higher quality. Range: 0 .. 15.<br>
	 *  0.0 = mathematically lossless (however, use JxlEncoderOptionsSetLossless to<br>
	 *  use true lossless).<br>
	 *  1.0 = visually lossless.<br>
	 *  Recommended range: 0.5 .. 3.0.<br>
	 *  Default value: 1.0.<br>
	 *  If JxlEncoderOptionsSetLossless is used, this value is unused and implied<br>
	 *  to be 0.<br>
	 * @param options set of encoder options to update with the new mode.<br>
	 * @param distance the distance value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetDistance(JxlEncoderOptions*, float)</code><br>
	 * <i>native declaration : jxl/encode.h:332</i>
	 */
	int JxlEncoderOptionsSetDistance(PointerByReference options, float distance);
	/**
	 * Create a new set of encoder options, with all values initially copied from<br>
	 * the @p source options, or set to default if @p source is NULL.<br>
	 * The returned pointer is an opaque struct tied to the encoder and it will be<br>
	 * deallocated by the encoder when JxlEncoderDestroy() is called. For functions<br>
	 * taking both a @ref JxlEncoder and a @ref JxlEncoderOptions, only<br>
	 * JxlEncoderOptions created with this function for the same encoder instance<br>
	 * can be used.<br>
	 * @param enc encoder object.<br>
	 * @param source source options to copy initial values from, or NULL to get<br>
	 * defaults initialized to defaults.<br>
	 * @return the opaque struct pointer identifying a new set of encoder options.<br>
	 * Original signature : <code>JxlEncoderOptions* JxlEncoderOptionsCreate(JxlEncoder*, const JxlEncoderOptions*)</code><br>
	 * <i>native declaration : jxl/encode.h:350</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsCreate(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	PointerByReference JxlEncoderOptionsCreate(Pointer enc, Pointer source);
	/**
	 * Create a new set of encoder options, with all values initially copied from<br>
	 * the @p source options, or set to default if @p source is NULL.<br>
	 * The returned pointer is an opaque struct tied to the encoder and it will be<br>
	 * deallocated by the encoder when JxlEncoderDestroy() is called. For functions<br>
	 * taking both a @ref JxlEncoder and a @ref JxlEncoderOptions, only<br>
	 * JxlEncoderOptions created with this function for the same encoder instance<br>
	 * can be used.<br>
	 * @param enc encoder object.<br>
	 * @param source source options to copy initial values from, or NULL to get<br>
	 * defaults initialized to defaults.<br>
	 * @return the opaque struct pointer identifying a new set of encoder options.<br>
	 * Original signature : <code>JxlEncoderOptions* JxlEncoderOptionsCreate(JxlEncoder*, const JxlEncoderOptions*)</code><br>
	 * <i>native declaration : jxl/encode.h:350</i>
	 */
	PointerByReference JxlEncoderOptionsCreate(PointerByReference enc, PointerByReference source);
	/**
	 * Sets a color encoding to be sRGB.<br>
	 * @param color_encoding color encoding instance.<br>
	 * @param is_gray whether the color encoding should be gray scale or color.<br>
	 * Original signature : <code>void JxlColorEncodingSetToSRGB(JxlColorEncoding*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:359</i>
	 */
	void JxlColorEncodingSetToSRGB(JxlColorEncoding color_encoding, int is_gray);
	/**
	 * Sets a color encoding to be linear sRGB.<br>
	 * @param color_encoding color encoding instance.<br>
	 * @param is_gray whether the color encoding should be gray scale or color.<br>
	 * Original signature : <code>void JxlColorEncodingSetToLinearSRGB(JxlColorEncoding*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:368</i>
	 */
	void JxlColorEncodingSetToLinearSRGB(JxlColorEncoding color_encoding, int is_gray);
	public static class JxlEncoderOptions extends PointerType {
		public JxlEncoderOptions(Pointer address) {
			super(address);
		}
		public JxlEncoderOptions() {
			super();
		}
	}
	public static class JxlEncoder extends PointerType {
		public JxlEncoder(Pointer address) {
			super(address);
		}
		public JxlEncoder() {
			super();
		}
	}
}
