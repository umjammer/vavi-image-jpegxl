package vavi.awt.image.jna.jpegxl.encode;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.NativeLongByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.ptr.ShortByReference;
import vavi.awt.image.jna.jpegxl.JxlBasicInfo;
import vavi.awt.image.jna.jpegxl.JxlBitDepth;
import vavi.awt.image.jna.jpegxl.JxlBlendInfo;
import vavi.awt.image.jna.jpegxl.JxlBoxType;
import vavi.awt.image.jna.jpegxl.JxlCmsInterface;
import vavi.awt.image.jna.jpegxl.JxlColorEncoding;
import vavi.awt.image.jna.jpegxl.JxlExtraChannelInfo;
import vavi.awt.image.jna.jpegxl.JxlFrameHeader;
import vavi.awt.image.jna.jpegxl.JxlMemoryManagerStruct;
import vavi.awt.image.jna.jpegxl.JxlPixelFormat;


/**
 * JNA Wrapper for library <b>encode</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface EncodeLibrary extends Library {
	String JNA_LIBRARY_NAME = "encode";
	NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(JNA_LIBRARY_NAME);
	EncodeLibrary INSTANCE = Native.load(JNA_LIBRARY_NAME, EncodeLibrary.class);
	/**
	 * <i>native declaration : jxl/encode.h</i><br>
	 * enum values
	 */
	interface JxlEncoderStatus {
		/** <i>native declaration : jxl/encode.h:40</i> */
		int JXL_ENC_SUCCESS = 0;
		/** <i>native declaration : jxl/encode.h:44</i> */
		int JXL_ENC_ERROR = 1;
		/** <i>native declaration : jxl/encode.h:48</i> */
		int JXL_ENC_NEED_MORE_OUTPUT = 2;
	};
	/**
	 * <i>native declaration : jxl/encode.h</i><br>
	 * enum values
	 */
	interface JxlEncoderError {
		/** <i>native declaration : jxl/encode.h:60</i> */
		int JXL_ENC_ERR_OK = 0;
		/** <i>native declaration : jxl/encode.h:64</i> */
		int JXL_ENC_ERR_GENERIC = 1;
		/** <i>native declaration : jxl/encode.h:69</i> */
		int JXL_ENC_ERR_OOM = 2;
		/** <i>native declaration : jxl/encode.h:74</i> */
		int JXL_ENC_ERR_JBRD = 3;
		/** <i>native declaration : jxl/encode.h:78</i> */
		int JXL_ENC_ERR_BAD_INPUT = 4;
		/** <i>native declaration : jxl/encode.h:84</i> */
		int JXL_ENC_ERR_NOT_SUPPORTED = 0x80;
		/** <i>native declaration : jxl/encode.h:90</i> */
		int JXL_ENC_ERR_API_USAGE = 0x81;
	};
	/**
	 * <i>native declaration : jxl/encode.h</i><br>
	 * enum values
	 */
	interface JxlEncoderFrameSettingId {
		/** <i>native declaration : jxl/encode.h:106</i> */
		int JXL_ENC_FRAME_SETTING_EFFORT = 0;
		/** <i>native declaration : jxl/encode.h:112</i> */
		int JXL_ENC_FRAME_SETTING_DECODING_SPEED = 1;
		/** <i>native declaration : jxl/encode.h:120</i> */
		int JXL_ENC_FRAME_SETTING_RESAMPLING = 2;
		/** <i>native declaration : jxl/encode.h:127</i> */
		int JXL_ENC_FRAME_SETTING_EXTRA_CHANNEL_RESAMPLING = 3;
		/** <i>native declaration : jxl/encode.h:138</i> */
		int JXL_ENC_FRAME_SETTING_ALREADY_DOWNSAMPLED = 4;
		/** <i>native declaration : jxl/encode.h:145</i> */
		int JXL_ENC_FRAME_SETTING_PHOTON_NOISE = 5;
		/** <i>native declaration : jxl/encode.h:151</i> */
		int JXL_ENC_FRAME_SETTING_NOISE = 6;
		/** <i>native declaration : jxl/encode.h:156</i> */
		int JXL_ENC_FRAME_SETTING_DOTS = 7;
		/** <i>native declaration : jxl/encode.h:161</i> */
		int JXL_ENC_FRAME_SETTING_PATCHES = 8;
		/** <i>native declaration : jxl/encode.h:166</i> */
		int JXL_ENC_FRAME_SETTING_EPF = 9;
		/** <i>native declaration : jxl/encode.h:171</i> */
		int JXL_ENC_FRAME_SETTING_GABORISH = 10;
		/** <i>native declaration : jxl/encode.h:177</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR = 11;
		/** <i>native declaration : jxl/encode.h:182</i> */
		int JXL_ENC_FRAME_SETTING_KEEP_INVISIBLE = 12;
		/** <i>native declaration : jxl/encode.h:188</i> */
		int JXL_ENC_FRAME_SETTING_GROUP_ORDER = 13;
		/** <i>native declaration : jxl/encode.h:194</i> */
		int JXL_ENC_FRAME_SETTING_GROUP_ORDER_CENTER_X = 14;
		/** <i>native declaration : jxl/encode.h:199</i> */
		int JXL_ENC_FRAME_SETTING_GROUP_ORDER_CENTER_Y = 15;
		/** <i>native declaration : jxl/encode.h:204</i> */
		int JXL_ENC_FRAME_SETTING_RESPONSIVE = 16;
		/** <i>native declaration : jxl/encode.h:210</i> */
		int JXL_ENC_FRAME_SETTING_PROGRESSIVE_AC = 17;
		/** <i>native declaration : jxl/encode.h:216</i> */
		int JXL_ENC_FRAME_SETTING_QPROGRESSIVE_AC = 18;
		/** <i>native declaration : jxl/encode.h:222</i> */
		int JXL_ENC_FRAME_SETTING_PROGRESSIVE_DC = 19;
		/** <i>native declaration : jxl/encode.h:228</i> */
		int JXL_ENC_FRAME_SETTING_CHANNEL_COLORS_GLOBAL_PERCENT = 20;
		/** <i>native declaration : jxl/encode.h:234</i> */
		int JXL_ENC_FRAME_SETTING_CHANNEL_COLORS_GROUP_PERCENT = 21;
		/** <i>native declaration : jxl/encode.h:239</i> */
		int JXL_ENC_FRAME_SETTING_PALETTE_COLORS = 22;
		/** <i>native declaration : jxl/encode.h:244</i> */
		int JXL_ENC_FRAME_SETTING_LOSSY_PALETTE = 23;
		/** <i>native declaration : jxl/encode.h:251</i> */
		int JXL_ENC_FRAME_SETTING_COLOR_TRANSFORM = 24;
		/** <i>native declaration : jxl/encode.h:260</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_COLOR_SPACE = 25;
		/** <i>native declaration : jxl/encode.h:264</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_GROUP_SIZE = 26;
		/** <i>native declaration : jxl/encode.h:271</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_PREDICTOR = 27;
		/** <i>native declaration : jxl/encode.h:277</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_MA_TREE_LEARNING_PERCENT = 28;
		/** <i>native declaration : jxl/encode.h:285</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_NB_PREV_CHANNELS = 29;
		/** <i>native declaration : jxl/encode.h:290</i> */
		int JXL_ENC_FRAME_SETTING_JPEG_RECON_CFL = 30;
		/** <i>native declaration : jxl/encode.h:301</i> */
		int JXL_ENC_FRAME_INDEX_BOX = 31;
		/** <i>native declaration : jxl/encode.h:308</i> */
		int JXL_ENC_FRAME_SETTING_BROTLI_EFFORT = 32;
		/** <i>native declaration : jxl/encode.h:315</i> */
		int JXL_ENC_FRAME_SETTING_JPEG_COMPRESS_BOXES = 33;
		/** <i>native declaration : jxl/encode.h:328</i> */
		int JXL_ENC_FRAME_SETTING_BUFFERING = 34;
		/** <i>native declaration : jxl/encode.h:337</i> */
		int JXL_ENC_FRAME_SETTING_JPEG_KEEP_EXIF = 35;
		/** <i>native declaration : jxl/encode.h:345</i> */
		int JXL_ENC_FRAME_SETTING_JPEG_KEEP_XMP = 36;
		/** <i>native declaration : jxl/encode.h:352</i> */
		int JXL_ENC_FRAME_SETTING_JPEG_KEEP_JUMBF = 37;
		/** <i>native declaration : jxl/encode.h:357</i> */
		int JXL_ENC_FRAME_SETTING_FILL_ENUM = 65535;
	};
	/** <i>native declaration : jxl/encode.h</i> */
	public interface JxlDebugImageCallback extends Callback {
		void apply(Pointer opaque, Pointer label, NativeLong xsize, NativeLong ysize, JxlColorEncoding color, ShortByReference pixels);
	};
	/**
	 * Encoder library version.<br>
	 * @return the encoder library version as an integer:<br>
	 * MAJOR_VERSION * 1000000 + MINOR_VERSION * 1000 + PATCH_VERSION. For example,<br>
	 * version 1.2.3 would return 1002003.<br>
	 * Original signature : <code>uint32_t JxlEncoderVersion()</code><br>
	 * <i>native declaration : jxl/encode.h:13</i>
	 */
	int JxlEncoderVersion();
	/**
	 * Creates an instance of JxlEncoder and initializes it.<br>
	 * @p memory_manager will be used for all the library dynamic allocations made<br>
	 * from this instance. The parameter may be NULL, in which case the default<br>
	 * allocator will be used. See jpegxl/memory_manager.h for details.<br>
	 * @param memory_manager custom allocator function. It may be NULL. The memory<br>
	 *        manager will be copied internally.<br>
	 * @return @c NULL if the instance can not be allocated or initialized<br>
	 * @return pointer to initialized JxlEncoder otherwise<br>
	 * Original signature : <code>JxlEncoder* JxlEncoderCreate(const JxlMemoryManagerStruct*)</code><br>
	 * <i>native declaration : jxl/encode.h:373</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderCreate(JxlMemoryManagerStruct[])} and {@link #JxlEncoderCreate(JxlMemoryManagerStruct)} instead
	 */
	@Deprecated 
	PointerByReference JxlEncoderCreate(JxlMemoryManagerStruct memory_manager);
	/**
	 * Creates an instance of JxlEncoder and initializes it.<br>
	 * @p memory_manager will be used for all the library dynamic allocations made<br>
	 * from this instance. The parameter may be NULL, in which case the default<br>
	 * allocator will be used. See jpegxl/memory_manager.h for details.<br>
	 * @param memory_manager custom allocator function. It may be NULL. The memory<br>
	 *        manager will be copied internally.<br>
	 * @return @c NULL if the instance can not be allocated or initialized<br>
	 * @return pointer to initialized JxlEncoder otherwise<br>
	 * Original signature : <code>JxlEncoder* JxlEncoderCreate(const JxlMemoryManagerStruct*)</code><br>
	 * <i>native declaration : jxl/encode.h:373</i>
	 */
	PointerByReference JxlEncoderCreate(JxlMemoryManagerStruct memory_manager[]);
	/**
	 * Re-initializes a JxlEncoder instance, so it can be re-used for encoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with JxlEncoderCreate, but the memory manager is kept.<br>
	 * @param enc instance to be re-initialized.<br>
	 * Original signature : <code>void JxlEncoderReset(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:382</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderReset(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderReset(Pointer enc);
	/**
	 * Re-initializes a JxlEncoder instance, so it can be re-used for encoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with JxlEncoderCreate, but the memory manager is kept.<br>
	 * @param enc instance to be re-initialized.<br>
	 * Original signature : <code>void JxlEncoderReset(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:382</i>
	 */
	void JxlEncoderReset(PointerByReference enc);
	/**
	 * Deinitializes and frees JxlEncoder instance.<br>
	 * @param enc instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlEncoderDestroy(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:389</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderDestroy(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderDestroy(Pointer enc);
	/**
	 * Deinitializes and frees JxlEncoder instance.<br>
	 * @param enc instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlEncoderDestroy(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:389</i>
	 */
	void JxlEncoderDestroy(PointerByReference enc);
	/**
	 * Sets the color management system (CMS) that will be used for color conversion<br>
	 * (if applicable) during encoding. May only be set before starting encoding. If<br>
	 * left unset, the default CMS implementation will be used.<br>
	 * @param enc encoder object.<br>
	 * @param cms structure representing a CMS implementation. See JxlCmsInterface<br>
	 * for more details.<br>
	 * Original signature : <code>void JxlEncoderSetCms(JxlEncoder*, JxlCmsInterface)</code><br>
	 * <i>native declaration : jxl/encode.h:400</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetCms(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlCmsInterface)} instead
	 */
	@Deprecated 
	void JxlEncoderSetCms(Pointer enc, JxlCmsInterface cms);
	/**
	 * Sets the color management system (CMS) that will be used for color conversion<br>
	 * (if applicable) during encoding. May only be set before starting encoding. If<br>
	 * left unset, the default CMS implementation will be used.<br>
	 * @param enc encoder object.<br>
	 * @param cms structure representing a CMS implementation. See JxlCmsInterface<br>
	 * for more details.<br>
	 * Original signature : <code>void JxlEncoderSetCms(JxlEncoder*, JxlCmsInterface)</code><br>
	 * <i>native declaration : jxl/encode.h:400</i>
	 */
	void JxlEncoderSetCms(PointerByReference enc, JxlCmsInterface cms);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * encoding.<br>
	 * @param enc encoder object.<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *        be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *        runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return JXL_ENC_SUCCESS if the runner was set, JXL_ENC_ERROR<br>
	 * otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetParallelRunner(JxlEncoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/encode.h:414</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetParallelRunner(com.sun.jna.ptr.PointerByReference, Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlEncoderSetParallelRunner(Pointer enc, Pointer /* JxlParallelRunner */ parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * encoding.<br>
	 * @param enc encoder object.<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *        be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *        runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return JXL_ENC_SUCCESS if the runner was set, JXL_ENC_ERROR<br>
	 * otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetParallelRunner(JxlEncoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/encode.h:414</i>
	 */
	int JxlEncoderSetParallelRunner(PointerByReference enc, Pointer /* JxlParallelRunner */ parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Get the (last) error code in case JXL_ENC_ERROR was returned.<br>
	 * @param enc encoder object.<br>
	 * @return the JxlEncoderError that caused the (last) JXL_ENC_ERROR to be<br>
	 * returned.<br>
	 * Original signature : <code>JxlEncoderError JxlEncoderGetError(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:425</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderGetError(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlEncoderGetError(Pointer enc);
	/**
	 * Get the (last) error code in case JXL_ENC_ERROR was returned.<br>
	 * @param enc encoder object.<br>
	 * @return the JxlEncoderError that caused the (last) JXL_ENC_ERROR to be<br>
	 * returned.<br>
	 * Original signature : <code>JxlEncoderError JxlEncoderGetError(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:425</i>
	 */
	int JxlEncoderGetError(PointerByReference enc);
	/**
	 * Encodes JPEG XL file using the available bytes. @p *avail_out indicates how<br>
	 * many output bytes are available, and @p *next_out points to the input bytes.<br>
	 * *avail_out will be decremented by the amount of bytes that have been<br>
	 * processed by the encoder and *next_out will be incremented by the same<br>
	 * amount, so *next_out will now point at the amount of *avail_out unprocessed<br>
	 * bytes.<br>
	 * The returned status indicates whether the encoder needs more output bytes.<br>
	 * When the return value is not JXL_ENC_ERROR or JXL_ENC_SUCCESS, the encoding<br>
	 * requires more JxlEncoderProcessOutput calls to continue.<br>
	 * The caller must guarantee that *avail_out >= 32 when calling<br>
	 * JxlEncoderProcessOutput; otherwise, JXL_ENC_NEED_MORE_OUTPUT will be<br>
	 * returned. It is guaranteed that, if *avail_out >= 32, at least one byte of<br>
	 * output will be written.<br>
	 * This encodes the frames and/or boxes added so far. If the last frame or last<br>
	 * box has been added, @ref JxlEncoderCloseInput, @ref JxlEncoderCloseFrames<br>
	 * and/or @ref JxlEncoderCloseBoxes must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call, or the codestream won't be encoded<br>
	 * correctly.<br>
	 * @param enc encoder object.<br>
	 * @param next_out pointer to next bytes to write to.<br>
	 * @param avail_out amount of bytes available starting from *next_out.<br>
	 * @return JXL_ENC_SUCCESS when encoding finished and all events handled.<br>
	 * @return JXL_ENC_ERROR when encoding failed, e.g. invalid input.<br>
	 * @return JXL_ENC_NEED_MORE_OUTPUT more output buffer is necessary.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderProcessOutput(JxlEncoder*, uint8_t**, size_t*)</code><br>
	 * <i>native declaration : jxl/encode.h:457</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderProcessOutput(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, NativeLongByReference)} instead
	 */
	@Deprecated 
	int JxlEncoderProcessOutput(Pointer enc, PointerByReference next_out, NativeLongByReference avail_out);
	/**
	 * Encodes JPEG XL file using the available bytes. @p *avail_out indicates how<br>
	 * many output bytes are available, and @p *next_out points to the input bytes.<br>
	 * *avail_out will be decremented by the amount of bytes that have been<br>
	 * processed by the encoder and *next_out will be incremented by the same<br>
	 * amount, so *next_out will now point at the amount of *avail_out unprocessed<br>
	 * bytes.<br>
	 * The returned status indicates whether the encoder needs more output bytes.<br>
	 * When the return value is not JXL_ENC_ERROR or JXL_ENC_SUCCESS, the encoding<br>
	 * requires more JxlEncoderProcessOutput calls to continue.<br>
	 * The caller must guarantee that *avail_out >= 32 when calling<br>
	 * JxlEncoderProcessOutput; otherwise, JXL_ENC_NEED_MORE_OUTPUT will be<br>
	 * returned. It is guaranteed that, if *avail_out >= 32, at least one byte of<br>
	 * output will be written.<br>
	 * This encodes the frames and/or boxes added so far. If the last frame or last<br>
	 * box has been added, @ref JxlEncoderCloseInput, @ref JxlEncoderCloseFrames<br>
	 * and/or @ref JxlEncoderCloseBoxes must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call, or the codestream won't be encoded<br>
	 * correctly.<br>
	 * @param enc encoder object.<br>
	 * @param next_out pointer to next bytes to write to.<br>
	 * @param avail_out amount of bytes available starting from *next_out.<br>
	 * @return JXL_ENC_SUCCESS when encoding finished and all events handled.<br>
	 * @return JXL_ENC_ERROR when encoding failed, e.g. invalid input.<br>
	 * @return JXL_ENC_NEED_MORE_OUTPUT more output buffer is necessary.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderProcessOutput(JxlEncoder*, uint8_t**, size_t*)</code><br>
	 * <i>native declaration : jxl/encode.h:457</i>
	 */
	int JxlEncoderProcessOutput(PointerByReference enc, PointerByReference next_out, NativeLongByReference avail_out);
	/**
	 * Sets the frame information for this frame to the encoder. This includes<br>
	 * animation information such as frame duration to store in the frame header.<br>
	 * The frame header fields represent the frame as passed to the encoder, but not<br>
	 * necessarily the exact values as they will be encoded file format: the encoder<br>
	 * could change crop and blending options of a frame for more efficient encoding<br>
	 * or introduce additional internal frames. Animation duration and time code<br>
	 * information is not altered since those are immutable metadata of the frame.<br>
	 * It is not required to use this function, however if have_animation is set<br>
	 * to true in the basic info, then this function should be used to set the<br>
	 * time duration of this individual frame. By default individual frames have a<br>
	 * time duration of 0, making them form a composite still. See @ref<br>
	 * JxlFrameHeader for more information.<br>
	 * This information is stored in the JxlEncoderFrameSettings and so is used for<br>
	 * any frame encoded with these JxlEncoderFrameSettings. It is ok to change<br>
	 * between @ref JxlEncoderAddImageFrame calls, each added image frame will have<br>
	 * the frame header that was set in the options at the time of calling<br>
	 * JxlEncoderAddImageFrame.<br>
	 * The is_last and name_length fields of the JxlFrameHeader are ignored, use<br>
	 * @ref JxlEncoderCloseFrames to indicate last frame, and @ref<br>
	 * JxlEncoderSetFrameName to indicate the name and its length instead.<br>
	 * Calling this function will clear any name that was previously set with @ref<br>
	 * JxlEncoderSetFrameName.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_header frame header data to set. Object owned by the caller and<br>
	 * does not need to be kept in memory, its information is copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameHeader(JxlEncoderFrameSettings*, const JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/encode.h:494</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetFrameHeader(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlFrameHeader[])} and {@link #JxlEncoderSetFrameHeader(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlFrameHeader)} instead
	 */
	@Deprecated 
	int JxlEncoderSetFrameHeader(Pointer frame_settings, JxlFrameHeader frame_header);
	/**
	 * Sets the frame information for this frame to the encoder. This includes<br>
	 * animation information such as frame duration to store in the frame header.<br>
	 * The frame header fields represent the frame as passed to the encoder, but not<br>
	 * necessarily the exact values as they will be encoded file format: the encoder<br>
	 * could change crop and blending options of a frame for more efficient encoding<br>
	 * or introduce additional internal frames. Animation duration and time code<br>
	 * information is not altered since those are immutable metadata of the frame.<br>
	 * It is not required to use this function, however if have_animation is set<br>
	 * to true in the basic info, then this function should be used to set the<br>
	 * time duration of this individual frame. By default individual frames have a<br>
	 * time duration of 0, making them form a composite still. See @ref<br>
	 * JxlFrameHeader for more information.<br>
	 * This information is stored in the JxlEncoderFrameSettings and so is used for<br>
	 * any frame encoded with these JxlEncoderFrameSettings. It is ok to change<br>
	 * between @ref JxlEncoderAddImageFrame calls, each added image frame will have<br>
	 * the frame header that was set in the options at the time of calling<br>
	 * JxlEncoderAddImageFrame.<br>
	 * The is_last and name_length fields of the JxlFrameHeader are ignored, use<br>
	 * @ref JxlEncoderCloseFrames to indicate last frame, and @ref<br>
	 * JxlEncoderSetFrameName to indicate the name and its length instead.<br>
	 * Calling this function will clear any name that was previously set with @ref<br>
	 * JxlEncoderSetFrameName.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_header frame header data to set. Object owned by the caller and<br>
	 * does not need to be kept in memory, its information is copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameHeader(JxlEncoderFrameSettings*, const JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/encode.h:494</i>
	 */
	int JxlEncoderSetFrameHeader(PointerByReference frame_settings, JxlFrameHeader frame_header[]);
	/**
	 * Sets the frame information for this frame to the encoder. This includes<br>
	 * animation information such as frame duration to store in the frame header.<br>
	 * The frame header fields represent the frame as passed to the encoder, but not<br>
	 * necessarily the exact values as they will be encoded file format: the encoder<br>
	 * could change crop and blending options of a frame for more efficient encoding<br>
	 * or introduce additional internal frames. Animation duration and time code<br>
	 * information is not altered since those are immutable metadata of the frame.<br>
	 * It is not required to use this function, however if have_animation is set<br>
	 * to true in the basic info, then this function should be used to set the<br>
	 * time duration of this individual frame. By default individual frames have a<br>
	 * time duration of 0, making them form a composite still. See @ref<br>
	 * JxlFrameHeader for more information.<br>
	 * This information is stored in the JxlEncoderFrameSettings and so is used for<br>
	 * any frame encoded with these JxlEncoderFrameSettings. It is ok to change<br>
	 * between @ref JxlEncoderAddImageFrame calls, each added image frame will have<br>
	 * the frame header that was set in the options at the time of calling<br>
	 * JxlEncoderAddImageFrame.<br>
	 * The is_last and name_length fields of the JxlFrameHeader are ignored, use<br>
	 * @ref JxlEncoderCloseFrames to indicate last frame, and @ref<br>
	 * JxlEncoderSetFrameName to indicate the name and its length instead.<br>
	 * Calling this function will clear any name that was previously set with @ref<br>
	 * JxlEncoderSetFrameName.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_header frame header data to set. Object owned by the caller and<br>
	 * does not need to be kept in memory, its information is copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameHeader(JxlEncoderFrameSettings*, const JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/encode.h:494</i>
	 */
	int JxlEncoderSetFrameHeader(PointerByReference frame_settings, JxlFrameHeader frame_header);
	/**
	 * Sets blend info of an extra channel. The blend info of extra channels is set<br>
	 * separately from that of the color channels, the color channels are set with<br>
	 * @ref JxlEncoderSetFrameHeader.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param index index of the extra channel to use.<br>
	 * @param blend_info blend info to set for the extra channel<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBlendInfo(JxlEncoderFrameSettings*, size_t, const JxlBlendInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:509</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetExtraChannelBlendInfo(com.sun.jna.ptr.PointerByReference, NativeLong, vavi.awt.image.jna.jpegxl.JxlBlendInfo[])} and {@link #JxlEncoderSetExtraChannelBlendInfo(com.sun.jna.ptr.PointerByReference, NativeLong, vavi.awt.image.jna.jpegxl.JxlBlendInfo)} instead
	 */
	@Deprecated 
	int JxlEncoderSetExtraChannelBlendInfo(Pointer frame_settings, NativeLong index, JxlBlendInfo blend_info);
	/**
	 * Sets blend info of an extra channel. The blend info of extra channels is set<br>
	 * separately from that of the color channels, the color channels are set with<br>
	 * @ref JxlEncoderSetFrameHeader.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param index index of the extra channel to use.<br>
	 * @param blend_info blend info to set for the extra channel<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBlendInfo(JxlEncoderFrameSettings*, size_t, const JxlBlendInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:509</i>
	 */
	int JxlEncoderSetExtraChannelBlendInfo(PointerByReference frame_settings, NativeLong index, JxlBlendInfo blend_info[]);
	/**
	 * Sets blend info of an extra channel. The blend info of extra channels is set<br>
	 * separately from that of the color channels, the color channels are set with<br>
	 * @ref JxlEncoderSetFrameHeader.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param index index of the extra channel to use.<br>
	 * @param blend_info blend info to set for the extra channel<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBlendInfo(JxlEncoderFrameSettings*, size_t, const JxlBlendInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:509</i>
	 */
	int JxlEncoderSetExtraChannelBlendInfo(PointerByReference frame_settings, NativeLong index, JxlBlendInfo blend_info);
	/**
	 * Sets the name of the animation frame. This function is optional, frames are<br>
	 * not required to have a name. This setting is a part of the frame header, and<br>
	 * the same principles as for @ref JxlEncoderSetFrameHeader apply. The<br>
	 * name_length field of JxlFrameHeader is ignored by the encoder, this function<br>
	 * determines the name length instead as the length in bytes of the C string.<br>
	 * The maximum possible name length is 1071 bytes (excluding terminating null<br>
	 * character).<br>
	 * Calling @ref JxlEncoderSetFrameHeader clears any name that was<br>
	 * previously set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_name name of the next frame to be encoded, as a UTF-8 encoded C<br>
	 * string (zero terminated). Owned by the caller, and copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameName(JxlEncoderFrameSettings*, const char*)</code><br>
	 * <i>native declaration : jxl/encode.h:532</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetFrameName(com.sun.jna.ptr.PointerByReference, java.lang.String)} and {@link #JxlEncoderSetFrameName(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlEncoderSetFrameName(Pointer frame_settings, Pointer frame_name);
	/**
	 * Sets the name of the animation frame. This function is optional, frames are<br>
	 * not required to have a name. This setting is a part of the frame header, and<br>
	 * the same principles as for @ref JxlEncoderSetFrameHeader apply. The<br>
	 * name_length field of JxlFrameHeader is ignored by the encoder, this function<br>
	 * determines the name length instead as the length in bytes of the C string.<br>
	 * The maximum possible name length is 1071 bytes (excluding terminating null<br>
	 * character).<br>
	 * Calling @ref JxlEncoderSetFrameHeader clears any name that was<br>
	 * previously set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_name name of the next frame to be encoded, as a UTF-8 encoded C<br>
	 * string (zero terminated). Owned by the caller, and copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameName(JxlEncoderFrameSettings*, const char*)</code><br>
	 * <i>native declaration : jxl/encode.h:532</i>
	 */
	int JxlEncoderSetFrameName(PointerByReference frame_settings, String frame_name);
	/**
	 * Sets the name of the animation frame. This function is optional, frames are<br>
	 * not required to have a name. This setting is a part of the frame header, and<br>
	 * the same principles as for @ref JxlEncoderSetFrameHeader apply. The<br>
	 * name_length field of JxlFrameHeader is ignored by the encoder, this function<br>
	 * determines the name length instead as the length in bytes of the C string.<br>
	 * The maximum possible name length is 1071 bytes (excluding terminating null<br>
	 * character).<br>
	 * Calling @ref JxlEncoderSetFrameHeader clears any name that was<br>
	 * previously set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_name name of the next frame to be encoded, as a UTF-8 encoded C<br>
	 * string (zero terminated). Owned by the caller, and copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameName(JxlEncoderFrameSettings*, const char*)</code><br>
	 * <i>native declaration : jxl/encode.h:532</i>
	 */
	int JxlEncoderSetFrameName(PointerByReference frame_settings, Pointer frame_name);
	/**
	 * Sets the bit depth of the input buffer.<br>
	 * For float pixel formats, only the default JXL_BIT_DEPTH_FROM_PIXEL_FORMAT<br>
	 * setting is allowed, while for unsigned pixel formats,<br>
	 * JXL_BIT_DEPTH_FROM_CODESTREAM setting is also allowed. See the comment on<br>
	 * @ref JxlEncoderAddImageFrame for the effects of the bit depth setting.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param bit_depth the bit depth setting of the pixel input<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameBitDepth(JxlEncoderFrameSettings*, const JxlBitDepth*)</code><br>
	 * <i>native declaration : jxl/encode.h:548</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetFrameBitDepth(com.sun.jna.ptr.PointerByReference, JxlBitDepth[])} and {@link #JxlEncoderSetFrameBitDepth(com.sun.jna.ptr.PointerByReference, JxlBitDepth)} instead
	 */
	@Deprecated 
	int JxlEncoderSetFrameBitDepth(Pointer frame_settings, JxlBitDepth bit_depth);
	/**
	 * Sets the bit depth of the input buffer.<br>
	 * For float pixel formats, only the default JXL_BIT_DEPTH_FROM_PIXEL_FORMAT<br>
	 * setting is allowed, while for unsigned pixel formats,<br>
	 * JXL_BIT_DEPTH_FROM_CODESTREAM setting is also allowed. See the comment on<br>
	 * @ref JxlEncoderAddImageFrame for the effects of the bit depth setting.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param bit_depth the bit depth setting of the pixel input<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameBitDepth(JxlEncoderFrameSettings*, const JxlBitDepth*)</code><br>
	 * <i>native declaration : jxl/encode.h:548</i>
	 */
	int JxlEncoderSetFrameBitDepth(PointerByReference frame_settings, JxlBitDepth bit_depth[]);
	/**
	 * Sets the bit depth of the input buffer.<br>
	 * For float pixel formats, only the default JXL_BIT_DEPTH_FROM_PIXEL_FORMAT<br>
	 * setting is allowed, while for unsigned pixel formats,<br>
	 * JXL_BIT_DEPTH_FROM_CODESTREAM setting is also allowed. See the comment on<br>
	 * @ref JxlEncoderAddImageFrame for the effects of the bit depth setting.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param bit_depth the bit depth setting of the pixel input<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameBitDepth(JxlEncoderFrameSettings*, const JxlBitDepth*)</code><br>
	 * <i>native declaration : jxl/encode.h:548</i>
	 */
	int JxlEncoderSetFrameBitDepth(PointerByReference frame_settings, JxlBitDepth bit_depth);
	/**
	 * Sets the buffer to read JPEG encoded bytes from for the next frame to encode.<br>
	 * If JxlEncoderSetBasicInfo has not yet been called, calling<br>
	 * JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the<br>
	 * added JPEG frame.<br>
	 * If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been<br>
	 * called, calling JxlEncoderAddJPEGFrame will implicitly call it with the<br>
	 * parameters of the added JPEG frame.<br>
	 * If the encoder is set to store JPEG reconstruction metadata using @ref<br>
	 * JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param buffer bytes to read JPEG from. Owned by the caller and its contents<br>
	 * are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddJPEGFrame(const JxlEncoderFrameSettings*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:577</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderAddJPEGFrame(com.sun.jna.ptr.PointerByReference, byte[], NativeLong)} and {@link #JxlEncoderAddJPEGFrame(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlEncoderAddJPEGFrame(Pointer frame_settings, Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to read JPEG encoded bytes from for the next frame to encode.<br>
	 * If JxlEncoderSetBasicInfo has not yet been called, calling<br>
	 * JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the<br>
	 * added JPEG frame.<br>
	 * If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been<br>
	 * called, calling JxlEncoderAddJPEGFrame will implicitly call it with the<br>
	 * parameters of the added JPEG frame.<br>
	 * If the encoder is set to store JPEG reconstruction metadata using @ref<br>
	 * JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param buffer bytes to read JPEG from. Owned by the caller and its contents<br>
	 * are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddJPEGFrame(const JxlEncoderFrameSettings*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:577</i>
	 */
	int JxlEncoderAddJPEGFrame(PointerByReference frame_settings, byte buffer[], NativeLong size);
	/**
	 * Sets the buffer to read JPEG encoded bytes from for the next frame to encode.<br>
	 * If JxlEncoderSetBasicInfo has not yet been called, calling<br>
	 * JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the<br>
	 * added JPEG frame.<br>
	 * If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been<br>
	 * called, calling JxlEncoderAddJPEGFrame will implicitly call it with the<br>
	 * parameters of the added JPEG frame.<br>
	 * If the encoder is set to store JPEG reconstruction metadata using @ref<br>
	 * JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param buffer bytes to read JPEG from. Owned by the caller and its contents<br>
	 * are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddJPEGFrame(const JxlEncoderFrameSettings*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:577</i>
	 */
	int JxlEncoderAddJPEGFrame(PointerByReference frame_settings, Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to read pixels from for the next image to encode. Must call<br>
	 * JxlEncoderSetBasicInfo before JxlEncoderAddImageFrame.<br>
	 * Currently only some data types for pixel formats are supported:<br>
	 * - JXL_TYPE_UINT8, with range 0..255<br>
	 * - JXL_TYPE_UINT16, with range 0..65535<br>
	 * - JXL_TYPE_FLOAT16, with nominal range 0..1<br>
	 * - JXL_TYPE_FLOAT, with nominal range 0..1<br>
	 * Note: the sample data type in pixel_format is allowed to be different from<br>
	 * what is described in the JxlBasicInfo. The type in pixel_format, together<br>
	 * with an optional @ref JxlBitDepth parameter set by @ref<br>
	 * JxlEncoderSetFrameBitDepth describes the format of the uncompressed pixel<br>
	 * buffer. The bits_per_sample and exponent_bits_per_sample in the JxlBasicInfo<br>
	 * describes what will actually be encoded in the JPEG XL codestream.<br>
	 * For example, to encode a 12-bit image, you would set bits_per_sample to 12,<br>
	 * while the input frame buffer can be in the following formats:<br>
	 *  - if pixel format is in JXL_TYPE_UINT16 with default bit depth setting<br>
	 *    (i.e. JXL_BIT_DEPTH_FROM_PIXEL_FORMAT), input sample values are rescaled<br>
	 *    to 16-bit, i.e. multiplied by 65535/4095;<br>
	 *  - if pixel format is in JXL_TYPE_UINT16 with JXL_BIT_DEPTH_FROM_CODESTREAM<br>
	 *    bit depth setting, input sample values are provided unscaled;<br>
	 *  - if pixel format is in JXL_TYPE_FLOAT, input sample values are rescaled<br>
	 *    to 0..1, i.e.  multiplied by 1.f/4095.f.<br>
	 * While it is allowed, it is obviously not recommended to use a pixel_format<br>
	 * with lower precision than what is specified in the JxlBasicInfo.<br>
	 * We support interleaved channels as described by the JxlPixelFormat:<br>
	 * - single-channel data, e.g. grayscale<br>
	 * - single-channel + alpha<br>
	 * - trichromatic, e.g. RGB<br>
	 * - trichromatic + alpha<br>
	 * Extra channels not handled here need to be set by @ref<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * If the image has alpha, and alpha is not passed here, it will implicitly be<br>
	 * set to all-opaque (an alpha value of 1.0 everywhere).<br>
	 * The pixels are assumed to be encoded in the original profile that is set with<br>
	 * JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile. If none of these<br>
	 * functions were used, the pixels are assumed to be nonlinear sRGB for integer<br>
	 * data types (JXL_TYPE_UINT8, JXL_TYPE_UINT16), and linear sRGB for floating<br>
	 * point data types (JXL_TYPE_FLOAT16, JXL_TYPE_FLOAT).<br>
	 * Sample values in floating-point pixel formats are allowed to be outside the<br>
	 * nominal range, e.g. to represent out-of-sRGB-gamut colors in the<br>
	 * uses_original_profile=false case. They are however not allowed to be NaN or<br>
	 * +-infinity.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddImageFrame(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:645</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderAddImageFrame(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], com.sun.jna.Pointer, NativeLong)} and {@link #JxlEncoderAddImageFrame(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlEncoderAddImageFrame(Pointer frame_settings, JxlPixelFormat pixel_format, Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to read pixels from for the next image to encode. Must call<br>
	 * JxlEncoderSetBasicInfo before JxlEncoderAddImageFrame.<br>
	 * Currently only some data types for pixel formats are supported:<br>
	 * - JXL_TYPE_UINT8, with range 0..255<br>
	 * - JXL_TYPE_UINT16, with range 0..65535<br>
	 * - JXL_TYPE_FLOAT16, with nominal range 0..1<br>
	 * - JXL_TYPE_FLOAT, with nominal range 0..1<br>
	 * Note: the sample data type in pixel_format is allowed to be different from<br>
	 * what is described in the JxlBasicInfo. The type in pixel_format, together<br>
	 * with an optional @ref JxlBitDepth parameter set by @ref<br>
	 * JxlEncoderSetFrameBitDepth describes the format of the uncompressed pixel<br>
	 * buffer. The bits_per_sample and exponent_bits_per_sample in the JxlBasicInfo<br>
	 * describes what will actually be encoded in the JPEG XL codestream.<br>
	 * For example, to encode a 12-bit image, you would set bits_per_sample to 12,<br>
	 * while the input frame buffer can be in the following formats:<br>
	 *  - if pixel format is in JXL_TYPE_UINT16 with default bit depth setting<br>
	 *    (i.e. JXL_BIT_DEPTH_FROM_PIXEL_FORMAT), input sample values are rescaled<br>
	 *    to 16-bit, i.e. multiplied by 65535/4095;<br>
	 *  - if pixel format is in JXL_TYPE_UINT16 with JXL_BIT_DEPTH_FROM_CODESTREAM<br>
	 *    bit depth setting, input sample values are provided unscaled;<br>
	 *  - if pixel format is in JXL_TYPE_FLOAT, input sample values are rescaled<br>
	 *    to 0..1, i.e.  multiplied by 1.f/4095.f.<br>
	 * While it is allowed, it is obviously not recommended to use a pixel_format<br>
	 * with lower precision than what is specified in the JxlBasicInfo.<br>
	 * We support interleaved channels as described by the JxlPixelFormat:<br>
	 * - single-channel data, e.g. grayscale<br>
	 * - single-channel + alpha<br>
	 * - trichromatic, e.g. RGB<br>
	 * - trichromatic + alpha<br>
	 * Extra channels not handled here need to be set by @ref<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * If the image has alpha, and alpha is not passed here, it will implicitly be<br>
	 * set to all-opaque (an alpha value of 1.0 everywhere).<br>
	 * The pixels are assumed to be encoded in the original profile that is set with<br>
	 * JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile. If none of these<br>
	 * functions were used, the pixels are assumed to be nonlinear sRGB for integer<br>
	 * data types (JXL_TYPE_UINT8, JXL_TYPE_UINT16), and linear sRGB for floating<br>
	 * point data types (JXL_TYPE_FLOAT16, JXL_TYPE_FLOAT).<br>
	 * Sample values in floating-point pixel formats are allowed to be outside the<br>
	 * nominal range, e.g. to represent out-of-sRGB-gamut colors in the<br>
	 * uses_original_profile=false case. They are however not allowed to be NaN or<br>
	 * +-infinity.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddImageFrame(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:645</i>
	 */
	int JxlEncoderAddImageFrame(PointerByReference frame_settings, JxlPixelFormat pixel_format[], Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to read pixels from for the next image to encode. Must call<br>
	 * JxlEncoderSetBasicInfo before JxlEncoderAddImageFrame.<br>
	 * Currently only some data types for pixel formats are supported:<br>
	 * - JXL_TYPE_UINT8, with range 0..255<br>
	 * - JXL_TYPE_UINT16, with range 0..65535<br>
	 * - JXL_TYPE_FLOAT16, with nominal range 0..1<br>
	 * - JXL_TYPE_FLOAT, with nominal range 0..1<br>
	 * Note: the sample data type in pixel_format is allowed to be different from<br>
	 * what is described in the JxlBasicInfo. The type in pixel_format, together<br>
	 * with an optional @ref JxlBitDepth parameter set by @ref<br>
	 * JxlEncoderSetFrameBitDepth describes the format of the uncompressed pixel<br>
	 * buffer. The bits_per_sample and exponent_bits_per_sample in the JxlBasicInfo<br>
	 * describes what will actually be encoded in the JPEG XL codestream.<br>
	 * For example, to encode a 12-bit image, you would set bits_per_sample to 12,<br>
	 * while the input frame buffer can be in the following formats:<br>
	 *  - if pixel format is in JXL_TYPE_UINT16 with default bit depth setting<br>
	 *    (i.e. JXL_BIT_DEPTH_FROM_PIXEL_FORMAT), input sample values are rescaled<br>
	 *    to 16-bit, i.e. multiplied by 65535/4095;<br>
	 *  - if pixel format is in JXL_TYPE_UINT16 with JXL_BIT_DEPTH_FROM_CODESTREAM<br>
	 *    bit depth setting, input sample values are provided unscaled;<br>
	 *  - if pixel format is in JXL_TYPE_FLOAT, input sample values are rescaled<br>
	 *    to 0..1, i.e.  multiplied by 1.f/4095.f.<br>
	 * While it is allowed, it is obviously not recommended to use a pixel_format<br>
	 * with lower precision than what is specified in the JxlBasicInfo.<br>
	 * We support interleaved channels as described by the JxlPixelFormat:<br>
	 * - single-channel data, e.g. grayscale<br>
	 * - single-channel + alpha<br>
	 * - trichromatic, e.g. RGB<br>
	 * - trichromatic + alpha<br>
	 * Extra channels not handled here need to be set by @ref<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * If the image has alpha, and alpha is not passed here, it will implicitly be<br>
	 * set to all-opaque (an alpha value of 1.0 everywhere).<br>
	 * The pixels are assumed to be encoded in the original profile that is set with<br>
	 * JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile. If none of these<br>
	 * functions were used, the pixels are assumed to be nonlinear sRGB for integer<br>
	 * data types (JXL_TYPE_UINT8, JXL_TYPE_UINT16), and linear sRGB for floating<br>
	 * point data types (JXL_TYPE_FLOAT16, JXL_TYPE_FLOAT).<br>
	 * Sample values in floating-point pixel formats are allowed to be outside the<br>
	 * nominal range, e.g. to represent out-of-sRGB-gamut colors in the<br>
	 * uses_original_profile=false case. They are however not allowed to be NaN or<br>
	 * +-infinity.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddImageFrame(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:645</i>
	 */
	int JxlEncoderAddImageFrame(PointerByReference frame_settings, JxlPixelFormat pixel_format, Pointer buffer, NativeLong size);
	/**
	 * Sets the output processor for the encoder. This processor determines how the<br>
	 * encoder will handle buffering, writing, seeking (if supported), and<br>
	 * setting a finalized position during the encoding process.<br>
	 * This should not be used when using @ref JxlEncoderProcessOutput.<br>
	 * @param enc encoder object.<br>
	 * @param output_processor the struct containing the callbacks for managing<br>
	 * output.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetOutputProcessor(JxlEncoder*, JxlEncoderOutputProcessor)</code><br>
	 * <i>native declaration : jxl/encode.h:754</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetOutputProcessor(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.encode.JxlEncoderOutputProcessor.ByValue)} instead
	 */
	@Deprecated 
	int JxlEncoderSetOutputProcessor(Pointer enc, vavi.awt.image.jna.jpegxl.encode.JxlEncoderOutputProcessor.ByValue output_processor);
	/**
	 * Sets the output processor for the encoder. This processor determines how the<br>
	 * encoder will handle buffering, writing, seeking (if supported), and<br>
	 * setting a finalized position during the encoding process.<br>
	 * This should not be used when using @ref JxlEncoderProcessOutput.<br>
	 * @param enc encoder object.<br>
	 * @param output_processor the struct containing the callbacks for managing<br>
	 * output.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetOutputProcessor(JxlEncoder*, JxlEncoderOutputProcessor)</code><br>
	 * <i>native declaration : jxl/encode.h:754</i>
	 */
	int JxlEncoderSetOutputProcessor(PointerByReference enc, vavi.awt.image.jna.jpegxl.encode.JxlEncoderOutputProcessor.ByValue output_processor);
	/**
	 * Flushes any buffered input in the encoder, ensuring that all available input<br>
	 * data has been processed and written to the output.<br>
	 * This function can only be used after @ref JxlEncoderSetOutputProcessor.<br>
	 * Before making the last call to @ref JxlEncoderFlushInput, users should call<br>
	 * @ref JxlEncoderCloseInput to signal the end of input data.<br>
	 * This should not be used when using @ref JxlEncoderProcessOutput.<br>
	 * @param enc encoder object.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFlushInput(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:770</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderFlushInput(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlEncoderFlushInput(Pointer enc);
	/**
	 * Flushes any buffered input in the encoder, ensuring that all available input<br>
	 * data has been processed and written to the output.<br>
	 * This function can only be used after @ref JxlEncoderSetOutputProcessor.<br>
	 * Before making the last call to @ref JxlEncoderFlushInput, users should call<br>
	 * @ref JxlEncoderCloseInput to signal the end of input data.<br>
	 * This should not be used when using @ref JxlEncoderProcessOutput.<br>
	 * @param enc encoder object.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFlushInput(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:770</i>
	 */
	int JxlEncoderFlushInput(PointerByReference enc);
	/**
	 * @brief Adds a frame to the encoder using a chunked input source.<br>
	 * This function gives a way to encode a frame by providing pixel data in a<br>
	 * chunked or streaming manner, which can be especially useful when dealing with<br>
	 * large images that may not fit entirely in memory or when trying to optimize<br>
	 * memory usage. The input data is provided through callbacks defined in the<br>
	 * `JxlChunkedFrameInputSource` struct. Once the frame data has been completely<br>
	 * retrieved, this function will flush the input and close it if it is the last<br>
	 * frame.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param is_last_frame indicates if this is the last frame.<br>
	 * @param chunked_frame_input struct providing callback methods for retrieving<br>
	 * pixel data in chunks.<br>
	 * @return Returns a status indicating the success or failure of adding the<br>
	 * frame.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddChunkedFrame(const JxlEncoderFrameSettings*, JXL_BOOL, JxlChunkedFrameInputSource)</code><br>
	 * <i>native declaration : jxl/encode.h:903</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderAddChunkedFrame(com.sun.jna.ptr.PointerByReference, int, vavi.awt.image.jna.jpegxl.encode.JxlChunkedFrameInputSource.ByValue)} instead
	 */
	@Deprecated 
	int JxlEncoderAddChunkedFrame(Pointer frame_settings, int /* JXL_BOOL */ is_last_frame, vavi.awt.image.jna.jpegxl.encode.JxlChunkedFrameInputSource.ByValue chunked_frame_input);
	/**
	 * @brief Adds a frame to the encoder using a chunked input source.<br>
	 * This function gives a way to encode a frame by providing pixel data in a<br>
	 * chunked or streaming manner, which can be especially useful when dealing with<br>
	 * large images that may not fit entirely in memory or when trying to optimize<br>
	 * memory usage. The input data is provided through callbacks defined in the<br>
	 * `JxlChunkedFrameInputSource` struct. Once the frame data has been completely<br>
	 * retrieved, this function will flush the input and close it if it is the last<br>
	 * frame.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param is_last_frame indicates if this is the last frame.<br>
	 * @param chunked_frame_input struct providing callback methods for retrieving<br>
	 * pixel data in chunks.<br>
	 * @return Returns a status indicating the success or failure of adding the<br>
	 * frame.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddChunkedFrame(const JxlEncoderFrameSettings*, JXL_BOOL, JxlChunkedFrameInputSource)</code><br>
	 * <i>native declaration : jxl/encode.h:903</i>
	 */
	int JxlEncoderAddChunkedFrame(PointerByReference frame_settings, int /* JXL_BOOL */ is_last_frame, vavi.awt.image.jna.jpegxl.encode.JxlChunkedFrameInputSource.ByValue chunked_frame_input);
	/**
	 * Sets the buffer to read pixels from for an extra channel at a given index.<br>
	 * The index must be smaller than the num_extra_channels in the associated<br>
	 * JxlBasicInfo. Must call @ref JxlEncoderSetExtraChannelInfo before<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * TODO(firsching): mention what data types in pixel formats are supported.<br>
	 * It is required to call this function for every extra channel, except for the<br>
	 * alpha channel if that was already set through @ref JxlEncoderAddImageFrame.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally. The num_channels value is ignored, since the<br>
	 * number of channels for an extra channel is always assumed to be one.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @param index index of the extra channel to use.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBuffer(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/encode.h:930</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetExtraChannelBuffer(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], com.sun.jna.Pointer, NativeLong, int)} and {@link #JxlEncoderSetExtraChannelBuffer(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, com.sun.jna.Pointer, NativeLong, int)} instead
	 */
	@Deprecated 
	int JxlEncoderSetExtraChannelBuffer(Pointer frame_settings, JxlPixelFormat pixel_format, Pointer buffer, NativeLong size, int index);
	/**
	 * Sets the buffer to read pixels from for an extra channel at a given index.<br>
	 * The index must be smaller than the num_extra_channels in the associated<br>
	 * JxlBasicInfo. Must call @ref JxlEncoderSetExtraChannelInfo before<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * TODO(firsching): mention what data types in pixel formats are supported.<br>
	 * It is required to call this function for every extra channel, except for the<br>
	 * alpha channel if that was already set through @ref JxlEncoderAddImageFrame.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally. The num_channels value is ignored, since the<br>
	 * number of channels for an extra channel is always assumed to be one.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @param index index of the extra channel to use.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBuffer(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/encode.h:930</i>
	 */
	int JxlEncoderSetExtraChannelBuffer(PointerByReference frame_settings, JxlPixelFormat pixel_format[], Pointer buffer, NativeLong size, int index);
	/**
	 * Sets the buffer to read pixels from for an extra channel at a given index.<br>
	 * The index must be smaller than the num_extra_channels in the associated<br>
	 * JxlBasicInfo. Must call @ref JxlEncoderSetExtraChannelInfo before<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * TODO(firsching): mention what data types in pixel formats are supported.<br>
	 * It is required to call this function for every extra channel, except for the<br>
	 * alpha channel if that was already set through @ref JxlEncoderAddImageFrame.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally. The num_channels value is ignored, since the<br>
	 * number of channels for an extra channel is always assumed to be one.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @param index index of the extra channel to use.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBuffer(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/encode.h:930</i>
	 */
	int JxlEncoderSetExtraChannelBuffer(PointerByReference frame_settings, JxlPixelFormat pixel_format, Pointer buffer, NativeLong size, int index);
	/**
	 * Adds a metadata box to the file format. JxlEncoderProcessOutput must be used<br>
	 * to effectively write the box to the output. @ref JxlEncoderUseBoxes must<br>
	 * be enabled before using this function.<br>
	 * Boxes allow inserting application-specific data and metadata (Exif, XML/XMP,<br>
	 * JUMBF and user defined boxes).<br>
	 * The box format follows ISO BMFF and shares features and box types with other<br>
	 * image and video formats, including the Exif, XML and JUMBF boxes. The box<br>
	 * format for JPEG XL is specified in ISO/IEC 18181-2.<br>
	 * Boxes in general don't contain other boxes inside, except a JUMBF superbox.<br>
	 * Boxes follow each other sequentially and are byte-aligned. If the container<br>
	 * format is used, the JXL stream consists of concatenated boxes.<br>
	 * It is also possible to use a direct codestream without boxes, but in that<br>
	 * case metadata cannot be added.<br>
	 * Each box generally has the following byte structure in the file:<br>
	 * - 4 bytes: box size including box header (Big endian. If set to 0, an<br>
	 *   8-byte 64-bit size follows instead).<br>
	 * - 4 bytes: type, e.g. "JXL " for the signature box, "jxlc" for a codestream<br>
	 *   box.<br>
	 * - N bytes: box contents.<br>
	 * Only the box contents are provided to the contents argument of this function,<br>
	 * the encoder encodes the size header itself. Most boxes are written<br>
	 * automatically by the encoder as needed ("JXL ", "ftyp", "jxll", "jxlc",<br>
	 * "jxlp", "jxli", "jbrd"), and this function only needs to be called to add<br>
	 * optional metadata when encoding from pixels (using JxlEncoderAddImageFrame).<br>
	 * When recompressing JPEG files (using JxlEncoderAddJPEGFrame), if the input<br>
	 * JPEG contains EXIF, XMP or JUMBF metadata, the corresponding boxes are<br>
	 * already added automatically.<br>
	 * Box types are given by 4 characters. The following boxes can be added with<br>
	 * this function:<br>
	 * - "Exif": a box with EXIF metadata, can be added by libjxl users, or is<br>
	 *   automatically added when needed for JPEG reconstruction. The contents of<br>
	 *   this box must be prepended by a 4-byte tiff header offset, which may<br>
	 *   be 4 zero bytes in case the tiff header follows immediately.<br>
	 *   The EXIF metadata must be in sync with what is encoded in the JPEG XL<br>
	 *   codestream, specifically the image orientation. While this is not<br>
	 *   recommended in practice, in case of conflicting metadata, the JPEG XL<br>
	 *   codestream takes precedence.<br>
	 * - "xml ": a box with XML data, in particular XMP metadata, can be added by<br>
	 *   libjxl users, or is automatically added when needed for JPEG reconstruction<br>
	 * - "jumb": a JUMBF superbox, which can contain boxes with different types of<br>
	 *   metadata inside. This box type can be added by the encoder transparently,<br>
	 *   and other libraries to create and handle JUMBF content exist.<br>
	 * - Application-specific boxes. Their typename should not begin with "jxl" or<br>
	 *   "JXL" or conflict with other existing typenames, and they should be<br>
	 *   registered with MP4RA (mp4ra.org).<br>
	 * These boxes can be stored uncompressed or Brotli-compressed (using a "brob"<br>
	 * box), depending on the compress_box parameter.<br>
	 * @param enc encoder object.<br>
	 * @param type the box type, e.g. "Exif" for EXIF metadata, "xml " for XMP or<br>
	 * IPTC metadata, "jumb" for JUMBF metadata.<br>
	 * @param contents the full contents of the box, for example EXIF<br>
	 * data. ISO BMFF box header must not be included, only the contents. Owned by<br>
	 * the caller and its contents are copied internally.<br>
	 * @param size size of the box contents.<br>
	 * @param compress_box Whether to compress this box as a "brob" box. Requires<br>
	 * Brotli support.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error, such as when<br>
	 * using this function without JxlEncoderUseContainer, or adding a box type<br>
	 * that would result in an invalid file format.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddBox(JxlEncoder*, const JxlBoxType, const uint8_t*, size_t, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1003</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderAddBox(com.sun.jna.ptr.PointerByReference, JxlBoxType, byte[], NativeLong, int)} and {@link #JxlEncoderAddBox(com.sun.jna.ptr.PointerByReference, JxlBoxType, com.sun.jna.Pointer, NativeLong, int)} instead
	 */
	@Deprecated 
	int JxlEncoderAddBox(Pointer enc, JxlBoxType type, Pointer contents, NativeLong size, int /* JXL_BOOL */ compress_box);
	/**
	 * Adds a metadata box to the file format. JxlEncoderProcessOutput must be used<br>
	 * to effectively write the box to the output. @ref JxlEncoderUseBoxes must<br>
	 * be enabled before using this function.<br>
	 * Boxes allow inserting application-specific data and metadata (Exif, XML/XMP,<br>
	 * JUMBF and user defined boxes).<br>
	 * The box format follows ISO BMFF and shares features and box types with other<br>
	 * image and video formats, including the Exif, XML and JUMBF boxes. The box<br>
	 * format for JPEG XL is specified in ISO/IEC 18181-2.<br>
	 * Boxes in general don't contain other boxes inside, except a JUMBF superbox.<br>
	 * Boxes follow each other sequentially and are byte-aligned. If the container<br>
	 * format is used, the JXL stream consists of concatenated boxes.<br>
	 * It is also possible to use a direct codestream without boxes, but in that<br>
	 * case metadata cannot be added.<br>
	 * Each box generally has the following byte structure in the file:<br>
	 * - 4 bytes: box size including box header (Big endian. If set to 0, an<br>
	 *   8-byte 64-bit size follows instead).<br>
	 * - 4 bytes: type, e.g. "JXL " for the signature box, "jxlc" for a codestream<br>
	 *   box.<br>
	 * - N bytes: box contents.<br>
	 * Only the box contents are provided to the contents argument of this function,<br>
	 * the encoder encodes the size header itself. Most boxes are written<br>
	 * automatically by the encoder as needed ("JXL ", "ftyp", "jxll", "jxlc",<br>
	 * "jxlp", "jxli", "jbrd"), and this function only needs to be called to add<br>
	 * optional metadata when encoding from pixels (using JxlEncoderAddImageFrame).<br>
	 * When recompressing JPEG files (using JxlEncoderAddJPEGFrame), if the input<br>
	 * JPEG contains EXIF, XMP or JUMBF metadata, the corresponding boxes are<br>
	 * already added automatically.<br>
	 * Box types are given by 4 characters. The following boxes can be added with<br>
	 * this function:<br>
	 * - "Exif": a box with EXIF metadata, can be added by libjxl users, or is<br>
	 *   automatically added when needed for JPEG reconstruction. The contents of<br>
	 *   this box must be prepended by a 4-byte tiff header offset, which may<br>
	 *   be 4 zero bytes in case the tiff header follows immediately.<br>
	 *   The EXIF metadata must be in sync with what is encoded in the JPEG XL<br>
	 *   codestream, specifically the image orientation. While this is not<br>
	 *   recommended in practice, in case of conflicting metadata, the JPEG XL<br>
	 *   codestream takes precedence.<br>
	 * - "xml ": a box with XML data, in particular XMP metadata, can be added by<br>
	 *   libjxl users, or is automatically added when needed for JPEG reconstruction<br>
	 * - "jumb": a JUMBF superbox, which can contain boxes with different types of<br>
	 *   metadata inside. This box type can be added by the encoder transparently,<br>
	 *   and other libraries to create and handle JUMBF content exist.<br>
	 * - Application-specific boxes. Their typename should not begin with "jxl" or<br>
	 *   "JXL" or conflict with other existing typenames, and they should be<br>
	 *   registered with MP4RA (mp4ra.org).<br>
	 * These boxes can be stored uncompressed or Brotli-compressed (using a "brob"<br>
	 * box), depending on the compress_box parameter.<br>
	 * @param enc encoder object.<br>
	 * @param type the box type, e.g. "Exif" for EXIF metadata, "xml " for XMP or<br>
	 * IPTC metadata, "jumb" for JUMBF metadata.<br>
	 * @param contents the full contents of the box, for example EXIF<br>
	 * data. ISO BMFF box header must not be included, only the contents. Owned by<br>
	 * the caller and its contents are copied internally.<br>
	 * @param size size of the box contents.<br>
	 * @param compress_box Whether to compress this box as a "brob" box. Requires<br>
	 * Brotli support.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error, such as when<br>
	 * using this function without JxlEncoderUseContainer, or adding a box type<br>
	 * that would result in an invalid file format.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddBox(JxlEncoder*, const JxlBoxType, const uint8_t*, size_t, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1003</i>
	 */
	int JxlEncoderAddBox(PointerByReference enc, JxlBoxType type, byte contents[], NativeLong size, int /* JXL_BOOL */ compress_box);
	/**
	 * Adds a metadata box to the file format. JxlEncoderProcessOutput must be used<br>
	 * to effectively write the box to the output. @ref JxlEncoderUseBoxes must<br>
	 * be enabled before using this function.<br>
	 * Boxes allow inserting application-specific data and metadata (Exif, XML/XMP,<br>
	 * JUMBF and user defined boxes).<br>
	 * The box format follows ISO BMFF and shares features and box types with other<br>
	 * image and video formats, including the Exif, XML and JUMBF boxes. The box<br>
	 * format for JPEG XL is specified in ISO/IEC 18181-2.<br>
	 * Boxes in general don't contain other boxes inside, except a JUMBF superbox.<br>
	 * Boxes follow each other sequentially and are byte-aligned. If the container<br>
	 * format is used, the JXL stream consists of concatenated boxes.<br>
	 * It is also possible to use a direct codestream without boxes, but in that<br>
	 * case metadata cannot be added.<br>
	 * Each box generally has the following byte structure in the file:<br>
	 * - 4 bytes: box size including box header (Big endian. If set to 0, an<br>
	 *   8-byte 64-bit size follows instead).<br>
	 * - 4 bytes: type, e.g. "JXL " for the signature box, "jxlc" for a codestream<br>
	 *   box.<br>
	 * - N bytes: box contents.<br>
	 * Only the box contents are provided to the contents argument of this function,<br>
	 * the encoder encodes the size header itself. Most boxes are written<br>
	 * automatically by the encoder as needed ("JXL ", "ftyp", "jxll", "jxlc",<br>
	 * "jxlp", "jxli", "jbrd"), and this function only needs to be called to add<br>
	 * optional metadata when encoding from pixels (using JxlEncoderAddImageFrame).<br>
	 * When recompressing JPEG files (using JxlEncoderAddJPEGFrame), if the input<br>
	 * JPEG contains EXIF, XMP or JUMBF metadata, the corresponding boxes are<br>
	 * already added automatically.<br>
	 * Box types are given by 4 characters. The following boxes can be added with<br>
	 * this function:<br>
	 * - "Exif": a box with EXIF metadata, can be added by libjxl users, or is<br>
	 *   automatically added when needed for JPEG reconstruction. The contents of<br>
	 *   this box must be prepended by a 4-byte tiff header offset, which may<br>
	 *   be 4 zero bytes in case the tiff header follows immediately.<br>
	 *   The EXIF metadata must be in sync with what is encoded in the JPEG XL<br>
	 *   codestream, specifically the image orientation. While this is not<br>
	 *   recommended in practice, in case of conflicting metadata, the JPEG XL<br>
	 *   codestream takes precedence.<br>
	 * - "xml ": a box with XML data, in particular XMP metadata, can be added by<br>
	 *   libjxl users, or is automatically added when needed for JPEG reconstruction<br>
	 * - "jumb": a JUMBF superbox, which can contain boxes with different types of<br>
	 *   metadata inside. This box type can be added by the encoder transparently,<br>
	 *   and other libraries to create and handle JUMBF content exist.<br>
	 * - Application-specific boxes. Their typename should not begin with "jxl" or<br>
	 *   "JXL" or conflict with other existing typenames, and they should be<br>
	 *   registered with MP4RA (mp4ra.org).<br>
	 * These boxes can be stored uncompressed or Brotli-compressed (using a "brob"<br>
	 * box), depending on the compress_box parameter.<br>
	 * @param enc encoder object.<br>
	 * @param type the box type, e.g. "Exif" for EXIF metadata, "xml " for XMP or<br>
	 * IPTC metadata, "jumb" for JUMBF metadata.<br>
	 * @param contents the full contents of the box, for example EXIF<br>
	 * data. ISO BMFF box header must not be included, only the contents. Owned by<br>
	 * the caller and its contents are copied internally.<br>
	 * @param size size of the box contents.<br>
	 * @param compress_box Whether to compress this box as a "brob" box. Requires<br>
	 * Brotli support.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error, such as when<br>
	 * using this function without JxlEncoderUseContainer, or adding a box type<br>
	 * that would result in an invalid file format.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddBox(JxlEncoder*, const JxlBoxType, const uint8_t*, size_t, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1003</i>
	 */
	int JxlEncoderAddBox(PointerByReference enc, JxlBoxType type, Pointer contents, NativeLong size, int /* JXL_BOOL */ compress_box);
	/**
	 * Indicates the intention to add metadata boxes. This allows @ref<br>
	 * JxlEncoderAddBox to be used. When using this function, then it is required<br>
	 * to use @ref JxlEncoderCloseBoxes at the end.<br>
	 * By default the encoder assumes no metadata boxes will be added.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseBoxes(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1020</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderUseBoxes(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlEncoderUseBoxes(Pointer enc);
	/**
	 * Indicates the intention to add metadata boxes. This allows @ref<br>
	 * JxlEncoderAddBox to be used. When using this function, then it is required<br>
	 * to use @ref JxlEncoderCloseBoxes at the end.<br>
	 * By default the encoder assumes no metadata boxes will be added.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseBoxes(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1020</i>
	 */
	int JxlEncoderUseBoxes(PointerByReference enc);
	/**
	 * Declares that no further boxes will be added with @ref JxlEncoderAddBox.<br>
	 * This function must be called after the last box is added so the encoder knows<br>
	 * the stream will be finished. It is not necessary to use this function if<br>
	 * @ref JxlEncoderUseBoxes is not used. Further frames may still be added.<br>
	 * Must be called between JxlEncoderAddBox of the last box<br>
	 * and the next call to JxlEncoderProcessOutput, or @ref JxlEncoderProcessOutput<br>
	 * won't output the last box correctly.<br>
	 * NOTE: if you don't need to close frames and boxes at separate times, you can<br>
	 * use @ref JxlEncoderCloseInput instead to close both at once.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseBoxes(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1037</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderCloseBoxes(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderCloseBoxes(Pointer enc);
	/**
	 * Declares that no further boxes will be added with @ref JxlEncoderAddBox.<br>
	 * This function must be called after the last box is added so the encoder knows<br>
	 * the stream will be finished. It is not necessary to use this function if<br>
	 * @ref JxlEncoderUseBoxes is not used. Further frames may still be added.<br>
	 * Must be called between JxlEncoderAddBox of the last box<br>
	 * and the next call to JxlEncoderProcessOutput, or @ref JxlEncoderProcessOutput<br>
	 * won't output the last box correctly.<br>
	 * NOTE: if you don't need to close frames and boxes at separate times, you can<br>
	 * use @ref JxlEncoderCloseInput instead to close both at once.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseBoxes(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1037</i>
	 */
	void JxlEncoderCloseBoxes(PointerByReference enc);
	/**
	 * Declares that no frames will be added and @ref JxlEncoderAddImageFrame and<br>
	 * @ref JxlEncoderAddJPEGFrame won't be called anymore. Further metadata boxes<br>
	 * may still be added. This function or @ref JxlEncoderCloseInput must be called<br>
	 * after adding the last frame and the next call to<br>
	 * @ref JxlEncoderProcessOutput, or the frame won't be properly marked as last.<br>
	 * NOTE: if you don't need to close frames and boxes at separate times, you can<br>
	 * use @ref JxlEncoderCloseInput instead to close both at once.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseFrames(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1051</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderCloseFrames(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderCloseFrames(Pointer enc);
	/**
	 * Declares that no frames will be added and @ref JxlEncoderAddImageFrame and<br>
	 * @ref JxlEncoderAddJPEGFrame won't be called anymore. Further metadata boxes<br>
	 * may still be added. This function or @ref JxlEncoderCloseInput must be called<br>
	 * after adding the last frame and the next call to<br>
	 * @ref JxlEncoderProcessOutput, or the frame won't be properly marked as last.<br>
	 * NOTE: if you don't need to close frames and boxes at separate times, you can<br>
	 * use @ref JxlEncoderCloseInput instead to close both at once.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseFrames(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1051</i>
	 */
	void JxlEncoderCloseFrames(PointerByReference enc);
	/**
	 * Closes any input to the encoder, equivalent to calling JxlEncoderCloseFrames<br>
	 * as well as calling JxlEncoderCloseBoxes if needed. No further input of any<br>
	 * kind may be given to the encoder, but further @ref JxlEncoderProcessOutput<br>
	 * calls should be done to create the final output.<br>
	 * The requirements of both @ref JxlEncoderCloseFrames and @ref<br>
	 * JxlEncoderCloseBoxes apply to this function. Either this function or the<br>
	 * other two must be called after the final frame and/or box, and the next<br>
	 * @ref JxlEncoderProcessOutput call, or the codestream won't be encoded<br>
	 * correctly.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseInput(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1067</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderCloseInput(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderCloseInput(Pointer enc);
	/**
	 * Closes any input to the encoder, equivalent to calling JxlEncoderCloseFrames<br>
	 * as well as calling JxlEncoderCloseBoxes if needed. No further input of any<br>
	 * kind may be given to the encoder, but further @ref JxlEncoderProcessOutput<br>
	 * calls should be done to create the final output.<br>
	 * The requirements of both @ref JxlEncoderCloseFrames and @ref<br>
	 * JxlEncoderCloseBoxes apply to this function. Either this function or the<br>
	 * other two must be called after the final frame and/or box, and the next<br>
	 * @ref JxlEncoderProcessOutput call, or the codestream won't be encoded<br>
	 * correctly.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseInput(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1067</i>
	 */
	void JxlEncoderCloseInput(PointerByReference enc);
	/**
	 * Sets the original color encoding of the image encoded by this encoder. This<br>
	 * is an alternative to JxlEncoderSetICCProfile and only one of these two must<br>
	 * be used. This one sets the color encoding as a @ref JxlColorEncoding, while<br>
	 * the other sets it as ICC binary data.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param color color encoding. Object owned by the caller and its contents are<br>
	 * copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetColorEncoding(JxlEncoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/encode.h:1082</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetColorEncoding(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlColorEncoding[])} and {@link #JxlEncoderSetColorEncoding(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlColorEncoding)} instead
	 */
	@Deprecated 
	int JxlEncoderSetColorEncoding(Pointer enc, JxlColorEncoding color);
	/**
	 * Sets the original color encoding of the image encoded by this encoder. This<br>
	 * is an alternative to JxlEncoderSetICCProfile and only one of these two must<br>
	 * be used. This one sets the color encoding as a @ref JxlColorEncoding, while<br>
	 * the other sets it as ICC binary data.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param color color encoding. Object owned by the caller and its contents are<br>
	 * copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetColorEncoding(JxlEncoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/encode.h:1082</i>
	 */
	int JxlEncoderSetColorEncoding(PointerByReference enc, JxlColorEncoding color[]);
	/**
	 * Sets the original color encoding of the image encoded by this encoder. This<br>
	 * is an alternative to JxlEncoderSetICCProfile and only one of these two must<br>
	 * be used. This one sets the color encoding as a @ref JxlColorEncoding, while<br>
	 * the other sets it as ICC binary data.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param color color encoding. Object owned by the caller and its contents are<br>
	 * copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetColorEncoding(JxlEncoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/encode.h:1082</i>
	 */
	int JxlEncoderSetColorEncoding(PointerByReference enc, JxlColorEncoding color);
	/**
	 * Sets the original color encoding of the image encoded by this encoder as an<br>
	 * ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and<br>
	 * only one of these two must be used. This one sets the color encoding as ICC<br>
	 * binary data, while the other defines it as a @ref JxlColorEncoding.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param icc_profile bytes of the original ICC profile<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetICCProfile(JxlEncoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1098</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetICCProfile(com.sun.jna.ptr.PointerByReference, byte[], NativeLong)} and {@link #JxlEncoderSetICCProfile(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlEncoderSetICCProfile(Pointer enc, Pointer icc_profile, NativeLong size);
	/**
	 * Sets the original color encoding of the image encoded by this encoder as an<br>
	 * ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and<br>
	 * only one of these two must be used. This one sets the color encoding as ICC<br>
	 * binary data, while the other defines it as a @ref JxlColorEncoding.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param icc_profile bytes of the original ICC profile<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetICCProfile(JxlEncoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1098</i>
	 */
	int JxlEncoderSetICCProfile(PointerByReference enc, byte icc_profile[], NativeLong size);
	/**
	 * Sets the original color encoding of the image encoded by this encoder as an<br>
	 * ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and<br>
	 * only one of these two must be used. This one sets the color encoding as ICC<br>
	 * binary data, while the other defines it as a @ref JxlColorEncoding.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param icc_profile bytes of the original ICC profile<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetICCProfile(JxlEncoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1098</i>
	 */
	int JxlEncoderSetICCProfile(PointerByReference enc, Pointer icc_profile, NativeLong size);
	/**
	 * Initializes a JxlBasicInfo struct to default values.<br>
	 * For forwards-compatibility, this function has to be called before values<br>
	 * are assigned to the struct fields.<br>
	 * The default values correspond to an 8-bit RGB image, no alpha or any<br>
	 * other extra channels.<br>
	 * @param info global image metadata. Object owned by the caller.<br>
	 * Original signature : <code>void JxlEncoderInitBasicInfo(JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:1111</i>
	 */
	void JxlEncoderInitBasicInfo(JxlBasicInfo info);
	/**
	 * Initializes a JxlFrameHeader struct to default values.<br>
	 * For forwards-compatibility, this function has to be called before values<br>
	 * are assigned to the struct fields.<br>
	 * The default values correspond to a frame with no animation duration and the<br>
	 * 'replace' blend mode. After using this function, For animation duration must<br>
	 * be set, for composite still blend settings must be set.<br>
	 * @param frame_header frame metadata. Object owned by the caller.<br>
	 * Original signature : <code>void JxlEncoderInitFrameHeader(JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/encode.h:1123</i>
	 */
	void JxlEncoderInitFrameHeader(JxlFrameHeader frame_header);
	/**
	 * Initializes a JxlBlendInfo struct to default values.<br>
	 * For forwards-compatibility, this function has to be called before values<br>
	 * are assigned to the struct fields.<br>
	 * @param blend_info blending info. Object owned by the caller.<br>
	 * Original signature : <code>void JxlEncoderInitBlendInfo(JxlBlendInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:1132</i>
	 */
	void JxlEncoderInitBlendInfo(JxlBlendInfo blend_info);
	/**
	 * Sets the global metadata of the image encoded by this encoder.<br>
	 * If the JxlBasicInfo contains information of extra channels beyond an alpha<br>
	 * channel, then @ref JxlEncoderSetExtraChannelInfo must be called between<br>
	 * JxlEncoderSetBasicInfo and @ref JxlEncoderAddImageFrame. In order to indicate<br>
	 * extra channels, the value of `info.num_extra_channels` should be set to the<br>
	 * number of extra channels, also counting the alpha channel if present.<br>
	 * @param enc encoder object.<br>
	 * @param info global image metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful,<br>
	 * JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetBasicInfo(JxlEncoder*, const JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:1149</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetBasicInfo(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlBasicInfo[])} and {@link #JxlEncoderSetBasicInfo(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlBasicInfo)} instead
	 */
	@Deprecated 
	int JxlEncoderSetBasicInfo(Pointer enc, JxlBasicInfo info);
	/**
	 * Sets the global metadata of the image encoded by this encoder.<br>
	 * If the JxlBasicInfo contains information of extra channels beyond an alpha<br>
	 * channel, then @ref JxlEncoderSetExtraChannelInfo must be called between<br>
	 * JxlEncoderSetBasicInfo and @ref JxlEncoderAddImageFrame. In order to indicate<br>
	 * extra channels, the value of `info.num_extra_channels` should be set to the<br>
	 * number of extra channels, also counting the alpha channel if present.<br>
	 * @param enc encoder object.<br>
	 * @param info global image metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful,<br>
	 * JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetBasicInfo(JxlEncoder*, const JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:1149</i>
	 */
	int JxlEncoderSetBasicInfo(PointerByReference enc, JxlBasicInfo info[]);
	/**
	 * Sets the global metadata of the image encoded by this encoder.<br>
	 * If the JxlBasicInfo contains information of extra channels beyond an alpha<br>
	 * channel, then @ref JxlEncoderSetExtraChannelInfo must be called between<br>
	 * JxlEncoderSetBasicInfo and @ref JxlEncoderAddImageFrame. In order to indicate<br>
	 * extra channels, the value of `info.num_extra_channels` should be set to the<br>
	 * number of extra channels, also counting the alpha channel if present.<br>
	 * @param enc encoder object.<br>
	 * @param info global image metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful,<br>
	 * JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetBasicInfo(JxlEncoder*, const JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:1149</i>
	 */
	int JxlEncoderSetBasicInfo(PointerByReference enc, JxlBasicInfo info);
	/**
	 * Sets the upsampling method the decoder will use in case there are frames<br>
	 * with JXL_ENC_FRAME_SETTING_RESAMPLING set. This is useful in combination<br>
	 * with the JXL_ENC_FRAME_SETTING_ALREADY_DOWNSAMPLED option, to control the<br>
	 * type of upsampling that will be used.<br>
	 * @param enc encoder object.<br>
	 * @param factor upsampling factor to configure (1, 2, 4 or 8; for 1 this<br>
	 * function has no effect at all)<br>
	 * @param mode upsampling mode to use for this upsampling:<br>
	 * -1: default (good for photographic images, no signaling overhead)<br>
	 * 0: nearest neighbor (good for pixel art)<br>
	 * 1: 'pixel dots' (same as NN for 2x, diamond-shaped 'pixel dots' for 4x/8x)<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful,<br>
	 * JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetUpsamplingMode(JxlEncoder*, const int64_t, const int64_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1168</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetUpsamplingMode(com.sun.jna.ptr.PointerByReference, long, long)} instead
	 */
	@Deprecated 
	int JxlEncoderSetUpsamplingMode(Pointer enc, long factor, long mode);
	/**
	 * Sets the upsampling method the decoder will use in case there are frames<br>
	 * with JXL_ENC_FRAME_SETTING_RESAMPLING set. This is useful in combination<br>
	 * with the JXL_ENC_FRAME_SETTING_ALREADY_DOWNSAMPLED option, to control the<br>
	 * type of upsampling that will be used.<br>
	 * @param enc encoder object.<br>
	 * @param factor upsampling factor to configure (1, 2, 4 or 8; for 1 this<br>
	 * function has no effect at all)<br>
	 * @param mode upsampling mode to use for this upsampling:<br>
	 * -1: default (good for photographic images, no signaling overhead)<br>
	 * 0: nearest neighbor (good for pixel art)<br>
	 * 1: 'pixel dots' (same as NN for 2x, diamond-shaped 'pixel dots' for 4x/8x)<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful,<br>
	 * JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetUpsamplingMode(JxlEncoder*, const int64_t, const int64_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1168</i>
	 */
	int JxlEncoderSetUpsamplingMode(PointerByReference enc, long factor, long mode);
	/**
	 * Initializes a JxlExtraChannelInfo struct to default values.<br>
	 * For forwards-compatibility, this function has to be called before values<br>
	 * are assigned to the struct fields.<br>
	 * The default values correspond to an 8-bit channel of the provided type.<br>
	 * @param type type of the extra channel.<br>
	 * @param info global extra channel metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * Original signature : <code>void JxlEncoderInitExtraChannelInfo(JxlExtraChannelType, JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:1182</i>
	 */
	void JxlEncoderInitExtraChannelInfo(JxlExtraChannelType type, JxlExtraChannelInfo info);
	/**
	 * Sets information for the extra channel at the given index. The index<br>
	 * must be smaller than num_extra_channels in the associated JxlBasicInfo.<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param info global extra channel metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelInfo(JxlEncoder*, size_t, const JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:1195</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetExtraChannelInfo(com.sun.jna.ptr.PointerByReference, NativeLong, vavi.awt.image.jna.jpegxl.JxlExtraChannelInfo[])} and {@link #JxlEncoderSetExtraChannelInfo(com.sun.jna.ptr.PointerByReference, NativeLong, vavi.awt.image.jna.jpegxl.JxlExtraChannelInfo)} instead
	 */
	@Deprecated 
	int JxlEncoderSetExtraChannelInfo(Pointer enc, NativeLong index, JxlExtraChannelInfo info);
	/**
	 * Sets information for the extra channel at the given index. The index<br>
	 * must be smaller than num_extra_channels in the associated JxlBasicInfo.<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param info global extra channel metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelInfo(JxlEncoder*, size_t, const JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:1195</i>
	 */
	int JxlEncoderSetExtraChannelInfo(PointerByReference enc, NativeLong index, JxlExtraChannelInfo info[]);
	/**
	 * Sets information for the extra channel at the given index. The index<br>
	 * must be smaller than num_extra_channels in the associated JxlBasicInfo.<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param info global extra channel metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelInfo(JxlEncoder*, size_t, const JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:1195</i>
	 */
	int JxlEncoderSetExtraChannelInfo(PointerByReference enc, NativeLong index, JxlExtraChannelInfo info);
	/**
	 * Sets the name for the extra channel at the given index in UTF-8. The index<br>
	 * must be smaller than the num_extra_channels in the associated JxlBasicInfo.<br>
	 * TODO(lode): remove size parameter for consistency with<br>
	 * JxlEncoderSetFrameName<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param name buffer with the name of the extra channel.<br>
	 * @param size size of the name buffer in bytes, not counting the terminating<br>
	 * character.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelName(JxlEncoder*, size_t, const char*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1212</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetExtraChannelName(com.sun.jna.ptr.PointerByReference, NativeLong, java.lang.String, NativeLong)} and {@link #JxlEncoderSetExtraChannelName(com.sun.jna.ptr.PointerByReference, NativeLong, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlEncoderSetExtraChannelName(Pointer enc, NativeLong index, Pointer name, NativeLong size);
	/**
	 * Sets the name for the extra channel at the given index in UTF-8. The index<br>
	 * must be smaller than the num_extra_channels in the associated JxlBasicInfo.<br>
	 * TODO(lode): remove size parameter for consistency with<br>
	 * JxlEncoderSetFrameName<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param name buffer with the name of the extra channel.<br>
	 * @param size size of the name buffer in bytes, not counting the terminating<br>
	 * character.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelName(JxlEncoder*, size_t, const char*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1212</i>
	 */
	int JxlEncoderSetExtraChannelName(PointerByReference enc, NativeLong index, String name, NativeLong size);
	/**
	 * Sets the name for the extra channel at the given index in UTF-8. The index<br>
	 * must be smaller than the num_extra_channels in the associated JxlBasicInfo.<br>
	 * TODO(lode): remove size parameter for consistency with<br>
	 * JxlEncoderSetFrameName<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param name buffer with the name of the extra channel.<br>
	 * @param size size of the name buffer in bytes, not counting the terminating<br>
	 * character.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelName(JxlEncoder*, size_t, const char*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1212</i>
	 */
	int JxlEncoderSetExtraChannelName(PointerByReference enc, NativeLong index, Pointer name, NativeLong size);
	/**
	 * Sets a frame-specific option of integer type to the encoder options.<br>
	 * The JxlEncoderFrameSettingId argument determines which option is set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param option ID of the option to set.<br>
	 * @param value Integer value to set for this option.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in<br>
	 * case of an error, such as invalid or unknown option id, or invalid integer<br>
	 * value for the given option. If an error is returned, the state of the<br>
	 * JxlEncoderFrameSettings object is still valid and is the same as before this<br>
	 * function was called.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFrameSettingsSetOption(JxlEncoderFrameSettings*, JxlEncoderFrameSettingId, int64_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1231</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderFrameSettingsSetOption(com.sun.jna.ptr.PointerByReference, int, long)} instead
	 */
	@Deprecated 
	int JxlEncoderFrameSettingsSetOption(Pointer frame_settings, int option, long value);
	/**
	 * Sets a frame-specific option of integer type to the encoder options.<br>
	 * The JxlEncoderFrameSettingId argument determines which option is set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param option ID of the option to set.<br>
	 * @param value Integer value to set for this option.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in<br>
	 * case of an error, such as invalid or unknown option id, or invalid integer<br>
	 * value for the given option. If an error is returned, the state of the<br>
	 * JxlEncoderFrameSettings object is still valid and is the same as before this<br>
	 * function was called.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFrameSettingsSetOption(JxlEncoderFrameSettings*, JxlEncoderFrameSettingId, int64_t)</code><br>
	 * <i>native declaration : jxl/encode.h:1231</i>
	 */
	int JxlEncoderFrameSettingsSetOption(PointerByReference frame_settings, int option, long value);
	/**
	 * Sets a frame-specific option of float type to the encoder options.<br>
	 * The JxlEncoderFrameSettingId argument determines which option is set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param option ID of the option to set.<br>
	 * @param value Float value to set for this option.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in<br>
	 * case of an error, such as invalid or unknown option id, or invalid integer<br>
	 * value for the given option. If an error is returned, the state of the<br>
	 * JxlEncoderFrameSettings object is still valid and is the same as before this<br>
	 * function was called.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFrameSettingsSetFloatOption(JxlEncoderFrameSettings*, JxlEncoderFrameSettingId, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1249</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderFrameSettingsSetFloatOption(com.sun.jna.ptr.PointerByReference, int, float)} instead
	 */
	@Deprecated 
	int JxlEncoderFrameSettingsSetFloatOption(Pointer frame_settings, int option, float value);
	/**
	 * Sets a frame-specific option of float type to the encoder options.<br>
	 * The JxlEncoderFrameSettingId argument determines which option is set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param option ID of the option to set.<br>
	 * @param value Float value to set for this option.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in<br>
	 * case of an error, such as invalid or unknown option id, or invalid integer<br>
	 * value for the given option. If an error is returned, the state of the<br>
	 * JxlEncoderFrameSettings object is still valid and is the same as before this<br>
	 * function was called.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFrameSettingsSetFloatOption(JxlEncoderFrameSettings*, JxlEncoderFrameSettingId, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1249</i>
	 */
	int JxlEncoderFrameSettingsSetFloatOption(PointerByReference frame_settings, int option, float value);
	/**
	 * Forces the encoder to use the box-based container format (BMFF) even<br>
	 * when not necessary.<br>
	 * When using @ref JxlEncoderUseBoxes, @ref JxlEncoderStoreJPEGMetadata or @ref<br>
	 * JxlEncoderSetCodestreamLevel with level 10, the encoder will automatically<br>
	 * also use the container format, it is not necessary to use<br>
	 * JxlEncoderUseContainer for those use cases.<br>
	 * By default this setting is disabled.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param use_container true if the encoder should always output the JPEG XL<br>
	 * container format, false to only output it when necessary.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseContainer(JxlEncoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1271</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderUseContainer(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderUseContainer(Pointer enc, int /* JXL_BOOL */ use_container);
	/**
	 * Forces the encoder to use the box-based container format (BMFF) even<br>
	 * when not necessary.<br>
	 * When using @ref JxlEncoderUseBoxes, @ref JxlEncoderStoreJPEGMetadata or @ref<br>
	 * JxlEncoderSetCodestreamLevel with level 10, the encoder will automatically<br>
	 * also use the container format, it is not necessary to use<br>
	 * JxlEncoderUseContainer for those use cases.<br>
	 * By default this setting is disabled.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param use_container true if the encoder should always output the JPEG XL<br>
	 * container format, false to only output it when necessary.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseContainer(JxlEncoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1271</i>
	 */
	int JxlEncoderUseContainer(PointerByReference enc, int /* JXL_BOOL */ use_container);
	/**
	 * Configure the encoder to store JPEG reconstruction metadata in the JPEG XL<br>
	 * container.<br>
	 * If this is set to true and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param store_jpeg_metadata true if the encoder should store JPEG metadata.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderStoreJPEGMetadata(JxlEncoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1288</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderStoreJPEGMetadata(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderStoreJPEGMetadata(Pointer enc, int /* JXL_BOOL */ store_jpeg_metadata);
	/**
	 * Configure the encoder to store JPEG reconstruction metadata in the JPEG XL<br>
	 * container.<br>
	 * If this is set to true and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param store_jpeg_metadata true if the encoder should store JPEG metadata.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderStoreJPEGMetadata(JxlEncoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1288</i>
	 */
	int JxlEncoderStoreJPEGMetadata(PointerByReference enc, int /* JXL_BOOL */ store_jpeg_metadata);
	/**
	 * Sets the feature level of the JPEG XL codestream. Valid values are 5 and<br>
	 * 10, or -1 (to choose automatically). Using the minimum required level, or<br>
	 * level 5 in most cases, is recommended for compatibility with all decoders.<br>
	 * Level 5: for end-user image delivery, this level is the most widely<br>
	 * supported level by image decoders and the recommended level to use unless a<br>
	 * level 10 feature is absolutely necessary. Supports a maximum resolution<br>
	 * 268435456 pixels total with a maximum width or height of 262144 pixels,<br>
	 * maximum 16-bit color channel depth, maximum 120 frames per second for<br>
	 * animation, maximum ICC color profile size of 4 MiB, it allows all color<br>
	 * models and extra channel types except CMYK and the JXL_CHANNEL_BLACK extra<br>
	 * channel, and a maximum of 4 extra channels in addition to the 3 color<br>
	 * channels. It also sets boundaries to certain internally used coding tools.<br>
	 * Level 10: this level removes or increases the bounds of most of the level<br>
	 * 5 limitations, allows CMYK color and up to 32 bits per color channel, but<br>
	 * may be less widely supported.<br>
	 * The default value is -1. This means the encoder will automatically choose<br>
	 * between level 5 and level 10 based on what information is inside the @ref<br>
	 * JxlBasicInfo structure. Do note that some level 10 features, particularly<br>
	 * those used by animated JPEG XL codestreams, might require level 10, even<br>
	 * though the @ref JxlBasicInfo only suggests level 5. In this case, the level<br>
	 * must be explicitly set to 10, otherwise the encoder will return an error.<br>
	 * The encoder will restrict internal encoding choices to those compatible with<br>
	 * the level setting.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param level the level value to set, must be -1, 5, or 10.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetCodestreamLevel(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1325</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetCodestreamLevel(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderSetCodestreamLevel(Pointer enc, int level);
	/**
	 * Sets the feature level of the JPEG XL codestream. Valid values are 5 and<br>
	 * 10, or -1 (to choose automatically). Using the minimum required level, or<br>
	 * level 5 in most cases, is recommended for compatibility with all decoders.<br>
	 * Level 5: for end-user image delivery, this level is the most widely<br>
	 * supported level by image decoders and the recommended level to use unless a<br>
	 * level 10 feature is absolutely necessary. Supports a maximum resolution<br>
	 * 268435456 pixels total with a maximum width or height of 262144 pixels,<br>
	 * maximum 16-bit color channel depth, maximum 120 frames per second for<br>
	 * animation, maximum ICC color profile size of 4 MiB, it allows all color<br>
	 * models and extra channel types except CMYK and the JXL_CHANNEL_BLACK extra<br>
	 * channel, and a maximum of 4 extra channels in addition to the 3 color<br>
	 * channels. It also sets boundaries to certain internally used coding tools.<br>
	 * Level 10: this level removes or increases the bounds of most of the level<br>
	 * 5 limitations, allows CMYK color and up to 32 bits per color channel, but<br>
	 * may be less widely supported.<br>
	 * The default value is -1. This means the encoder will automatically choose<br>
	 * between level 5 and level 10 based on what information is inside the @ref<br>
	 * JxlBasicInfo structure. Do note that some level 10 features, particularly<br>
	 * those used by animated JPEG XL codestreams, might require level 10, even<br>
	 * though the @ref JxlBasicInfo only suggests level 5. In this case, the level<br>
	 * must be explicitly set to 10, otherwise the encoder will return an error.<br>
	 * The encoder will restrict internal encoding choices to those compatible with<br>
	 * the level setting.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param level the level value to set, must be -1, 5, or 10.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetCodestreamLevel(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1325</i>
	 */
	int JxlEncoderSetCodestreamLevel(PointerByReference enc, int level);
	/**
	 * Returns the codestream level required to support the currently configured<br>
	 * settings and basic info. This function can only be used at the beginning,<br>
	 * before encoding starts, but after setting basic info.<br>
	 * This does not support per-frame settings, only global configuration, such as<br>
	 * the image dimensions, that are known at the time of writing the header of<br>
	 * the JPEG XL file.<br>
	 * If this returns 5, nothing needs to be done and the codestream can be<br>
	 * compatible with any decoder. If this returns 10, JxlEncoderSetCodestreamLevel<br>
	 * has to be used to set the codestream level to 10, or the encoder can be<br>
	 * configured differently to allow using the more compatible level 5.<br>
	 * @param enc encoder object.<br>
	 * @return -1 if no level can support the configuration (e.g. image dimensions<br>
	 * larger than even level 10 supports), 5 if level 5 is supported, 10 if setting<br>
	 * the codestream level to 10 is required.<br>
	 * Original signature : <code>int JxlEncoderGetRequiredCodestreamLevel(const JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1347</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderGetRequiredCodestreamLevel(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlEncoderGetRequiredCodestreamLevel(Pointer enc);
	/**
	 * Returns the codestream level required to support the currently configured<br>
	 * settings and basic info. This function can only be used at the beginning,<br>
	 * before encoding starts, but after setting basic info.<br>
	 * This does not support per-frame settings, only global configuration, such as<br>
	 * the image dimensions, that are known at the time of writing the header of<br>
	 * the JPEG XL file.<br>
	 * If this returns 5, nothing needs to be done and the codestream can be<br>
	 * compatible with any decoder. If this returns 10, JxlEncoderSetCodestreamLevel<br>
	 * has to be used to set the codestream level to 10, or the encoder can be<br>
	 * configured differently to allow using the more compatible level 5.<br>
	 * @param enc encoder object.<br>
	 * @return -1 if no level can support the configuration (e.g. image dimensions<br>
	 * larger than even level 10 supports), 5 if level 5 is supported, 10 if setting<br>
	 * the codestream level to 10 is required.<br>
	 * Original signature : <code>int JxlEncoderGetRequiredCodestreamLevel(const JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1347</i>
	 */
	int JxlEncoderGetRequiredCodestreamLevel(PointerByReference enc);
	/**
	 * Enables lossless encoding.<br>
	 * This is not an option like the others on itself, but rather while enabled it<br>
	 * overrides a set of existing options (such as distance, modular mode and<br>
	 * color transform) that enables bit-for-bit lossless encoding.<br>
	 * When disabled, those options are not overridden, but since those options<br>
	 * could still have been manually set to a combination that operates losslessly,<br>
	 * using this function with lossless set to JXL_DEC_FALSE does not guarantee<br>
	 * lossy encoding, though the default set of options is lossy.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param lossless whether to override options for lossless mode<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameLossless(JxlEncoderFrameSettings*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1367</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetFrameLossless(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderSetFrameLossless(Pointer frame_settings, int /* JXL_BOOL */ lossless);
	/**
	 * Enables lossless encoding.<br>
	 * This is not an option like the others on itself, but rather while enabled it<br>
	 * overrides a set of existing options (such as distance, modular mode and<br>
	 * color transform) that enables bit-for-bit lossless encoding.<br>
	 * When disabled, those options are not overridden, but since those options<br>
	 * could still have been manually set to a combination that operates losslessly,<br>
	 * using this function with lossless set to JXL_DEC_FALSE does not guarantee<br>
	 * lossy encoding, though the default set of options is lossy.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param lossless whether to override options for lossless mode<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameLossless(JxlEncoderFrameSettings*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1367</i>
	 */
	int JxlEncoderSetFrameLossless(PointerByReference frame_settings, int /* JXL_BOOL */ lossless);
	/**
	 * Sets the distance level for lossy compression: target max butteraugli<br>
	 * distance, lower = higher quality. Range: 0 .. 25.<br>
	 * 0.0 = mathematically lossless (however, use JxlEncoderSetFrameLossless<br>
	 * instead to use true lossless, as setting distance to 0 alone is not the only<br>
	 * requirement). 1.0 = visually lossless. Recommended range: 0.5 .. 3.0. Default<br>
	 * value: 1.0.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param distance the distance value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameDistance(JxlEncoderFrameSettings*, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1384</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetFrameDistance(com.sun.jna.ptr.PointerByReference, float)} instead
	 */
	@Deprecated 
	int JxlEncoderSetFrameDistance(Pointer frame_settings, float distance);
	/**
	 * Sets the distance level for lossy compression: target max butteraugli<br>
	 * distance, lower = higher quality. Range: 0 .. 25.<br>
	 * 0.0 = mathematically lossless (however, use JxlEncoderSetFrameLossless<br>
	 * instead to use true lossless, as setting distance to 0 alone is not the only<br>
	 * requirement). 1.0 = visually lossless. Recommended range: 0.5 .. 3.0. Default<br>
	 * value: 1.0.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param distance the distance value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameDistance(JxlEncoderFrameSettings*, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1384</i>
	 */
	int JxlEncoderSetFrameDistance(PointerByReference frame_settings, float distance);
	/**
	 * Sets the distance level for lossy compression of extra channels.<br>
	 * The distance is as in JxlEncoderSetFrameDistance (lower = higher quality).<br>
	 * If not set, or if set to the special value -1, the distance that was set with<br>
	 * JxlEncoderSetFrameDistance will be used.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param index index of the extra channel to set a distance value for.<br>
	 * @param distance the distance value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelDistance(JxlEncoderFrameSettings*, size_t, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1400</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetExtraChannelDistance(com.sun.jna.ptr.PointerByReference, NativeLong, float)} instead
	 */
	@Deprecated 
	int JxlEncoderSetExtraChannelDistance(Pointer frame_settings, NativeLong index, float distance);
	/**
	 * Sets the distance level for lossy compression of extra channels.<br>
	 * The distance is as in JxlEncoderSetFrameDistance (lower = higher quality).<br>
	 * If not set, or if set to the special value -1, the distance that was set with<br>
	 * JxlEncoderSetFrameDistance will be used.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param index index of the extra channel to set a distance value for.<br>
	 * @param distance the distance value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelDistance(JxlEncoderFrameSettings*, size_t, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1400</i>
	 */
	int JxlEncoderSetExtraChannelDistance(PointerByReference frame_settings, NativeLong index, float distance);
	/**
	 * Maps JPEG-style quality factor to distance.<br>
	 * This function takes in input a JPEG-style quality factor `quality` and<br>
	 * produces as output a `distance` value suitable to be used with @ref<br>
	 * JxlEncoderSetFrameDistance and<br>
	 * @ref JxlEncoderSetExtraChannelDistance.<br>
	 * The `distance` value influences the level of compression, with lower values<br>
	 * indicating higher quality:<br>
	 * - 0.0 implies lossless compression (however, note that calling @ref<br>
	 * JxlEncoderSetFrameLossless is required).<br>
	 * - 1.0 represents a visually lossy compression, which is also the default<br>
	 * setting.<br>
	 * The `quality` parameter, ranging up to 100, is inversely related to<br>
	 * 'distance':<br>
	 * - A `quality` of 100.0 maps to a `distance` of 0.0 (lossless).<br>
	 * - A `quality` of 90.0 corresponds to a `distance` of 1.0.<br>
	 * Recommended Range:<br>
	 * - `distance`: 0.5 to 3.0.<br>
	 * - corresponding `quality`: approximately 96 to 68.<br>
	 * Allowed Range:<br>
	 * - `distance`: 0.0 to 25.0.<br>
	 * - corresponding `quality`: 100.0 to 0.0.<br>
	 * Note: the `quality` parameter has no consistent psychovisual meaning<br>
	 * across different codecs and libraries. Using the mapping defined by @ref<br>
	 * JxlEncoderDistanceFromQuality will result in a visual quality roughly<br>
	 * equivalent to what would be obtained with `libjpeg-turbo` with the same<br>
	 * `quality` parameter, but that is by no means guaranteed; do not assume that<br>
	 * the same quality value will result in similar file sizes and image quality<br>
	 * across different codecs.<br>
	 * Original signature : <code>float JxlEncoderDistanceFromQuality(float)</code><br>
	 * <i>native declaration : jxl/encode.h:1439</i>
	 */
	float JxlEncoderDistanceFromQuality(float quality);
	/**
	 * Create a new set of encoder options, with all values initially copied from<br>
	 * the @p source options, or set to default if @p source is NULL.<br>
	 * The returned pointer is an opaque struct tied to the encoder and it will be<br>
	 * deallocated by the encoder when JxlEncoderDestroy() is called. For functions<br>
	 * taking both a @ref JxlEncoder and a @ref JxlEncoderFrameSettings, only<br>
	 * JxlEncoderFrameSettings created with this function for the same encoder<br>
	 * instance can be used.<br>
	 * @param enc encoder object.<br>
	 * @param source source options to copy initial values from, or NULL to get<br>
	 * defaults initialized to defaults.<br>
	 * @return the opaque struct pointer identifying a new set of encoder options.<br>
	 * Original signature : <code>JxlEncoderFrameSettings* JxlEncoderFrameSettingsCreate(JxlEncoder*, const JxlEncoderFrameSettings*)</code><br>
	 * <i>native declaration : jxl/encode.h:1456</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderFrameSettingsCreate(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	PointerByReference JxlEncoderFrameSettingsCreate(Pointer enc, Pointer source);
	/**
	 * Create a new set of encoder options, with all values initially copied from<br>
	 * the @p source options, or set to default if @p source is NULL.<br>
	 * The returned pointer is an opaque struct tied to the encoder and it will be<br>
	 * deallocated by the encoder when JxlEncoderDestroy() is called. For functions<br>
	 * taking both a @ref JxlEncoder and a @ref JxlEncoderFrameSettings, only<br>
	 * JxlEncoderFrameSettings created with this function for the same encoder<br>
	 * instance can be used.<br>
	 * @param enc encoder object.<br>
	 * @param source source options to copy initial values from, or NULL to get<br>
	 * defaults initialized to defaults.<br>
	 * @return the opaque struct pointer identifying a new set of encoder options.<br>
	 * Original signature : <code>JxlEncoderFrameSettings* JxlEncoderFrameSettingsCreate(JxlEncoder*, const JxlEncoderFrameSettings*)</code><br>
	 * <i>native declaration : jxl/encode.h:1456</i>
	 */
	PointerByReference JxlEncoderFrameSettingsCreate(PointerByReference enc, PointerByReference source);
	/**
	 * Sets a color encoding to be sRGB.<br>
	 * @param color_encoding color encoding instance.<br>
	 * @param is_gray whether the color encoding should be gray scale or color.<br>
	 * Original signature : <code>void JxlColorEncodingSetToSRGB(JxlColorEncoding*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1465</i>
	 */
	void JxlColorEncodingSetToSRGB(JxlColorEncoding color_encoding, int /* JXL_BOOL */ is_gray);
	/**
	 * Sets a color encoding to be linear sRGB.<br>
	 * @param color_encoding color encoding instance.<br>
	 * @param is_gray whether the color encoding should be gray scale or color.<br>
	 * Original signature : <code>void JxlColorEncodingSetToLinearSRGB(JxlColorEncoding*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/encode.h:1474</i>
	 */
	void JxlColorEncodingSetToLinearSRGB(JxlColorEncoding color_encoding, int /* JXL_BOOL */ is_gray);
	/**
	 * Enables usage of expert options.<br>
	 * At the moment, the only expert option is setting an effort value of 10,<br>
	 * which gives the best compression for pixel-lossless modes but is very slow.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderAllowExpertOptions(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1485</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderAllowExpertOptions(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderAllowExpertOptions(Pointer enc);
	/**
	 * Enables usage of expert options.<br>
	 * At the moment, the only expert option is setting an effort value of 10,<br>
	 * which gives the best compression for pixel-lossless modes but is very slow.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderAllowExpertOptions(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1485</i>
	 */
	void JxlEncoderAllowExpertOptions(PointerByReference enc);
	/**
	 * Sets the given debug image callback that will be used by the encoder to<br>
	 * output various debug images during encoding.<br>
	 * This only has any effect if the encoder was compiled with the appropriate<br>
	 * debug build flags.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param callback used to return the debug image<br>
	 * @param opaque user supplied parameter to the image callback<br>
	 * Original signature : <code>void JxlEncoderSetDebugImageCallback(JxlEncoderFrameSettings*, JxlDebugImageCallback, void*)</code><br>
	 * <i>native declaration : jxl/encode.h:1520</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetDebugImageCallback(com.sun.jna.ptr.PointerByReference, JxlDebugImageCallback, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void JxlEncoderSetDebugImageCallback(Pointer frame_settings, JxlDebugImageCallback callback, Pointer opaque);
	/**
	 * Sets the given debug image callback that will be used by the encoder to<br>
	 * output various debug images during encoding.<br>
	 * This only has any effect if the encoder was compiled with the appropriate<br>
	 * debug build flags.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param callback used to return the debug image<br>
	 * @param opaque user supplied parameter to the image callback<br>
	 * Original signature : <code>void JxlEncoderSetDebugImageCallback(JxlEncoderFrameSettings*, JxlDebugImageCallback, void*)</code><br>
	 * <i>native declaration : jxl/encode.h:1520</i>
	 */
	void JxlEncoderSetDebugImageCallback(PointerByReference frame_settings, JxlDebugImageCallback callback, Pointer opaque);
	/**
	 * Sets the given stats object for gathering various statistics during encoding.<br>
	 * This only has any effect if the encoder was compiled with the appropriate<br>
	 * debug build flags.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param stats object that can be used to query the gathered stats (created<br>
	 *   by @ref JxlEncoderStatsCreate)<br>
	 * Original signature : <code>void JxlEncoderCollectStats(JxlEncoderFrameSettings*, JxlEncoderStats*)</code><br>
	 * <i>native declaration : jxl/encode.h:1535</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderCollectStats(com.sun.jna.ptr.PointerByReference, JxlEncoderStats)} instead
	 */
	@Deprecated 
	void JxlEncoderCollectStats(Pointer frame_settings, JxlEncoderStats stats);
	/**
	 * Sets the given stats object for gathering various statistics during encoding.<br>
	 * This only has any effect if the encoder was compiled with the appropriate<br>
	 * debug build flags.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param stats object that can be used to query the gathered stats (created<br>
	 *   by @ref JxlEncoderStatsCreate)<br>
	 * Original signature : <code>void JxlEncoderCollectStats(JxlEncoderFrameSettings*, JxlEncoderStats*)</code><br>
	 * <i>native declaration : jxl/encode.h:1535</i>
	 */
	void JxlEncoderCollectStats(PointerByReference frame_settings, JxlEncoderStats stats);
	class JxlEncoder extends PointerType {
		public JxlEncoder(Pointer address) {
			super(address);
		}
		public JxlEncoder() {
			super();
		}
	}
	class JxlExtraChannelType extends PointerType {
		public JxlExtraChannelType(Pointer address) {
			super(address);
		}
		public JxlExtraChannelType() {
			super();
		}
	}
	class JxlEncoderStats extends PointerType {
		public JxlEncoderStats(Pointer address) {
			super(address);
		}
		public JxlEncoderStats() {
			super();
		}
	}
}
