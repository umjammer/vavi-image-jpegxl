package vavi.awt.image.jna.jpegxl.encode;
import com.sun.jna.NativeLong;
import com.sun.jna.ptr.NativeLongByReference;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import vavi.awt.image.jna.jpegxl.JxlBasicInfo;
import vavi.awt.image.jna.jpegxl.JxlBlendInfo;
import vavi.awt.image.jna.jpegxl.JxlCmsInterface.ByValue;
import vavi.awt.image.jna.jpegxl.JxlColorEncoding;
import vavi.awt.image.jna.jpegxl.JxlExtraChannelInfo;
import vavi.awt.image.jna.jpegxl.JxlFrameHeader;
import vavi.awt.image.jna.jpegxl.JxlMemoryManagerStruct;
import vavi.awt.image.jna.jpegxl.JxlPixelFormat;
import vavi.awt.image.jna.jpegxl.Library.JxlParallelRunner;
/**
 * JNA Wrapper for library <b>encode</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface EncodeLibrary extends Library {
	String JNA_LIBRARY_NAME = "jxl";
	NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(EncodeLibrary.JNA_LIBRARY_NAME);
	EncodeLibrary INSTANCE = Native.load(EncodeLibrary.JNA_LIBRARY_NAME, EncodeLibrary.class);
	/**
	 * <i>native declaration : jxl/encode.h</i><br>
	 * enum values
	 */
	public static interface JxlEncoderStatus {
		/** <i>native declaration : jxl/encode.h:44</i> */
		int JXL_ENC_SUCCESS = 0;
		/** <i>native declaration : jxl/encode.h:48</i> */
		int JXL_ENC_ERROR = 1;
		/** <i>native declaration : jxl/encode.h:52</i> */
		int JXL_ENC_NEED_MORE_OUTPUT = 2;
		/** <i>native declaration : jxl/encode.h:59</i> */
		int JXL_ENC_NOT_SUPPORTED = 3;
	}
	/**
	 * <i>native declaration : jxl/encode.h</i><br>
	 * enum values
	 */
	public static interface JxlEncoderError {
		/** <i>native declaration : jxl/encode.h:71</i> */
		int JXL_ENC_ERR_OK = 0;
		/** <i>native declaration : jxl/encode.h:75</i> */
		int JXL_ENC_ERR_GENERIC = 1;
		/** <i>native declaration : jxl/encode.h:80</i> */
		int JXL_ENC_ERR_OOM = 2;
		/** <i>native declaration : jxl/encode.h:85</i> */
		int JXL_ENC_ERR_JBRD = 3;
		/** <i>native declaration : jxl/encode.h:89</i> */
		int JXL_ENC_ERR_BAD_INPUT = 4;
		/** <i>native declaration : jxl/encode.h:95</i> */
		int JXL_ENC_ERR_NOT_SUPPORTED = 0x80;
		/** <i>native declaration : jxl/encode.h:101</i> */
		int JXL_ENC_ERR_API_USAGE = 0x81;
	}
	/**
	 * <i>native declaration : jxl/encode.h</i><br>
	 * enum values
	 */
	public static interface JxlEncoderFrameSettingId {
		/** <i>native declaration : jxl/encode.h:117</i> */
		int JXL_ENC_FRAME_SETTING_EFFORT = 0;
		/** <i>native declaration : jxl/encode.h:123</i> */
		int JXL_ENC_FRAME_SETTING_DECODING_SPEED = 1;
		/** <i>native declaration : jxl/encode.h:131</i> */
		int JXL_ENC_FRAME_SETTING_RESAMPLING = 2;
		/** <i>native declaration : jxl/encode.h:138</i> */
		int JXL_ENC_FRAME_SETTING_EXTRA_CHANNEL_RESAMPLING = 3;
		/** <i>native declaration : jxl/encode.h:149</i> */
		int JXL_ENC_FRAME_SETTING_ALREADY_DOWNSAMPLED = 4;
		/** <i>native declaration : jxl/encode.h:156</i> */
		int JXL_ENC_FRAME_SETTING_PHOTON_NOISE = 5;
		/** <i>native declaration : jxl/encode.h:162</i> */
		int JXL_ENC_FRAME_SETTING_NOISE = 6;
		/** <i>native declaration : jxl/encode.h:167</i> */
		int JXL_ENC_FRAME_SETTING_DOTS = 7;
		/** <i>native declaration : jxl/encode.h:172</i> */
		int JXL_ENC_FRAME_SETTING_PATCHES = 8;
		/** <i>native declaration : jxl/encode.h:177</i> */
		int JXL_ENC_FRAME_SETTING_EPF = 9;
		/** <i>native declaration : jxl/encode.h:182</i> */
		int JXL_ENC_FRAME_SETTING_GABORISH = 10;
		/** <i>native declaration : jxl/encode.h:188</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR = 11;
		/** <i>native declaration : jxl/encode.h:193</i> */
		int JXL_ENC_FRAME_SETTING_KEEP_INVISIBLE = 12;
		/** <i>native declaration : jxl/encode.h:199</i> */
		int JXL_ENC_FRAME_SETTING_GROUP_ORDER = 13;
		/** <i>native declaration : jxl/encode.h:205</i> */
		int JXL_ENC_FRAME_SETTING_GROUP_ORDER_CENTER_X = 14;
		/** <i>native declaration : jxl/encode.h:210</i> */
		int JXL_ENC_FRAME_SETTING_GROUP_ORDER_CENTER_Y = 15;
		/** <i>native declaration : jxl/encode.h:215</i> */
		int JXL_ENC_FRAME_SETTING_RESPONSIVE = 16;
		/** <i>native declaration : jxl/encode.h:221</i> */
		int JXL_ENC_FRAME_SETTING_PROGRESSIVE_AC = 17;
		/** <i>native declaration : jxl/encode.h:227</i> */
		int JXL_ENC_FRAME_SETTING_QPROGRESSIVE_AC = 18;
		/** <i>native declaration : jxl/encode.h:233</i> */
		int JXL_ENC_FRAME_SETTING_PROGRESSIVE_DC = 19;
		/** <i>native declaration : jxl/encode.h:239</i> */
		int JXL_ENC_FRAME_SETTING_CHANNEL_COLORS_GLOBAL_PERCENT = 20;
		/** <i>native declaration : jxl/encode.h:245</i> */
		int JXL_ENC_FRAME_SETTING_CHANNEL_COLORS_GROUP_PERCENT = 21;
		/** <i>native declaration : jxl/encode.h:250</i> */
		int JXL_ENC_FRAME_SETTING_PALETTE_COLORS = 22;
		/** <i>native declaration : jxl/encode.h:255</i> */
		int JXL_ENC_FRAME_SETTING_LOSSY_PALETTE = 23;
		/** <i>native declaration : jxl/encode.h:262</i> */
		int JXL_ENC_FRAME_SETTING_COLOR_TRANSFORM = 24;
		/** <i>native declaration : jxl/encode.h:271</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_COLOR_SPACE = 25;
		/** <i>native declaration : jxl/encode.h:275</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_GROUP_SIZE = 26;
		/** <i>native declaration : jxl/encode.h:282</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_PREDICTOR = 27;
		/** <i>native declaration : jxl/encode.h:288</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_MA_TREE_LEARNING_PERCENT = 28;
		/** <i>native declaration : jxl/encode.h:296</i> */
		int JXL_ENC_FRAME_SETTING_MODULAR_NB_PREV_CHANNELS = 29;
		/** <i>native declaration : jxl/encode.h:301</i> */
		int JXL_ENC_FRAME_SETTING_JPEG_RECON_CFL = 30;
		/** <i>native declaration : jxl/encode.h:312</i> */
		int JXL_ENC_FRAME_INDEX_BOX = 31;
		/** <i>native declaration : jxl/encode.h:319</i> */
		int JXL_ENC_FRAME_SETTING_BROTLI_EFFORT = 32;
		/** <i>native declaration : jxl/encode.h:324</i> */
		int JXL_ENC_FRAME_SETTING_FILL_ENUM = 65535;
	}
	/**
	 * Encoder library version.<br>
	 * @return the encoder library version as an integer:<br>
	 * MAJOR_VERSION * 1000000 + MINOR_VERSION * 1000 + PATCH_VERSION. For example,<br>
	 * version 1.2.3 would return 1002003.<br>
	 * Original signature : <code>uint32_t JxlEncoderVersion()</code><br>
	 * <i>native declaration : jxl/encode.h:13</i>
	 */
	int JxlEncoderVersion();
	/**
	 * Creates an instance of JxlEncoder and initializes it.<br>
	 * @p memory_manager will be used for all the library dynamic allocations made<br>
	 * from this instance. The parameter may be NULL, in which case the default<br>
	 * allocator will be used. See jpegxl/memory_manager.h for details.<br>
	 * @param memory_manager custom allocator function. It may be NULL. The memory<br>
	 *        manager will be copied internally.<br>
	 * @return @c NULL if the instance can not be allocated or initialized<br>
	 * @return pointer to initialized JxlEncoder otherwise<br>
	 * Original signature : <code>JxlEncoder* JxlEncoderCreate(const JxlMemoryManager*)</code><br>
	 * <i>native declaration : jxl/encode.h:340</i>
	 */
	PointerByReference JxlEncoderCreate(JxlMemoryManagerStruct memory_manager);
	/**
	 * Re-initializes a JxlEncoder instance, so it can be re-used for encoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with JxlEncoderCreate, but the memory manager is kept.<br>
	 * @param enc instance to be re-initialized.<br>
	 * Original signature : <code>void JxlEncoderReset(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:349</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderReset(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderReset(Pointer enc);
	/**
	 * Re-initializes a JxlEncoder instance, so it can be re-used for encoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with JxlEncoderCreate, but the memory manager is kept.<br>
	 * @param enc instance to be re-initialized.<br>
	 * Original signature : <code>void JxlEncoderReset(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:349</i>
	 */
	void JxlEncoderReset(PointerByReference enc);
	/**
	 * Deinitializes and frees JxlEncoder instance.<br>
	 * @param enc instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlEncoderDestroy(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:356</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderDestroy(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderDestroy(Pointer enc);
	/**
	 * Deinitializes and frees JxlEncoder instance.<br>
	 * @param enc instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlEncoderDestroy(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:356</i>
	 */
	void JxlEncoderDestroy(PointerByReference enc);
	/**
	 * Sets the color management system (CMS) that will be used for color conversion<br>
	 * (if applicable) during encoding. May only be set before starting encoding. If<br>
	 * left unset, the default CMS implementation will be used.<br>
	 * @param enc encoder object.<br>
	 * @param cms structure representing a CMS implementation. See JxlCmsInterface<br>
	 * for more details.<br>
	 * Original signature : <code>void JxlEncoderSetCms(JxlEncoder*, JxlCmsInterface)</code><br>
	 * <i>native declaration : jxl/encode.h:367</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetCms(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlCmsInterface.ByValue)} instead
	 */
	@Deprecated 
	void JxlEncoderSetCms(Pointer enc, ByValue cms);
	/**
	 * Sets the color management system (CMS) that will be used for color conversion<br>
	 * (if applicable) during encoding. May only be set before starting encoding. If<br>
	 * left unset, the default CMS implementation will be used.<br>
	 * @param enc encoder object.<br>
	 * @param cms structure representing a CMS implementation. See JxlCmsInterface<br>
	 * for more details.<br>
	 * Original signature : <code>void JxlEncoderSetCms(JxlEncoder*, JxlCmsInterface)</code><br>
	 * <i>native declaration : jxl/encode.h:367</i>
	 */
	void JxlEncoderSetCms(PointerByReference enc, ByValue cms);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * encoding.<br>
	 * @param enc encoder object.<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *        be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *        runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return JXL_ENC_SUCCESS if the runner was set, JXL_ENC_ERROR<br>
	 * otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetParallelRunner(JxlEncoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/encode.h:381</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetParallelRunner(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.Library.JxlParallelRunner, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlEncoderSetParallelRunner(Pointer enc, JxlParallelRunner parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * encoding.<br>
	 * @param enc encoder object.<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *        be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *        runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return JXL_ENC_SUCCESS if the runner was set, JXL_ENC_ERROR<br>
	 * otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetParallelRunner(JxlEncoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/encode.h:381</i>
	 */
	int JxlEncoderSetParallelRunner(PointerByReference enc, JxlParallelRunner parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Get the (last) error code in case JXL_ENC_ERROR was returned.<br>
	 * @param enc encoder object.<br>
	 * @return the JxlEncoderError that caused the (last) JXL_ENC_ERROR to be<br>
	 * returned.<br>
	 * Original signature : <code>JxlEncoderError JxlEncoderGetError(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:392</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderGetError(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlEncoderGetError(Pointer enc);
	/**
	 * Get the (last) error code in case JXL_ENC_ERROR was returned.<br>
	 * @param enc encoder object.<br>
	 * @return the JxlEncoderError that caused the (last) JXL_ENC_ERROR to be<br>
	 * returned.<br>
	 * Original signature : <code>JxlEncoderError JxlEncoderGetError(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:392</i>
	 */
	int JxlEncoderGetError(PointerByReference enc);
	/**
	 * Encodes JPEG XL file using the available bytes. @p *avail_out indicates how<br>
	 * many output bytes are available, and @p *next_out points to the input bytes.<br>
	 * *avail_out will be decremented by the amount of bytes that have been<br>
	 * processed by the encoder and *next_out will be incremented by the same<br>
	 * amount, so *next_out will now point at the amount of *avail_out unprocessed<br>
	 * bytes.<br>
	 * The returned status indicates whether the encoder needs more output bytes.<br>
	 * When the return value is not JXL_ENC_ERROR or JXL_ENC_SUCCESS, the encoding<br>
	 * requires more JxlEncoderProcessOutput calls to continue.<br>
	 * This encodes the frames and/or boxes added so far. If the last frame or last<br>
	 * box has been added, @ref JxlEncoderCloseInput, @ref JxlEncoderCloseFrames<br>
	 * and/or @ref JxlEncoderCloseBoxes must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call, or the codestream won't be encoded<br>
	 * correctly.<br>
	 * @param enc encoder object.<br>
	 * @param next_out pointer to next bytes to write to.<br>
	 * @param avail_out amount of bytes available starting from *next_out.<br>
	 * @return JXL_ENC_SUCCESS when encoding finished and all events handled.<br>
	 * @return JXL_ENC_ERROR when encoding failed, e.g. invalid input.<br>
	 * @return JXL_ENC_NEED_MORE_OUTPUT more output buffer is necessary.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderProcessOutput(JxlEncoder*, uint8_t**, size_t*)</code><br>
	 * <i>native declaration : jxl/encode.h:419</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderProcessOutput(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.NativeLongByReference)} instead
	 */
	@Deprecated 
	int JxlEncoderProcessOutput(Pointer enc, PointerByReference next_out, NativeLongByReference avail_out);
	/**
	 * Encodes JPEG XL file using the available bytes. @p *avail_out indicates how<br>
	 * many output bytes are available, and @p *next_out points to the input bytes.<br>
	 * *avail_out will be decremented by the amount of bytes that have been<br>
	 * processed by the encoder and *next_out will be incremented by the same<br>
	 * amount, so *next_out will now point at the amount of *avail_out unprocessed<br>
	 * bytes.<br>
	 * The returned status indicates whether the encoder needs more output bytes.<br>
	 * When the return value is not JXL_ENC_ERROR or JXL_ENC_SUCCESS, the encoding<br>
	 * requires more JxlEncoderProcessOutput calls to continue.<br>
	 * This encodes the frames and/or boxes added so far. If the last frame or last<br>
	 * box has been added, @ref JxlEncoderCloseInput, @ref JxlEncoderCloseFrames<br>
	 * and/or @ref JxlEncoderCloseBoxes must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call, or the codestream won't be encoded<br>
	 * correctly.<br>
	 * @param enc encoder object.<br>
	 * @param next_out pointer to next bytes to write to.<br>
	 * @param avail_out amount of bytes available starting from *next_out.<br>
	 * @return JXL_ENC_SUCCESS when encoding finished and all events handled.<br>
	 * @return JXL_ENC_ERROR when encoding failed, e.g. invalid input.<br>
	 * @return JXL_ENC_NEED_MORE_OUTPUT more output buffer is necessary.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderProcessOutput(JxlEncoder*, uint8_t**, size_t*)</code><br>
	 * <i>native declaration : jxl/encode.h:419</i>
	 */
	int JxlEncoderProcessOutput(PointerByReference enc, PointerByReference next_out, NativeLongByReference avail_out);
	/**
	 * Sets the frame information for this frame to the encoder. This includes<br>
	 * animation information such as frame duration to store in the frame header.<br>
	 * The frame header fields represent the frame as passed to the encoder, but not<br>
	 * necessarily the exact values as they will be encoded file format: the encoder<br>
	 * could change crop and blending options of a frame for more efficient encoding<br>
	 * or introduce additional internal frames. Animation duration and time code<br>
	 * information is not altered since those are immutable metadata of the frame.<br>
	 * It is not required to use this function, however if have_animation is set<br>
	 * to true in the basic info, then this function should be used to set the<br>
	 * time duration of this individual frame. By default individual frames have a<br>
	 * time duration of 0, making them form a composite still. See @ref<br>
	 * JxlFrameHeader for more information.<br>
	 * This information is stored in the JxlEncoderFrameSettings and so is used for<br>
	 * any frame encoded with these JxlEncoderFrameSettings. It is ok to change<br>
	 * between @ref JxlEncoderAddImageFrame calls, each added image frame will have<br>
	 * the frame header that was set in the options at the time of calling<br>
	 * JxlEncoderAddImageFrame.<br>
	 * The is_last and name_length fields of the JxlFrameHeader are ignored, use<br>
	 * @ref JxlEncoderCloseFrames to indicate last frame, and @ref<br>
	 * JxlEncoderSetFrameName to indicate the name and its length instead.<br>
	 * Calling this function will clear any name that was previously set with @ref<br>
	 * JxlEncoderSetFrameName.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_header frame header data to set. Object owned by the caller and<br>
	 * does not need to be kept in memory, its information is copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameHeader(JxlEncoderFrameSettings*, const JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/encode.h:456</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetFrameHeader(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlFrameHeader)} instead
	 */
	@Deprecated 
	int JxlEncoderSetFrameHeader(Pointer frame_settings, JxlFrameHeader frame_header);
	/**
	 * Sets the frame information for this frame to the encoder. This includes<br>
	 * animation information such as frame duration to store in the frame header.<br>
	 * The frame header fields represent the frame as passed to the encoder, but not<br>
	 * necessarily the exact values as they will be encoded file format: the encoder<br>
	 * could change crop and blending options of a frame for more efficient encoding<br>
	 * or introduce additional internal frames. Animation duration and time code<br>
	 * information is not altered since those are immutable metadata of the frame.<br>
	 * It is not required to use this function, however if have_animation is set<br>
	 * to true in the basic info, then this function should be used to set the<br>
	 * time duration of this individual frame. By default individual frames have a<br>
	 * time duration of 0, making them form a composite still. See @ref<br>
	 * JxlFrameHeader for more information.<br>
	 * This information is stored in the JxlEncoderFrameSettings and so is used for<br>
	 * any frame encoded with these JxlEncoderFrameSettings. It is ok to change<br>
	 * between @ref JxlEncoderAddImageFrame calls, each added image frame will have<br>
	 * the frame header that was set in the options at the time of calling<br>
	 * JxlEncoderAddImageFrame.<br>
	 * The is_last and name_length fields of the JxlFrameHeader are ignored, use<br>
	 * @ref JxlEncoderCloseFrames to indicate last frame, and @ref<br>
	 * JxlEncoderSetFrameName to indicate the name and its length instead.<br>
	 * Calling this function will clear any name that was previously set with @ref<br>
	 * JxlEncoderSetFrameName.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_header frame header data to set. Object owned by the caller and<br>
	 * does not need to be kept in memory, its information is copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameHeader(JxlEncoderFrameSettings*, const JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/encode.h:456</i>
	 */
	int JxlEncoderSetFrameHeader(PointerByReference frame_settings, JxlFrameHeader frame_header);
	/**
	 * Sets blend info of an extra channel. The blend info of extra channels is set<br>
	 * separately from that of the color channels, the color channels are set with<br>
	 * @ref JxlEncoderSetFrameHeader.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param index index of the extra channel to use.<br>
	 * @param blend_info blend info to set for the extra channel<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBlendInfo(JxlEncoderFrameSettings*, size_t, const JxlBlendInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:471</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetExtraChannelBlendInfo(com.sun.jna.ptr.PointerByReference, com.sun.jna.NativeLong, vavi.awt.image.jna.jpegxl.JxlBlendInfo)} instead
	 */
	@Deprecated 
	int JxlEncoderSetExtraChannelBlendInfo(Pointer frame_settings, NativeLong index, JxlBlendInfo blend_info);
	/**
	 * Sets blend info of an extra channel. The blend info of extra channels is set<br>
	 * separately from that of the color channels, the color channels are set with<br>
	 * @ref JxlEncoderSetFrameHeader.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param index index of the extra channel to use.<br>
	 * @param blend_info blend info to set for the extra channel<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBlendInfo(JxlEncoderFrameSettings*, size_t, const JxlBlendInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:471</i>
	 */
	int JxlEncoderSetExtraChannelBlendInfo(PointerByReference frame_settings, NativeLong index, JxlBlendInfo blend_info);
	/**
	 * Sets the name of the animation frame. This function is optional, frames are<br>
	 * not required to have a name. This setting is a part of the frame header, and<br>
	 * the same principles as for @ref JxlEncoderSetFrameHeader apply. The<br>
	 * name_length field of JxlFrameHeader is ignored by the encoder, this function<br>
	 * determines the name length instead as the length in bytes of the C string.<br>
	 * The maximum possible name length is 1071 bytes (excluding terminating null<br>
	 * character).<br>
	 * Calling @ref JxlEncoderSetFrameHeader clears any name that was<br>
	 * previously set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_name name of the next frame to be encoded, as a UTF-8 encoded C<br>
	 * string (zero terminated). Owned by the caller, and copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameName(JxlEncoderFrameSettings*, const char*)</code><br>
	 * <i>native declaration : jxl/encode.h:494</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetFrameName(com.sun.jna.ptr.PointerByReference, java.lang.String)} and {@link #JxlEncoderSetFrameName(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlEncoderSetFrameName(Pointer frame_settings, Pointer frame_name);
	/**
	 * Sets the name of the animation frame. This function is optional, frames are<br>
	 * not required to have a name. This setting is a part of the frame header, and<br>
	 * the same principles as for @ref JxlEncoderSetFrameHeader apply. The<br>
	 * name_length field of JxlFrameHeader is ignored by the encoder, this function<br>
	 * determines the name length instead as the length in bytes of the C string.<br>
	 * The maximum possible name length is 1071 bytes (excluding terminating null<br>
	 * character).<br>
	 * Calling @ref JxlEncoderSetFrameHeader clears any name that was<br>
	 * previously set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_name name of the next frame to be encoded, as a UTF-8 encoded C<br>
	 * string (zero terminated). Owned by the caller, and copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameName(JxlEncoderFrameSettings*, const char*)</code><br>
	 * <i>native declaration : jxl/encode.h:494</i>
	 */
	int JxlEncoderSetFrameName(PointerByReference frame_settings, String frame_name);
	/**
	 * Sets the name of the animation frame. This function is optional, frames are<br>
	 * not required to have a name. This setting is a part of the frame header, and<br>
	 * the same principles as for @ref JxlEncoderSetFrameHeader apply. The<br>
	 * name_length field of JxlFrameHeader is ignored by the encoder, this function<br>
	 * determines the name length instead as the length in bytes of the C string.<br>
	 * The maximum possible name length is 1071 bytes (excluding terminating null<br>
	 * character).<br>
	 * Calling @ref JxlEncoderSetFrameHeader clears any name that was<br>
	 * previously set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param frame_name name of the next frame to be encoded, as a UTF-8 encoded C<br>
	 * string (zero terminated). Owned by the caller, and copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameName(JxlEncoderFrameSettings*, const char*)</code><br>
	 * <i>native declaration : jxl/encode.h:494</i>
	 */
	int JxlEncoderSetFrameName(PointerByReference frame_settings, Pointer frame_name);
	/**
	 * Sets the buffer to read JPEG encoded bytes from for the next frame to encode.<br>
	 * If JxlEncoderSetBasicInfo has not yet been called, calling<br>
	 * JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the<br>
	 * added JPEG frame.<br>
	 * If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been<br>
	 * called, calling JxlEncoderAddJPEGFrame will implicitly call it with the<br>
	 * parameters of the added JPEG frame.<br>
	 * If the encoder is set to store JPEG reconstruction metadata using @ref<br>
	 * JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param buffer bytes to read JPEG from. Owned by the caller and its contents<br>
	 * are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddJPEGFrame(const JxlEncoderFrameSettings*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:523</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderAddJPEGFrame(com.sun.jna.ptr.PointerByReference, byte[], com.sun.jna.NativeLong)} and {@link #JxlEncoderAddJPEGFrame(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.NativeLong)} instead
	 */
	@Deprecated 
	int JxlEncoderAddJPEGFrame(Pointer frame_settings, Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to read JPEG encoded bytes from for the next frame to encode.<br>
	 * If JxlEncoderSetBasicInfo has not yet been called, calling<br>
	 * JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the<br>
	 * added JPEG frame.<br>
	 * If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been<br>
	 * called, calling JxlEncoderAddJPEGFrame will implicitly call it with the<br>
	 * parameters of the added JPEG frame.<br>
	 * If the encoder is set to store JPEG reconstruction metadata using @ref<br>
	 * JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param buffer bytes to read JPEG from. Owned by the caller and its contents<br>
	 * are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddJPEGFrame(const JxlEncoderFrameSettings*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:523</i>
	 */
	int JxlEncoderAddJPEGFrame(PointerByReference frame_settings, byte buffer[], NativeLong size);
	/**
	 * Sets the buffer to read JPEG encoded bytes from for the next frame to encode.<br>
	 * If JxlEncoderSetBasicInfo has not yet been called, calling<br>
	 * JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the<br>
	 * added JPEG frame.<br>
	 * If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been<br>
	 * called, calling JxlEncoderAddJPEGFrame will implicitly call it with the<br>
	 * parameters of the added JPEG frame.<br>
	 * If the encoder is set to store JPEG reconstruction metadata using @ref<br>
	 * JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param buffer bytes to read JPEG from. Owned by the caller and its contents<br>
	 * are copied internally.<br>
	 * @param size size of buffer in bytes.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddJPEGFrame(const JxlEncoderFrameSettings*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:523</i>
	 */
	int JxlEncoderAddJPEGFrame(PointerByReference frame_settings, Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to read pixels from for the next image to encode. Must call<br>
	 * JxlEncoderSetBasicInfo before JxlEncoderAddImageFrame.<br>
	 * Currently only some data types for pixel formats are supported:<br>
	 * - JXL_TYPE_UINT8, with range 0..255<br>
	 * - JXL_TYPE_UINT16, with range 0..65535<br>
	 * - JXL_TYPE_FLOAT16, with nominal range 0..1<br>
	 * - JXL_TYPE_FLOAT, with nominal range 0..1<br>
	 * Note: the sample data type in pixel_format is allowed to be different from<br>
	 * what is described in the JxlBasicInfo. The type in pixel_format describes the<br>
	 * format of the uncompressed pixel buffer. The bits_per_sample and<br>
	 * exponent_bits_per_sample in the JxlBasicInfo describes what will actually be<br>
	 * encoded in the JPEG XL codestream. For example, to encode a 12-bit image, you<br>
	 * would set bits_per_sample to 12, and you could use e.g. JXL_TYPE_UINT16<br>
	 * (where the values are rescaled to 16-bit, i.e. multiplied by 65535/4095) or<br>
	 * JXL_TYPE_FLOAT (where the values are rescaled to 0..1, i.e. multiplied<br>
	 * by 1.f/4095.f). While it is allowed, it is obviously not recommended to use a<br>
	 * pixel_format with lower precision than what is specified in the JxlBasicInfo.<br>
	 * We support interleaved channels as described by the JxlPixelFormat:<br>
	 * - single-channel data, e.g. grayscale<br>
	 * - single-channel + alpha<br>
	 * - trichromatic, e.g. RGB<br>
	 * - trichromatic + alpha<br>
	 * Extra channels not handled here need to be set by @ref<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * If the image has alpha, and alpha is not passed here, it will implicitly be<br>
	 * set to all-opaque (an alpha value of 1.0 everywhere).<br>
	 * The pixels are assumed to be encoded in the original profile that is set with<br>
	 * JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile. If none of these<br>
	 * functions were used, the pixels are assumed to be nonlinear sRGB for integer<br>
	 * data types (JXL_TYPE_UINT8, JXL_TYPE_UINT16), and linear sRGB for floating<br>
	 * point data types (JXL_TYPE_FLOAT16, JXL_TYPE_FLOAT).<br>
	 * Sample values in floating-point pixel formats are allowed to be outside the<br>
	 * nominal range, e.g. to represent out-of-sRGB-gamut colors in the<br>
	 * uses_original_profile=false case. They are however not allowed to be NaN or<br>
	 * +-infinity.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddImageFrame(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:584</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderAddImageFrame(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, com.sun.jna.Pointer, com.sun.jna.NativeLong)} instead
	 */
	@Deprecated 
	int JxlEncoderAddImageFrame(Pointer frame_settings, JxlPixelFormat pixel_format, Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to read pixels from for the next image to encode. Must call<br>
	 * JxlEncoderSetBasicInfo before JxlEncoderAddImageFrame.<br>
	 * Currently only some data types for pixel formats are supported:<br>
	 * - JXL_TYPE_UINT8, with range 0..255<br>
	 * - JXL_TYPE_UINT16, with range 0..65535<br>
	 * - JXL_TYPE_FLOAT16, with nominal range 0..1<br>
	 * - JXL_TYPE_FLOAT, with nominal range 0..1<br>
	 * Note: the sample data type in pixel_format is allowed to be different from<br>
	 * what is described in the JxlBasicInfo. The type in pixel_format describes the<br>
	 * format of the uncompressed pixel buffer. The bits_per_sample and<br>
	 * exponent_bits_per_sample in the JxlBasicInfo describes what will actually be<br>
	 * encoded in the JPEG XL codestream. For example, to encode a 12-bit image, you<br>
	 * would set bits_per_sample to 12, and you could use e.g. JXL_TYPE_UINT16<br>
	 * (where the values are rescaled to 16-bit, i.e. multiplied by 65535/4095) or<br>
	 * JXL_TYPE_FLOAT (where the values are rescaled to 0..1, i.e. multiplied<br>
	 * by 1.f/4095.f). While it is allowed, it is obviously not recommended to use a<br>
	 * pixel_format with lower precision than what is specified in the JxlBasicInfo.<br>
	 * We support interleaved channels as described by the JxlPixelFormat:<br>
	 * - single-channel data, e.g. grayscale<br>
	 * - single-channel + alpha<br>
	 * - trichromatic, e.g. RGB<br>
	 * - trichromatic + alpha<br>
	 * Extra channels not handled here need to be set by @ref<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * If the image has alpha, and alpha is not passed here, it will implicitly be<br>
	 * set to all-opaque (an alpha value of 1.0 everywhere).<br>
	 * The pixels are assumed to be encoded in the original profile that is set with<br>
	 * JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile. If none of these<br>
	 * functions were used, the pixels are assumed to be nonlinear sRGB for integer<br>
	 * data types (JXL_TYPE_UINT8, JXL_TYPE_UINT16), and linear sRGB for floating<br>
	 * point data types (JXL_TYPE_FLOAT16, JXL_TYPE_FLOAT).<br>
	 * Sample values in floating-point pixel formats are allowed to be outside the<br>
	 * nominal range, e.g. to represent out-of-sRGB-gamut colors in the<br>
	 * uses_original_profile=false case. They are however not allowed to be NaN or<br>
	 * +-infinity.<br>
	 * If this is the last frame, @ref JxlEncoderCloseInput or @ref<br>
	 * JxlEncoderCloseFrames must be called before the next<br>
	 * @ref JxlEncoderProcessOutput call.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddImageFrame(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:584</i>
	 */
	int JxlEncoderAddImageFrame(PointerByReference frame_settings, JxlPixelFormat pixel_format, Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to read pixels from for an extra channel at a given index.<br>
	 * The index must be smaller than the num_extra_channels in the associated<br>
	 * JxlBasicInfo. Must call @ref JxlEncoderSetExtraChannelInfo before<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * TODO(firsching): mention what data types in pixel formats are supported.<br>
	 * It is required to call this function for every extra channel, except for the<br>
	 * alpha channel if that was already set through @ref JxlEncoderAddImageFrame.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally. The num_channels value is ignored, since the<br>
	 * number of channels for an extra channel is always assumed to be one.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @param index index of the extra channel to use.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBuffer(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/encode.h:611</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetExtraChannelBuffer(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, com.sun.jna.Pointer, com.sun.jna.NativeLong, int)} instead
	 */
	@Deprecated 
	int JxlEncoderSetExtraChannelBuffer(Pointer frame_settings, JxlPixelFormat pixel_format, Pointer buffer, NativeLong size, int index);
	/**
	 * Sets the buffer to read pixels from for an extra channel at a given index.<br>
	 * The index must be smaller than the num_extra_channels in the associated<br>
	 * JxlBasicInfo. Must call @ref JxlEncoderSetExtraChannelInfo before<br>
	 * JxlEncoderSetExtraChannelBuffer.<br>
	 * TODO(firsching): mention what data types in pixel formats are supported.<br>
	 * It is required to call this function for every extra channel, except for the<br>
	 * alpha channel if that was already set through @ref JxlEncoderAddImageFrame.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param pixel_format format for pixels. Object owned by the caller and its<br>
	 * contents are copied internally. The num_channels value is ignored, since the<br>
	 * number of channels for an extra channel is always assumed to be one.<br>
	 * @param buffer buffer type to input the pixel data from. Owned by the caller<br>
	 * and its contents are copied internally.<br>
	 * @param size size of buffer in bytes. This size should match what is implied<br>
	 * by the frame dimensions and the pixel format.<br>
	 * @param index index of the extra channel to use.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelBuffer(const JxlEncoderFrameSettings*, const JxlPixelFormat*, const void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/encode.h:611</i>
	 */
	int JxlEncoderSetExtraChannelBuffer(PointerByReference frame_settings, JxlPixelFormat pixel_format, Pointer buffer, NativeLong size, int index);
	/**
	 * Adds a metadata box to the file format. JxlEncoderProcessOutput must be used<br>
	 * to effectively write the box to the output. @ref JxlEncoderUseBoxes must<br>
	 * be enabled before using this function.<br>
	 * Boxes allow inserting application-specific data and metadata (Exif, XML/XMP,<br>
	 * JUMBF and user defined boxes).<br>
	 * The box format follows ISO BMFF and shares features and box types with other<br>
	 * image and video formats, including the Exif, XML and JUMBF boxes. The box<br>
	 * format for JPEG XL is specified in ISO/IEC 18181-2.<br>
	 * Boxes in general don't contain other boxes inside, except a JUMBF superbox.<br>
	 * Boxes follow each other sequentially and are byte-aligned. If the container<br>
	 * format is used, the JXL stream consists of concatenated boxes.<br>
	 * It is also possible to use a direct codestream without boxes, but in that<br>
	 * case metadata cannot be added.<br>
	 * Each box generally has the following byte structure in the file:<br>
	 * - 4 bytes: box size including box header (Big endian. If set to 0, an<br>
	 *   8-byte 64-bit size follows instead).<br>
	 * - 4 bytes: type, e.g. "JXL " for the signature box, "jxlc" for a codestream<br>
	 *   box.<br>
	 * - N bytes: box contents.<br>
	 * Only the box contents are provided to the contents argument of this function,<br>
	 * the encoder encodes the size header itself. Most boxes are written<br>
	 * automatically by the encoder as needed ("JXL ", "ftyp", "jxll", "jxlc",<br>
	 * "jxlp", "jxli", "jbrd"), and this function only needs to be called to add<br>
	 * optional metadata when encoding from pixels (using JxlEncoderAddImageFrame).<br>
	 * When recompressing JPEG files (using JxlEncoderAddJPEGFrame), if the input<br>
	 * JPEG contains EXIF, XMP or JUMBF metadata, the corresponding boxes are<br>
	 * already added automatically.<br>
	 * Box types are given by 4 characters. The following boxes can be added with<br>
	 * this function:<br>
	 * - "Exif": a box with EXIF metadata, can be added by libjxl users, or is<br>
	 *   automatically added when needed for JPEG reconstruction. The contents of<br>
	 *   this box must be prepended by a 4-byte tiff header offset, which may<br>
	 *   be 4 zero bytes in case the tiff header follows immediately.<br>
	 *   The EXIF metadata must be in sync with what is encoded in the JPEG XL<br>
	 *   codestream, specifically the image orientation. While this is not<br>
	 *   recommended in practice, in case of conflicting metadata, the JPEG XL<br>
	 *   codestream takes precedence.<br>
	 * - "xml ": a box with XML data, in particular XMP metadata, can be added by<br>
	 *   libjxl users, or is automatically added when needed for JPEG reconstruction<br>
	 * - "jumb": a JUMBF superbox, which can contain boxes with different types of<br>
	 *   metadata inside. This box type can be added by the encoder transparently,<br>
	 *   and other libraries to create and handle JUMBF content exist.<br>
	 * - Application-specific boxes. Their typename should not begin with "jxl" or<br>
	 *   "JXL" or conflict with other existing typenames, and they should be<br>
	 *   registered with MP4RA (mp4ra.org).<br>
	 * These boxes can be stored uncompressed or Brotli-compressed (using a "brob"<br>
	 * box), depending on the compress_box parameter.<br>
	 * @param enc encoder object.<br>
	 * @param type the box type, e.g. "Exif" for EXIF metadata, "xml " for XMP or<br>
	 * IPTC metadata, "jumb" for JUMBF metadata.<br>
	 * @param contents the full contents of the box, for example EXIF<br>
	 * data. ISO BMFF box header must not be included, only the contents. Owned by<br>
	 * the caller and its contents are copied internally.<br>
	 * @param size size of the box contents.<br>
	 * @param compress_box Whether to compress this box as a "brob" box. Requires<br>
	 * Brotli support.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error, such as when<br>
	 * using this function without JxlEncoderUseContainer, or adding a box type<br>
	 * that would result in an invalid file format.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddBox(JxlEncoder*, const JxlBoxType, const uint8_t*, size_t, int)</code><br>
	 * <i>native declaration : jxl/encode.h:684</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderAddBox(com.sun.jna.ptr.PointerByReference, java.nio.ByteBuffer, byte[], com.sun.jna.NativeLong, int)} and {@link #JxlEncoderAddBox(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.NativeLong, int)} instead
	 */
	@Deprecated 
	int JxlEncoderAddBox(Pointer enc, Pointer type, Pointer contents, NativeLong size, int compress_box);
	/**
	 * Adds a metadata box to the file format. JxlEncoderProcessOutput must be used<br>
	 * to effectively write the box to the output. @ref JxlEncoderUseBoxes must<br>
	 * be enabled before using this function.<br>
	 * Boxes allow inserting application-specific data and metadata (Exif, XML/XMP,<br>
	 * JUMBF and user defined boxes).<br>
	 * The box format follows ISO BMFF and shares features and box types with other<br>
	 * image and video formats, including the Exif, XML and JUMBF boxes. The box<br>
	 * format for JPEG XL is specified in ISO/IEC 18181-2.<br>
	 * Boxes in general don't contain other boxes inside, except a JUMBF superbox.<br>
	 * Boxes follow each other sequentially and are byte-aligned. If the container<br>
	 * format is used, the JXL stream consists of concatenated boxes.<br>
	 * It is also possible to use a direct codestream without boxes, but in that<br>
	 * case metadata cannot be added.<br>
	 * Each box generally has the following byte structure in the file:<br>
	 * - 4 bytes: box size including box header (Big endian. If set to 0, an<br>
	 *   8-byte 64-bit size follows instead).<br>
	 * - 4 bytes: type, e.g. "JXL " for the signature box, "jxlc" for a codestream<br>
	 *   box.<br>
	 * - N bytes: box contents.<br>
	 * Only the box contents are provided to the contents argument of this function,<br>
	 * the encoder encodes the size header itself. Most boxes are written<br>
	 * automatically by the encoder as needed ("JXL ", "ftyp", "jxll", "jxlc",<br>
	 * "jxlp", "jxli", "jbrd"), and this function only needs to be called to add<br>
	 * optional metadata when encoding from pixels (using JxlEncoderAddImageFrame).<br>
	 * When recompressing JPEG files (using JxlEncoderAddJPEGFrame), if the input<br>
	 * JPEG contains EXIF, XMP or JUMBF metadata, the corresponding boxes are<br>
	 * already added automatically.<br>
	 * Box types are given by 4 characters. The following boxes can be added with<br>
	 * this function:<br>
	 * - "Exif": a box with EXIF metadata, can be added by libjxl users, or is<br>
	 *   automatically added when needed for JPEG reconstruction. The contents of<br>
	 *   this box must be prepended by a 4-byte tiff header offset, which may<br>
	 *   be 4 zero bytes in case the tiff header follows immediately.<br>
	 *   The EXIF metadata must be in sync with what is encoded in the JPEG XL<br>
	 *   codestream, specifically the image orientation. While this is not<br>
	 *   recommended in practice, in case of conflicting metadata, the JPEG XL<br>
	 *   codestream takes precedence.<br>
	 * - "xml ": a box with XML data, in particular XMP metadata, can be added by<br>
	 *   libjxl users, or is automatically added when needed for JPEG reconstruction<br>
	 * - "jumb": a JUMBF superbox, which can contain boxes with different types of<br>
	 *   metadata inside. This box type can be added by the encoder transparently,<br>
	 *   and other libraries to create and handle JUMBF content exist.<br>
	 * - Application-specific boxes. Their typename should not begin with "jxl" or<br>
	 *   "JXL" or conflict with other existing typenames, and they should be<br>
	 *   registered with MP4RA (mp4ra.org).<br>
	 * These boxes can be stored uncompressed or Brotli-compressed (using a "brob"<br>
	 * box), depending on the compress_box parameter.<br>
	 * @param enc encoder object.<br>
	 * @param type the box type, e.g. "Exif" for EXIF metadata, "xml " for XMP or<br>
	 * IPTC metadata, "jumb" for JUMBF metadata.<br>
	 * @param contents the full contents of the box, for example EXIF<br>
	 * data. ISO BMFF box header must not be included, only the contents. Owned by<br>
	 * the caller and its contents are copied internally.<br>
	 * @param size size of the box contents.<br>
	 * @param compress_box Whether to compress this box as a "brob" box. Requires<br>
	 * Brotli support.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error, such as when<br>
	 * using this function without JxlEncoderUseContainer, or adding a box type<br>
	 * that would result in an invalid file format.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddBox(JxlEncoder*, const JxlBoxType, const uint8_t*, size_t, int)</code><br>
	 * <i>native declaration : jxl/encode.h:684</i>
	 */
	int JxlEncoderAddBox(PointerByReference enc, ByteBuffer type, byte contents[], NativeLong size, int compress_box);
	/**
	 * Adds a metadata box to the file format. JxlEncoderProcessOutput must be used<br>
	 * to effectively write the box to the output. @ref JxlEncoderUseBoxes must<br>
	 * be enabled before using this function.<br>
	 * Boxes allow inserting application-specific data and metadata (Exif, XML/XMP,<br>
	 * JUMBF and user defined boxes).<br>
	 * The box format follows ISO BMFF and shares features and box types with other<br>
	 * image and video formats, including the Exif, XML and JUMBF boxes. The box<br>
	 * format for JPEG XL is specified in ISO/IEC 18181-2.<br>
	 * Boxes in general don't contain other boxes inside, except a JUMBF superbox.<br>
	 * Boxes follow each other sequentially and are byte-aligned. If the container<br>
	 * format is used, the JXL stream consists of concatenated boxes.<br>
	 * It is also possible to use a direct codestream without boxes, but in that<br>
	 * case metadata cannot be added.<br>
	 * Each box generally has the following byte structure in the file:<br>
	 * - 4 bytes: box size including box header (Big endian. If set to 0, an<br>
	 *   8-byte 64-bit size follows instead).<br>
	 * - 4 bytes: type, e.g. "JXL " for the signature box, "jxlc" for a codestream<br>
	 *   box.<br>
	 * - N bytes: box contents.<br>
	 * Only the box contents are provided to the contents argument of this function,<br>
	 * the encoder encodes the size header itself. Most boxes are written<br>
	 * automatically by the encoder as needed ("JXL ", "ftyp", "jxll", "jxlc",<br>
	 * "jxlp", "jxli", "jbrd"), and this function only needs to be called to add<br>
	 * optional metadata when encoding from pixels (using JxlEncoderAddImageFrame).<br>
	 * When recompressing JPEG files (using JxlEncoderAddJPEGFrame), if the input<br>
	 * JPEG contains EXIF, XMP or JUMBF metadata, the corresponding boxes are<br>
	 * already added automatically.<br>
	 * Box types are given by 4 characters. The following boxes can be added with<br>
	 * this function:<br>
	 * - "Exif": a box with EXIF metadata, can be added by libjxl users, or is<br>
	 *   automatically added when needed for JPEG reconstruction. The contents of<br>
	 *   this box must be prepended by a 4-byte tiff header offset, which may<br>
	 *   be 4 zero bytes in case the tiff header follows immediately.<br>
	 *   The EXIF metadata must be in sync with what is encoded in the JPEG XL<br>
	 *   codestream, specifically the image orientation. While this is not<br>
	 *   recommended in practice, in case of conflicting metadata, the JPEG XL<br>
	 *   codestream takes precedence.<br>
	 * - "xml ": a box with XML data, in particular XMP metadata, can be added by<br>
	 *   libjxl users, or is automatically added when needed for JPEG reconstruction<br>
	 * - "jumb": a JUMBF superbox, which can contain boxes with different types of<br>
	 *   metadata inside. This box type can be added by the encoder transparently,<br>
	 *   and other libraries to create and handle JUMBF content exist.<br>
	 * - Application-specific boxes. Their typename should not begin with "jxl" or<br>
	 *   "JXL" or conflict with other existing typenames, and they should be<br>
	 *   registered with MP4RA (mp4ra.org).<br>
	 * These boxes can be stored uncompressed or Brotli-compressed (using a "brob"<br>
	 * box), depending on the compress_box parameter.<br>
	 * @param enc encoder object.<br>
	 * @param type the box type, e.g. "Exif" for EXIF metadata, "xml " for XMP or<br>
	 * IPTC metadata, "jumb" for JUMBF metadata.<br>
	 * @param contents the full contents of the box, for example EXIF<br>
	 * data. ISO BMFF box header must not be included, only the contents. Owned by<br>
	 * the caller and its contents are copied internally.<br>
	 * @param size size of the box contents.<br>
	 * @param compress_box Whether to compress this box as a "brob" box. Requires<br>
	 * Brotli support.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error, such as when<br>
	 * using this function without JxlEncoderUseContainer, or adding a box type<br>
	 * that would result in an invalid file format.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderAddBox(JxlEncoder*, const JxlBoxType, const uint8_t*, size_t, int)</code><br>
	 * <i>native declaration : jxl/encode.h:684</i>
	 */
	int JxlEncoderAddBox(PointerByReference enc, Pointer type, Pointer contents, NativeLong size, int compress_box);
	/**
	 * Indicates the intention to add metadata boxes. This allows @ref<br>
	 * JxlEncoderAddBox to be used. When using this function, then it is required<br>
	 * to use @ref JxlEncoderCloseBoxes at the end.<br>
	 * By default the encoder assumes no metadata boxes will be added.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseBoxes(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:701</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderUseBoxes(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlEncoderUseBoxes(Pointer enc);
	/**
	 * Indicates the intention to add metadata boxes. This allows @ref<br>
	 * JxlEncoderAddBox to be used. When using this function, then it is required<br>
	 * to use @ref JxlEncoderCloseBoxes at the end.<br>
	 * By default the encoder assumes no metadata boxes will be added.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseBoxes(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:701</i>
	 */
	int JxlEncoderUseBoxes(PointerByReference enc);
	/**
	 * Declares that no further boxes will be added with @ref JxlEncoderAddBox.<br>
	 * This function must be called after the last box is added so the encoder knows<br>
	 * the stream will be finished. It is not necessary to use this function if<br>
	 * @ref JxlEncoderUseBoxes is not used. Further frames may still be added.<br>
	 * Must be called between JxlEncoderAddBox of the last box<br>
	 * and the next call to JxlEncoderProcessOutput, or @ref JxlEncoderProcessOutput<br>
	 * won't output the last box correctly.<br>
	 * NOTE: if you don't need to close frames and boxes at separate times, you can<br>
	 * use @ref JxlEncoderCloseInput instead to close both at once.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseBoxes(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:718</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderCloseBoxes(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderCloseBoxes(Pointer enc);
	/**
	 * Declares that no further boxes will be added with @ref JxlEncoderAddBox.<br>
	 * This function must be called after the last box is added so the encoder knows<br>
	 * the stream will be finished. It is not necessary to use this function if<br>
	 * @ref JxlEncoderUseBoxes is not used. Further frames may still be added.<br>
	 * Must be called between JxlEncoderAddBox of the last box<br>
	 * and the next call to JxlEncoderProcessOutput, or @ref JxlEncoderProcessOutput<br>
	 * won't output the last box correctly.<br>
	 * NOTE: if you don't need to close frames and boxes at separate times, you can<br>
	 * use @ref JxlEncoderCloseInput instead to close both at once.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseBoxes(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:718</i>
	 */
	void JxlEncoderCloseBoxes(PointerByReference enc);
	/**
	 * Declares that no frames will be added and @ref JxlEncoderAddImageFrame and<br>
	 * @ref JxlEncoderAddJPEGFrame won't be called anymore. Further metadata boxes<br>
	 * may still be added. This function or @ref JxlEncoderCloseInput must be called<br>
	 * after adding the last frame and the next call to<br>
	 * @ref JxlEncoderProcessOutput, or the frame won't be properly marked as last.<br>
	 * NOTE: if you don't need to close frames and boxes at separate times, you can<br>
	 * use @ref JxlEncoderCloseInput instead to close both at once.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseFrames(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:732</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderCloseFrames(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderCloseFrames(Pointer enc);
	/**
	 * Declares that no frames will be added and @ref JxlEncoderAddImageFrame and<br>
	 * @ref JxlEncoderAddJPEGFrame won't be called anymore. Further metadata boxes<br>
	 * may still be added. This function or @ref JxlEncoderCloseInput must be called<br>
	 * after adding the last frame and the next call to<br>
	 * @ref JxlEncoderProcessOutput, or the frame won't be properly marked as last.<br>
	 * NOTE: if you don't need to close frames and boxes at separate times, you can<br>
	 * use @ref JxlEncoderCloseInput instead to close both at once.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseFrames(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:732</i>
	 */
	void JxlEncoderCloseFrames(PointerByReference enc);
	/**
	 * Closes any input to the encoder, equivalent to calling JxlEncoderCloseFrames<br>
	 * as well as calling JxlEncoderCloseBoxes if needed. No further input of any<br>
	 * kind may be given to the encoder, but further @ref JxlEncoderProcessOutput<br>
	 * calls should be done to create the final output.<br>
	 * The requirements of both @ref JxlEncoderCloseFrames and @ref<br>
	 * JxlEncoderCloseBoxes apply to this function. Either this function or the<br>
	 * other two must be called after the final frame and/or box, and the next<br>
	 * @ref JxlEncoderProcessOutput call, or the codestream won't be encoded<br>
	 * correctly.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseInput(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:748</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderCloseInput(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlEncoderCloseInput(Pointer enc);
	/**
	 * Closes any input to the encoder, equivalent to calling JxlEncoderCloseFrames<br>
	 * as well as calling JxlEncoderCloseBoxes if needed. No further input of any<br>
	 * kind may be given to the encoder, but further @ref JxlEncoderProcessOutput<br>
	 * calls should be done to create the final output.<br>
	 * The requirements of both @ref JxlEncoderCloseFrames and @ref<br>
	 * JxlEncoderCloseBoxes apply to this function. Either this function or the<br>
	 * other two must be called after the final frame and/or box, and the next<br>
	 * @ref JxlEncoderProcessOutput call, or the codestream won't be encoded<br>
	 * correctly.<br>
	 * @param enc encoder object.<br>
	 * Original signature : <code>void JxlEncoderCloseInput(JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:748</i>
	 */
	void JxlEncoderCloseInput(PointerByReference enc);
	/**
	 * Sets the original color encoding of the image encoded by this encoder. This<br>
	 * is an alternative to JxlEncoderSetICCProfile and only one of these two must<br>
	 * be used. This one sets the color encoding as a @ref JxlColorEncoding, while<br>
	 * the other sets it as ICC binary data.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param color color encoding. Object owned by the caller and its contents are<br>
	 * copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetColorEncoding(JxlEncoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/encode.h:763</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetColorEncoding(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlColorEncoding)} instead
	 */
	@Deprecated 
	int JxlEncoderSetColorEncoding(Pointer enc, JxlColorEncoding color);
	/**
	 * Sets the original color encoding of the image encoded by this encoder. This<br>
	 * is an alternative to JxlEncoderSetICCProfile and only one of these two must<br>
	 * be used. This one sets the color encoding as a @ref JxlColorEncoding, while<br>
	 * the other sets it as ICC binary data.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param color color encoding. Object owned by the caller and its contents are<br>
	 * copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetColorEncoding(JxlEncoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/encode.h:763</i>
	 */
	int JxlEncoderSetColorEncoding(PointerByReference enc, JxlColorEncoding color);
	/**
	 * Sets the original color encoding of the image encoded by this encoder as an<br>
	 * ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and<br>
	 * only one of these two must be used. This one sets the color encoding as ICC<br>
	 * binary data, while the other defines it as a @ref JxlColorEncoding.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param icc_profile bytes of the original ICC profile<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetICCProfile(JxlEncoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:779</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetICCProfile(com.sun.jna.ptr.PointerByReference, byte[], com.sun.jna.NativeLong)} and {@link #JxlEncoderSetICCProfile(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.NativeLong)} instead
	 */
	@Deprecated 
	int JxlEncoderSetICCProfile(Pointer enc, Pointer icc_profile, NativeLong size);
	/**
	 * Sets the original color encoding of the image encoded by this encoder as an<br>
	 * ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and<br>
	 * only one of these two must be used. This one sets the color encoding as ICC<br>
	 * binary data, while the other defines it as a @ref JxlColorEncoding.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param icc_profile bytes of the original ICC profile<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetICCProfile(JxlEncoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:779</i>
	 */
	int JxlEncoderSetICCProfile(PointerByReference enc, byte icc_profile[], NativeLong size);
	/**
	 * Sets the original color encoding of the image encoded by this encoder as an<br>
	 * ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and<br>
	 * only one of these two must be used. This one sets the color encoding as ICC<br>
	 * binary data, while the other defines it as a @ref JxlColorEncoding.<br>
	 * Must be called after JxlEncoderSetBasicInfo.<br>
	 * @param enc encoder object.<br>
	 * @param icc_profile bytes of the original ICC profile<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or<br>
	 * JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetICCProfile(JxlEncoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:779</i>
	 */
	int JxlEncoderSetICCProfile(PointerByReference enc, Pointer icc_profile, NativeLong size);
	/**
	 * Initializes a JxlBasicInfo struct to default values.<br>
	 * For forwards-compatibility, this function has to be called before values<br>
	 * are assigned to the struct fields.<br>
	 * The default values correspond to an 8-bit RGB image, no alpha or any<br>
	 * other extra channels.<br>
	 * @param info global image metadata. Object owned by the caller.<br>
	 * Original signature : <code>void JxlEncoderInitBasicInfo(JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:792</i>
	 */
	void JxlEncoderInitBasicInfo(JxlBasicInfo info);
	/**
	 * Initializes a JxlFrameHeader struct to default values.<br>
	 * For forwards-compatibility, this function has to be called before values<br>
	 * are assigned to the struct fields.<br>
	 * The default values correspond to a frame with no animation duration and the<br>
	 * 'replace' blend mode. After using this function, For animation duration must<br>
	 * be set, for composite still blend settings must be set.<br>
	 * @param frame_header frame metadata. Object owned by the caller.<br>
	 * Original signature : <code>void JxlEncoderInitFrameHeader(JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/encode.h:804</i>
	 */
	void JxlEncoderInitFrameHeader(JxlFrameHeader frame_header);
	/**
	 * Initializes a JxlBlendInfo struct to default values.<br>
	 * For forwards-compatibility, this function has to be called before values<br>
	 * are assigned to the struct fields.<br>
	 * @param blend_info blending info. Object owned by the caller.<br>
	 * Original signature : <code>void JxlEncoderInitBlendInfo(JxlBlendInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:813</i>
	 */
	void JxlEncoderInitBlendInfo(JxlBlendInfo blend_info);
	/**
	 * Sets the global metadata of the image encoded by this encoder.<br>
	 * If the JxlBasicInfo contains information of extra channels beyond an alpha<br>
	 * channel, then @ref JxlEncoderSetExtraChannelInfo must be called between<br>
	 * JxlEncoderSetBasicInfo and @ref JxlEncoderAddImageFrame. In order to indicate<br>
	 * extra channels, the value of `info.num_extra_channels` should be set to the<br>
	 * number of extra channels, also counting the alpha channel if present.<br>
	 * @param enc encoder object.<br>
	 * @param info global image metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful,<br>
	 * JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetBasicInfo(JxlEncoder*, const JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:830</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetBasicInfo(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlBasicInfo)} instead
	 */
	@Deprecated 
	int JxlEncoderSetBasicInfo(Pointer enc, JxlBasicInfo info);
	/**
	 * Sets the global metadata of the image encoded by this encoder.<br>
	 * If the JxlBasicInfo contains information of extra channels beyond an alpha<br>
	 * channel, then @ref JxlEncoderSetExtraChannelInfo must be called between<br>
	 * JxlEncoderSetBasicInfo and @ref JxlEncoderAddImageFrame. In order to indicate<br>
	 * extra channels, the value of `info.num_extra_channels` should be set to the<br>
	 * number of extra channels, also counting the alpha channel if present.<br>
	 * @param enc encoder object.<br>
	 * @param info global image metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful,<br>
	 * JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetBasicInfo(JxlEncoder*, const JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:830</i>
	 */
	int JxlEncoderSetBasicInfo(PointerByReference enc, JxlBasicInfo info);
	/**
	 * Initializes a JxlExtraChannelInfo struct to default values.<br>
	 * For forwards-compatibility, this function has to be called before values<br>
	 * are assigned to the struct fields.<br>
	 * The default values correspond to an 8-bit channel of the provided type.<br>
	 * @param type type of the extra channel.<br>
	 * @param info global extra channel metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * Original signature : <code>void JxlEncoderInitExtraChannelInfo(JxlExtraChannelType, JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:843</i>
	 */
	void JxlEncoderInitExtraChannelInfo(int type, JxlExtraChannelInfo info);
	/**
	 * Sets information for the extra channel at the given index. The index<br>
	 * must be smaller than num_extra_channels in the associated JxlBasicInfo.<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param info global extra channel metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelInfo(JxlEncoder*, size_t, const JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:856</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetExtraChannelInfo(com.sun.jna.ptr.PointerByReference, com.sun.jna.NativeLong, vavi.awt.image.jna.jpegxl.JxlExtraChannelInfo)} instead
	 */
	@Deprecated 
	int JxlEncoderSetExtraChannelInfo(Pointer enc, NativeLong index, JxlExtraChannelInfo info);
	/**
	 * Sets information for the extra channel at the given index. The index<br>
	 * must be smaller than num_extra_channels in the associated JxlBasicInfo.<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param info global extra channel metadata. Object owned by the caller and its<br>
	 * contents are copied internally.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelInfo(JxlEncoder*, size_t, const JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/encode.h:856</i>
	 */
	int JxlEncoderSetExtraChannelInfo(PointerByReference enc, NativeLong index, JxlExtraChannelInfo info);
	/**
	 * Sets the name for the extra channel at the given index in UTF-8. The index<br>
	 * must be smaller than the num_extra_channels in the associated JxlBasicInfo.<br>
	 * TODO(lode): remove size parameter for consistency with<br>
	 * JxlEncoderSetFrameName<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param name buffer with the name of the extra channel.<br>
	 * @param size size of the name buffer in bytes, not counting the terminating<br>
	 * character.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelName(JxlEncoder*, size_t, const char*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:873</i><br>
	 * @deprecated use the safer methods {@link #JxlEncoderSetExtraChannelName(com.sun.jna.ptr.PointerByReference, com.sun.jna.NativeLong, java.lang.String, com.sun.jna.NativeLong)} and {@link #JxlEncoderSetExtraChannelName(com.sun.jna.ptr.PointerByReference, com.sun.jna.NativeLong, com.sun.jna.Pointer, com.sun.jna.NativeLong)} instead
	 */
	@Deprecated 
	int JxlEncoderSetExtraChannelName(Pointer enc, NativeLong index, Pointer name, NativeLong size);
	/**
	 * Sets the name for the extra channel at the given index in UTF-8. The index<br>
	 * must be smaller than the num_extra_channels in the associated JxlBasicInfo.<br>
	 * TODO(lode): remove size parameter for consistency with<br>
	 * JxlEncoderSetFrameName<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param name buffer with the name of the extra channel.<br>
	 * @param size size of the name buffer in bytes, not counting the terminating<br>
	 * character.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelName(JxlEncoder*, size_t, const char*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:873</i>
	 */
	int JxlEncoderSetExtraChannelName(PointerByReference enc, NativeLong index, String name, NativeLong size);
	/**
	 * Sets the name for the extra channel at the given index in UTF-8. The index<br>
	 * must be smaller than the num_extra_channels in the associated JxlBasicInfo.<br>
	 * TODO(lode): remove size parameter for consistency with<br>
	 * JxlEncoderSetFrameName<br>
	 * @param enc encoder object<br>
	 * @param index index of the extra channel to set.<br>
	 * @param name buffer with the name of the extra channel.<br>
	 * @param size size of the name buffer in bytes, not counting the terminating<br>
	 * character.<br>
	 * @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetExtraChannelName(JxlEncoder*, size_t, const char*, size_t)</code><br>
	 * <i>native declaration : jxl/encode.h:873</i>
	 */
	int JxlEncoderSetExtraChannelName(PointerByReference enc, NativeLong index, Pointer name, NativeLong size);
	/**
	 * Sets a frame-specific option of integer type to the encoder options.<br>
	 * The JxlEncoderFrameSettingId argument determines which option is set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param option ID of the option to set.<br>
	 * @param value Integer value to set for this option.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in<br>
	 * case of an error, such as invalid or unknown option id, or invalid integer<br>
	 * value for the given option. If an error is returned, the state of the<br>
	 * JxlEncoderFrameSettings object is still valid and is the same as before this<br>
	 * function was called.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFrameSettingsSetOption(JxlEncoderFrameSettings*, JxlEncoderFrameSettingId, int64_t)</code><br>
	 * <i>native declaration : jxl/encode.h:892</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderFrameSettingsSetOption(com.sun.jna.ptr.PointerByReference, int, long)} instead
	 */
	@Deprecated 
	int JxlEncoderFrameSettingsSetOption(Pointer frame_settings, int option, long value);
	/**
	 * Sets a frame-specific option of integer type to the encoder options.<br>
	 * The JxlEncoderFrameSettingId argument determines which option is set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param option ID of the option to set.<br>
	 * @param value Integer value to set for this option.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in<br>
	 * case of an error, such as invalid or unknown option id, or invalid integer<br>
	 * value for the given option. If an error is returned, the state of the<br>
	 * JxlEncoderFrameSettings object is still valid and is the same as before this<br>
	 * function was called.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFrameSettingsSetOption(JxlEncoderFrameSettings*, JxlEncoderFrameSettingId, int64_t)</code><br>
	 * <i>native declaration : jxl/encode.h:892</i>
	 */
	int JxlEncoderFrameSettingsSetOption(PointerByReference frame_settings, int option, long value);
	/**
	 * Sets a frame-specific option of float type to the encoder options.<br>
	 * The JxlEncoderFrameSettingId argument determines which option is set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param option ID of the option to set.<br>
	 * @param value Float value to set for this option.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in<br>
	 * case of an error, such as invalid or unknown option id, or invalid integer<br>
	 * value for the given option. If an error is returned, the state of the<br>
	 * JxlEncoderFrameSettings object is still valid and is the same as before this<br>
	 * function was called.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFrameSettingsSetFloatOption(JxlEncoderFrameSettings*, JxlEncoderFrameSettingId, float)</code><br>
	 * <i>native declaration : jxl/encode.h:910</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderFrameSettingsSetFloatOption(com.sun.jna.ptr.PointerByReference, int, float)} instead
	 */
	@Deprecated 
	int JxlEncoderFrameSettingsSetFloatOption(Pointer frame_settings, int option, float value);
	/**
	 * Sets a frame-specific option of float type to the encoder options.<br>
	 * The JxlEncoderFrameSettingId argument determines which option is set.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param option ID of the option to set.<br>
	 * @param value Float value to set for this option.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in<br>
	 * case of an error, such as invalid or unknown option id, or invalid integer<br>
	 * value for the given option. If an error is returned, the state of the<br>
	 * JxlEncoderFrameSettings object is still valid and is the same as before this<br>
	 * function was called.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderFrameSettingsSetFloatOption(JxlEncoderFrameSettings*, JxlEncoderFrameSettingId, float)</code><br>
	 * <i>native declaration : jxl/encode.h:910</i>
	 */
	int JxlEncoderFrameSettingsSetFloatOption(PointerByReference frame_settings, int option, float value);
	/**
	 * Forces the encoder to use the box-based container format (BMFF) even<br>
	 * when not necessary.<br>
	 * When using @ref JxlEncoderUseBoxes, @ref JxlEncoderStoreJPEGMetadata or @ref<br>
	 * JxlEncoderSetCodestreamLevel with level 10, the encoder will automatically<br>
	 * also use the container format, it is not necessary to use<br>
	 * JxlEncoderUseContainer for those use cases.<br>
	 * By default this setting is disabled.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param use_container true if the encoder should always output the JPEG XL<br>
	 * container format, false to only output it when necessary.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseContainer(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:932</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderUseContainer(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderUseContainer(Pointer enc, int use_container);
	/**
	 * Forces the encoder to use the box-based container format (BMFF) even<br>
	 * when not necessary.<br>
	 * When using @ref JxlEncoderUseBoxes, @ref JxlEncoderStoreJPEGMetadata or @ref<br>
	 * JxlEncoderSetCodestreamLevel with level 10, the encoder will automatically<br>
	 * also use the container format, it is not necessary to use<br>
	 * JxlEncoderUseContainer for those use cases.<br>
	 * By default this setting is disabled.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param use_container true if the encoder should always output the JPEG XL<br>
	 * container format, false to only output it when necessary.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderUseContainer(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:932</i>
	 */
	int JxlEncoderUseContainer(PointerByReference enc, int use_container);
	/**
	 * Configure the encoder to store JPEG reconstruction metadata in the JPEG XL<br>
	 * container.<br>
	 * If this is set to true and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param store_jpeg_metadata true if the encoder should store JPEG metadata.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderStoreJPEGMetadata(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:949</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderStoreJPEGMetadata(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderStoreJPEGMetadata(Pointer enc, int store_jpeg_metadata);
	/**
	 * Configure the encoder to store JPEG reconstruction metadata in the JPEG XL<br>
	 * container.<br>
	 * If this is set to true and a single JPEG frame is added, it will be<br>
	 * possible to losslessly reconstruct the JPEG codestream.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param store_jpeg_metadata true if the encoder should store JPEG metadata.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderStoreJPEGMetadata(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:949</i>
	 */
	int JxlEncoderStoreJPEGMetadata(PointerByReference enc, int store_jpeg_metadata);
	/**
	 * Sets the feature level of the JPEG XL codestream. Valid values are 5 and<br>
	 * 10, or -1 (to choose automatically). Using the minimum required level, or<br>
	 * level 5 in most cases, is recommended for compatibility with all decoders.<br>
	 * Level 5: for end-user image delivery, this level is the most widely<br>
	 * supported level by image decoders and the recommended level to use unless a<br>
	 * level 10 feature is absolutely necessary. Supports a maximum resolution<br>
	 * 268435456 pixels total with a maximum width or height of 262144 pixels,<br>
	 * maximum 16-bit color channel depth, maximum 120 frames per second for<br>
	 * animation, maximum ICC color profile size of 4 MiB, it allows all color<br>
	 * models and extra channel types except CMYK and the JXL_CHANNEL_BLACK extra<br>
	 * channel, and a maximum of 4 extra channels in addition to the 3 color<br>
	 * channels. It also sets boundaries to certain internally used coding tools.<br>
	 * Level 10: this level removes or increases the bounds of most of the level<br>
	 * 5 limitations, allows CMYK color and up to 32 bits per color channel, but<br>
	 * may be less widely supported.<br>
	 * The default value is -1. This means the encoder will automatically choose<br>
	 * between level 5 and level 10 based on what information is inside the @ref<br>
	 * JxlBasicInfo structure. Do note that some level 10 features, particularly<br>
	 * those used by animated JPEG XL codestreams, might require level 10, even<br>
	 * though the @ref JxlBasicInfo only suggests level 5. In this case, the level<br>
	 * must be explicitly set to 10, otherwise the encoder will return an error.<br>
	 * The encoder will restrict internal encoding choices to those compatible with<br>
	 * the level setting.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param level the level value to set, must be -1, 5, or 10.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetCodestreamLevel(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:986</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetCodestreamLevel(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderSetCodestreamLevel(Pointer enc, int level);
	/**
	 * Sets the feature level of the JPEG XL codestream. Valid values are 5 and<br>
	 * 10, or -1 (to choose automatically). Using the minimum required level, or<br>
	 * level 5 in most cases, is recommended for compatibility with all decoders.<br>
	 * Level 5: for end-user image delivery, this level is the most widely<br>
	 * supported level by image decoders and the recommended level to use unless a<br>
	 * level 10 feature is absolutely necessary. Supports a maximum resolution<br>
	 * 268435456 pixels total with a maximum width or height of 262144 pixels,<br>
	 * maximum 16-bit color channel depth, maximum 120 frames per second for<br>
	 * animation, maximum ICC color profile size of 4 MiB, it allows all color<br>
	 * models and extra channel types except CMYK and the JXL_CHANNEL_BLACK extra<br>
	 * channel, and a maximum of 4 extra channels in addition to the 3 color<br>
	 * channels. It also sets boundaries to certain internally used coding tools.<br>
	 * Level 10: this level removes or increases the bounds of most of the level<br>
	 * 5 limitations, allows CMYK color and up to 32 bits per color channel, but<br>
	 * may be less widely supported.<br>
	 * The default value is -1. This means the encoder will automatically choose<br>
	 * between level 5 and level 10 based on what information is inside the @ref<br>
	 * JxlBasicInfo structure. Do note that some level 10 features, particularly<br>
	 * those used by animated JPEG XL codestreams, might require level 10, even<br>
	 * though the @ref JxlBasicInfo only suggests level 5. In this case, the level<br>
	 * must be explicitly set to 10, otherwise the encoder will return an error.<br>
	 * The encoder will restrict internal encoding choices to those compatible with<br>
	 * the level setting.<br>
	 * This setting can only be set at the beginning, before encoding starts.<br>
	 * @param enc encoder object.<br>
	 * @param level the level value to set, must be -1, 5, or 10.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetCodestreamLevel(JxlEncoder*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:986</i>
	 */
	int JxlEncoderSetCodestreamLevel(PointerByReference enc, int level);
	/**
	 * Returns the codestream level required to support the currently configured<br>
	 * settings and basic info. This function can only be used at the beginning,<br>
	 * before encoding starts, but after setting basic info.<br>
	 * This does not support per-frame settings, only global configuration, such as<br>
	 * the image dimensions, that are known at the time of writing the header of<br>
	 * the JPEG XL file.<br>
	 * If this returns 5, nothing needs to be done and the codestream can be<br>
	 * compatible with any decoder. If this returns 10, JxlEncoderSetCodestreamLevel<br>
	 * has to be used to set the codestream level to 10, or the encoder can be<br>
	 * configured differently to allow using the more compatible level 5.<br>
	 * @param enc encoder object.<br>
	 * @return -1 if no level can support the configuration (e.g. image dimensions<br>
	 * larger than even level 10 supports), 5 if level 5 is supported, 10 if setting<br>
	 * the codestream level to 10 is required.<br>
	 * Original signature : <code>int JxlEncoderGetRequiredCodestreamLevel(const JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1008</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderGetRequiredCodestreamLevel(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlEncoderGetRequiredCodestreamLevel(Pointer enc);
	/**
	 * Returns the codestream level required to support the currently configured<br>
	 * settings and basic info. This function can only be used at the beginning,<br>
	 * before encoding starts, but after setting basic info.<br>
	 * This does not support per-frame settings, only global configuration, such as<br>
	 * the image dimensions, that are known at the time of writing the header of<br>
	 * the JPEG XL file.<br>
	 * If this returns 5, nothing needs to be done and the codestream can be<br>
	 * compatible with any decoder. If this returns 10, JxlEncoderSetCodestreamLevel<br>
	 * has to be used to set the codestream level to 10, or the encoder can be<br>
	 * configured differently to allow using the more compatible level 5.<br>
	 * @param enc encoder object.<br>
	 * @return -1 if no level can support the configuration (e.g. image dimensions<br>
	 * larger than even level 10 supports), 5 if level 5 is supported, 10 if setting<br>
	 * the codestream level to 10 is required.<br>
	 * Original signature : <code>int JxlEncoderGetRequiredCodestreamLevel(const JxlEncoder*)</code><br>
	 * <i>native declaration : jxl/encode.h:1008</i>
	 */
	int JxlEncoderGetRequiredCodestreamLevel(PointerByReference enc);
	/**
	 * Enables lossless encoding.<br>
	 * This is not an option like the others on itself, but rather while enabled it<br>
	 * overrides a set of existing options (such as distance, modular mode and<br>
	 * color transform) that enables bit-for-bit lossless encoding.<br>
	 * When disabled, those options are not overridden, but since those options<br>
	 * could still have been manually set to a combination that operates losslessly,<br>
	 * using this function with lossless set to JXL_DEC_FALSE does not guarantee<br>
	 * lossy encoding, though the default set of options is lossy.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param lossless whether to override options for lossless mode<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameLossless(JxlEncoderFrameSettings*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1028</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetFrameLossless(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderSetFrameLossless(Pointer frame_settings, int lossless);
	/**
	 * Enables lossless encoding.<br>
	 * This is not an option like the others on itself, but rather while enabled it<br>
	 * overrides a set of existing options (such as distance, modular mode and<br>
	 * color transform) that enables bit-for-bit lossless encoding.<br>
	 * When disabled, those options are not overridden, but since those options<br>
	 * could still have been manually set to a combination that operates losslessly,<br>
	 * using this function with lossless set to JXL_DEC_FALSE does not guarantee<br>
	 * lossy encoding, though the default set of options is lossy.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param lossless whether to override options for lossless mode<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameLossless(JxlEncoderFrameSettings*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1028</i>
	 */
	int JxlEncoderSetFrameLossless(PointerByReference frame_settings, int lossless);
	/**
	 * DEPRECATED: use JxlEncoderSetFrameLossless instead.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetLossless(JxlEncoderFrameSettings*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1033</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsSetLossless(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderOptionsSetLossless(Pointer JxlEncoderFrameSettingsPtr1, int int1);
	/**
	 * DEPRECATED: use JxlEncoderSetFrameLossless instead.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetLossless(JxlEncoderFrameSettings*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1033</i>
	 */
	int JxlEncoderOptionsSetLossless(PointerByReference JxlEncoderFrameSettingsPtr1, int int1);
	/**
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param effort the effort value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * DEPRECATED: use JxlEncoderFrameSettingsSetOption(frame_settings,<br>
	 * JXL_ENC_FRAME_SETTING_EFFORT, effort) instead.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetEffort(JxlEncoderFrameSettings*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1046</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsSetEffort(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderOptionsSetEffort(Pointer frame_settings, int effort);
	/**
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param effort the effort value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * DEPRECATED: use JxlEncoderFrameSettingsSetOption(frame_settings,<br>
	 * JXL_ENC_FRAME_SETTING_EFFORT, effort) instead.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetEffort(JxlEncoderFrameSettings*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1046</i>
	 */
	int JxlEncoderOptionsSetEffort(PointerByReference frame_settings, int effort);
	/**
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param tier the decoding speed tier to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * DEPRECATED: use JxlEncoderFrameSettingsSetOption(frame_settings,<br>
	 * JXL_ENC_FRAME_SETTING_DECODING_SPEED, tier) instead.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetDecodingSpeed(JxlEncoderFrameSettings*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1059</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsSetDecodingSpeed(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlEncoderOptionsSetDecodingSpeed(Pointer frame_settings, int tier);
	/**
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param tier the decoding speed tier to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * DEPRECATED: use JxlEncoderFrameSettingsSetOption(frame_settings,<br>
	 * JXL_ENC_FRAME_SETTING_DECODING_SPEED, tier) instead.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetDecodingSpeed(JxlEncoderFrameSettings*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1059</i>
	 */
	int JxlEncoderOptionsSetDecodingSpeed(PointerByReference frame_settings, int tier);
	/**
	 * Sets the distance level for lossy compression: target max butteraugli<br>
	 * distance, lower = higher quality. Range: 0 .. 15.<br>
	 * 0.0 = mathematically lossless (however, use JxlEncoderSetFrameLossless<br>
	 * instead to use true lossless, as setting distance to 0 alone is not the only<br>
	 * requirement). 1.0 = visually lossless. Recommended range: 0.5 .. 3.0. Default<br>
	 * value: 1.0.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param distance the distance value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameDistance(JxlEncoderFrameSettings*, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1076</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderSetFrameDistance(com.sun.jna.ptr.PointerByReference, float)} instead
	 */
	@Deprecated 
	int JxlEncoderSetFrameDistance(Pointer frame_settings, float distance);
	/**
	 * Sets the distance level for lossy compression: target max butteraugli<br>
	 * distance, lower = higher quality. Range: 0 .. 15.<br>
	 * 0.0 = mathematically lossless (however, use JxlEncoderSetFrameLossless<br>
	 * instead to use true lossless, as setting distance to 0 alone is not the only<br>
	 * requirement). 1.0 = visually lossless. Recommended range: 0.5 .. 3.0. Default<br>
	 * value: 1.0.<br>
	 * @param frame_settings set of options and metadata for this frame. Also<br>
	 * includes reference to the encoder object.<br>
	 * @param distance the distance value to set.<br>
	 * @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR<br>
	 * otherwise.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderSetFrameDistance(JxlEncoderFrameSettings*, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1076</i>
	 */
	int JxlEncoderSetFrameDistance(PointerByReference frame_settings, float distance);
	/**
	 * DEPRECATED: use JxlEncoderSetFrameDistance instead.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetDistance(JxlEncoderFrameSettings*, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1081</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsSetDistance(com.sun.jna.ptr.PointerByReference, float)} instead
	 */
	@Deprecated 
	int JxlEncoderOptionsSetDistance(Pointer JxlEncoderFrameSettingsPtr1, float float1);
	/**
	 * DEPRECATED: use JxlEncoderSetFrameDistance instead.<br>
	 * Original signature : <code>JxlEncoderStatus JxlEncoderOptionsSetDistance(JxlEncoderFrameSettings*, float)</code><br>
	 * <i>native declaration : jxl/encode.h:1081</i>
	 */
	int JxlEncoderOptionsSetDistance(PointerByReference JxlEncoderFrameSettingsPtr1, float float1);
	/**
	 * Create a new set of encoder options, with all values initially copied from<br>
	 * the @p source options, or set to default if @p source is NULL.<br>
	 * The returned pointer is an opaque struct tied to the encoder and it will be<br>
	 * deallocated by the encoder when JxlEncoderDestroy() is called. For functions<br>
	 * taking both a @ref JxlEncoder and a @ref JxlEncoderFrameSettings, only<br>
	 * JxlEncoderFrameSettings created with this function for the same encoder<br>
	 * instance can be used.<br>
	 * @param enc encoder object.<br>
	 * @param source source options to copy initial values from, or NULL to get<br>
	 * defaults initialized to defaults.<br>
	 * @return the opaque struct pointer identifying a new set of encoder options.<br>
	 * Original signature : <code>JxlEncoderFrameSettings* JxlEncoderFrameSettingsCreate(JxlEncoder*, const JxlEncoderFrameSettings*)</code><br>
	 * <i>native declaration : jxl/encode.h:1099</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderFrameSettingsCreate(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	PointerByReference JxlEncoderFrameSettingsCreate(Pointer enc, Pointer source);
	/**
	 * Create a new set of encoder options, with all values initially copied from<br>
	 * the @p source options, or set to default if @p source is NULL.<br>
	 * The returned pointer is an opaque struct tied to the encoder and it will be<br>
	 * deallocated by the encoder when JxlEncoderDestroy() is called. For functions<br>
	 * taking both a @ref JxlEncoder and a @ref JxlEncoderFrameSettings, only<br>
	 * JxlEncoderFrameSettings created with this function for the same encoder<br>
	 * instance can be used.<br>
	 * @param enc encoder object.<br>
	 * @param source source options to copy initial values from, or NULL to get<br>
	 * defaults initialized to defaults.<br>
	 * @return the opaque struct pointer identifying a new set of encoder options.<br>
	 * Original signature : <code>JxlEncoderFrameSettings* JxlEncoderFrameSettingsCreate(JxlEncoder*, const JxlEncoderFrameSettings*)</code><br>
	 * <i>native declaration : jxl/encode.h:1099</i>
	 */
	PointerByReference JxlEncoderFrameSettingsCreate(PointerByReference enc, PointerByReference source);
	/**
	 * DEPRECATED: use JxlEncoderFrameSettingsCreate instead.<br>
	 * Original signature : <code>JxlEncoderFrameSettings* JxlEncoderOptionsCreate(JxlEncoder*, const JxlEncoderFrameSettings*)</code><br>
	 * <i>native declaration : jxl/encode.h:1104</i><br>
	 * @deprecated use the safer method {@link #JxlEncoderOptionsCreate(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	PointerByReference JxlEncoderOptionsCreate(Pointer JxlEncoderPtr1, Pointer JxlEncoderFrameSettingsPtr1);
	/**
	 * DEPRECATED: use JxlEncoderFrameSettingsCreate instead.<br>
	 * Original signature : <code>JxlEncoderFrameSettings* JxlEncoderOptionsCreate(JxlEncoder*, const JxlEncoderFrameSettings*)</code><br>
	 * <i>native declaration : jxl/encode.h:1104</i>
	 */
	PointerByReference JxlEncoderOptionsCreate(PointerByReference JxlEncoderPtr1, PointerByReference JxlEncoderFrameSettingsPtr1);
	/**
	 * Sets a color encoding to be sRGB.<br>
	 * @param color_encoding color encoding instance.<br>
	 * @param is_gray whether the color encoding should be gray scale or color.<br>
	 * Original signature : <code>void JxlColorEncodingSetToSRGB(JxlColorEncoding*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1113</i>
	 */
	void JxlColorEncodingSetToSRGB(JxlColorEncoding color_encoding, int is_gray);
	/**
	 * Sets a color encoding to be linear sRGB.<br>
	 * @param color_encoding color encoding instance.<br>
	 * @param is_gray whether the color encoding should be gray scale or color.<br>
	 * Original signature : <code>void JxlColorEncodingSetToLinearSRGB(JxlColorEncoding*, int)</code><br>
	 * <i>native declaration : jxl/encode.h:1122</i>
	 */
	void JxlColorEncodingSetToLinearSRGB(JxlColorEncoding color_encoding, int is_gray);
	public static class JxlEncoder extends PointerType {
		public JxlEncoder(Pointer address) {
			super(address);
		}
		public JxlEncoder() {
			super();
		}
	};
	public static class JxlEncoderFrameSettings extends PointerType {
		public JxlEncoderFrameSettings(Pointer address) {
			super(address);
		}
		public JxlEncoderFrameSettings() {
			super();
		}
	};
}
