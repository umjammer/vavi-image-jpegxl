package vavi.awt.image.jna.jpegxl.decode;

import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import vavi.awt.image.jna.jpegxl.JxlBasicInfo;
import vavi.awt.image.jna.jpegxl.JxlColorEncoding;
import vavi.awt.image.jna.jpegxl.JxlExtraChannelInfo;
import vavi.awt.image.jna.jpegxl.JxlFrameHeader;
import vavi.awt.image.jna.jpegxl.JxlMemoryManagerStruct;
import vavi.awt.image.jna.jpegxl.JxlPixelFormat;
import vavi.awt.image.jna.jpegxl.Library.JxlParallelRunner;


/**
 * JNA Wrapper for library <b>decode</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface DecodeLibrary extends Library {
	String JNA_LIBRARY_NAME = "jxl";
	NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(DecodeLibrary.JNA_LIBRARY_NAME);
	DecodeLibrary INSTANCE = Native.load(DecodeLibrary.JNA_LIBRARY_NAME, DecodeLibrary.class);
	/**
	 * <i>native declaration : jxl/decode.h</i><br>
	 * enum values
	 */
	interface JxlSignature {
		/** <i>native declaration : jxl/decode.h:20</i> */
		int JXL_SIG_NOT_ENOUGH_BYTES = 0;
		/** <i>native declaration : jxl/decode.h:23</i> */
		int JXL_SIG_INVALID = 1;
		/** <i>native declaration : jxl/decode.h:28</i> */
		int JXL_SIG_CODESTREAM = 2;
		/** <i>native declaration : jxl/decode.h:33</i> */
		int JXL_SIG_CONTAINER = 3;
	}
	/**
	 * <i>native declaration : jxl/decode.h</i><br>
	 * enum values
	 */
	interface JxlDecoderStatus {
		/** <i>native declaration : jxl/decode.h:100</i> */
		int JXL_DEC_SUCCESS = 0;
		/** <i>native declaration : jxl/decode.h:105</i> */
		int JXL_DEC_ERROR = 1;
		/** <i>native declaration : jxl/decode.h:116</i> */
		int JXL_DEC_NEED_MORE_INPUT = 2;
		/** <i>native declaration : jxl/decode.h:124</i> */
		int JXL_DEC_NEED_PREVIEW_OUT_BUFFER = 3;
		/** <i>native declaration : jxl/decode.h:134</i> */
		int JXL_DEC_NEED_DC_OUT_BUFFER = 4;
		/** <i>native declaration : jxl/decode.h:141</i> */
		int JXL_DEC_NEED_IMAGE_OUT_BUFFER = 5;
		/** <i>native declaration : jxl/decode.h:149</i> */
		int JXL_DEC_JPEG_NEED_MORE_OUTPUT = 6;
		/** <i>native declaration : jxl/decode.h:154</i> */
		int JXL_DEC_BASIC_INFO = 0x40;
		/** <i>native declaration : jxl/decode.h:160</i> */
		int JXL_DEC_EXTENSIONS = 0x80;
		/** <i>native declaration : jxl/decode.h:167</i> */
		int JXL_DEC_COLOR_ENCODING = 0x100;
		/** <i>native declaration : jxl/decode.h:174</i> */
		int JXL_DEC_PREVIEW_IMAGE = 0x200;
		/** <i>native declaration : jxl/decode.h:187</i> */
		int JXL_DEC_FRAME = 0x400;
		/** <i>native declaration : jxl/decode.h:200</i> */
		int JXL_DEC_DC_IMAGE = 0x800;
		/** <i>native declaration : jxl/decode.h:208</i> */
		int JXL_DEC_FULL_IMAGE = 0x1000;
		/** <i>native declaration : jxl/decode.h:218</i> */
		int JXL_DEC_JPEG_RECONSTRUCTION = 0x2000;
	}
	/**
	 * <i>native declaration : jxl/decode.h</i><br>
	 * enum values
	 */
	interface JxlColorProfileTarget {
		/** <i>native declaration : jxl/decode.h:473</i> */
		int JXL_COLOR_PROFILE_TARGET_ORIGINAL = 0;
		/** <i>native declaration : jxl/decode.h:476</i> */
		int JXL_COLOR_PROFILE_TARGET_DATA = 1;
	}
	/** <i>native declaration : jxl/decode.h</i> */
	public interface JxlImageOutCallback extends Callback {
		void apply(Pointer opaque, int x, int y, int num_pixels, Pointer pixels);
	}
	/**
	 * Decoder library version.<br>
	 * @return the decoder library version as an integer:<br>
	 * MAJOR_VERSION * 1000000 + MINOR_VERSION * 1000 + PATCH_VERSION. For example,<br>
	 * version 1.2.3 would return 1002003.<br>
	 * Original signature : <code>uint32_t JxlDecoderVersion()</code><br>
	 * <i>native declaration : jxl/decode.h:13</i>
	 */
	int JxlDecoderVersion();
	/**
	 * JPEG XL signature identification.<br>
	 * Checks if the passed buffer contains a valid JPEG XL signature. The passed @p<br>
	 * buf of size<br>
	 * @p size doesn't need to be a full image, only the beginning of the file.<br>
	 * @return a flag indicating if a JPEG XL signature was found and what type.<br>
	 *   - JXL_SIG_NOT_ENOUGH_BYTES not enough bytes were passed to determine<br>
	 *       if a valid signature is there.<br>
	 *   - JXL_SIG_INVALID: no valid signature found for JPEG XL decoding.<br>
	 *   - JXL_SIG_CODESTREAM a valid JPEG XL codestream signature was found.<br>
	 *   - JXL_SIG_CONTAINER a valid JPEG XL container signature was found.<br>
	 * Original signature : <code>JxlSignature JxlSignatureCheck(const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:50</i><br>
	 * @deprecated use the safer methods {@link #JxlSignatureCheck(byte[], int)} and {@link #JxlSignatureCheck(com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlSignatureCheck(Pointer buf, int len);
	/**
	 * JPEG XL signature identification.<br>
	 * Checks if the passed buffer contains a valid JPEG XL signature. The passed @p<br>
	 * buf of size<br>
	 * @p size doesn't need to be a full image, only the beginning of the file.<br>
	 * @return a flag indicating if a JPEG XL signature was found and what type.<br>
	 *   - JXL_SIG_NOT_ENOUGH_BYTES not enough bytes were passed to determine<br>
	 *       if a valid signature is there.<br>
	 *   - JXL_SIG_INVALID: no valid signature found for JPEG XL decoding.<br>
	 *   - JXL_SIG_CODESTREAM a valid JPEG XL codestream signature was found.<br>
	 *   - JXL_SIG_CONTAINER a valid JPEG XL container signature was found.<br>
	 * Original signature : <code>JxlSignature JxlSignatureCheck(const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:50</i>
	 */
	int JxlSignatureCheck(byte[] buf, int len);
	/**
	 * Creates an instance of JxlDecoder and initializes it.<br>
	 * @p memory_manager will be used for all the library dynamic allocations made<br>
	 * from this instance. The parameter may be NULL, in which case the default<br>
	 * allocator will be used. See jpegxl/memory_manager.h for details.<br>
	 * @param memory_manager custom allocator function. It may be NULL. The memory<br>
	 *        manager will be copied internally.<br>
	 * @return @c NULL if the instance can not be allocated or initialized<br>
	 * return pointer to initialized JxlDecoder otherwise<br>
	 * Original signature : <code>JxlDecoder* JxlDecoderCreate(const JxlMemoryManager*)</code><br>
	 * <i>native declaration : jxl/decode.h:72</i>
	 */
	PointerByReference JxlDecoderCreate(JxlMemoryManagerStruct memory_manager);
	/**
	 * Re-initializes a JxlDecoder instance, so it can be re-used for decoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with JxlDecoderCreate, but the memory manager is kept.<br>
	 * @param dec instance to be re-initialized.<br>
	 * Original signature : <code>void JxlDecoderReset(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:81</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderReset(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlDecoderReset(Pointer dec);
	/**
	 * Re-initializes a JxlDecoder instance, so it can be re-used for decoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with JxlDecoderCreate, but the memory manager is kept.<br>
	 * @param dec instance to be re-initialized.<br>
	 * Original signature : <code>void JxlDecoderReset(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:81</i>
	 */
	void JxlDecoderReset(PointerByReference dec);
	/**
	 * Deinitializes and frees JxlDecoder instance.<br>
	 * @param dec instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlDecoderDestroy(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:88</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderDestroy(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlDecoderDestroy(Pointer dec);
	/**
	 * Deinitializes and frees JxlDecoder instance.<br>
	 * @param dec instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlDecoderDestroy(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:88</i>
	 */
	void JxlDecoderDestroy(PointerByReference dec);
	/**
	 * Rewinds decoder to the beginning. The same input must be given again from<br>
	 * the beginning of the file and the decoder will emit events from the beginning<br>
	 * again. When rewinding (as opposed to JxlDecoderReset), the decoder can keep<br>
	 * state about the image, which it can use to skip to a requested frame more<br>
	 * efficiently with JxlDecoderSkipFrames. After rewind,<br>
	 * JxlDecoderSubscribeEvents can be used again, and it is feasible to leave out<br>
	 * events that were already handled before, such as JXL_DEC_BASIC_INFO and<br>
	 * JXL_DEC_COLOR_ENCODING, since they will provide the same information as<br>
	 * before.<br>
	 * @param dec decoder object<br>
	 * Original signature : <code>void JxlDecoderRewind(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:232</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderRewind(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlDecoderRewind(Pointer dec);
	/**
	 * Rewinds decoder to the beginning. The same input must be given again from<br>
	 * the beginning of the file and the decoder will emit events from the beginning<br>
	 * again. When rewinding (as opposed to JxlDecoderReset), the decoder can keep<br>
	 * state about the image, which it can use to skip to a requested frame more<br>
	 * efficiently with JxlDecoderSkipFrames. After rewind,<br>
	 * JxlDecoderSubscribeEvents can be used again, and it is feasible to leave out<br>
	 * events that were already handled before, such as JXL_DEC_BASIC_INFO and<br>
	 * JXL_DEC_COLOR_ENCODING, since they will provide the same information as<br>
	 * before.<br>
	 * @param dec decoder object<br>
	 * Original signature : <code>void JxlDecoderRewind(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:232</i>
	 */
	void JxlDecoderRewind(PointerByReference dec);
	/**
	 * Makes the decoder skip the next `amount` frames. It still needs to process<br>
	 * the input, but will not output the frame events. It can be more efficient<br>
	 * when skipping frames, and even more so when using this after<br>
	 * JxlDecoderRewind. If the decoder is already processing a frame (could<br>
	 * have emitted JXL_DEC_FRAME but not yet JXL_DEC_FULL_IMAGE), it starts<br>
	 * skipping from the next frame. If the amount is larger than the amount of<br>
	 * frames remaining in the image, all remaining frames are skipped. Calling this<br>
	 * function multiple times adds the amount to skip to the already existing<br>
	 * amount.<br>
	 * A frame here is defined as a frame that without skipping emits events such as<br>
	 * JXL_DEC_FRAME and JXL_FULL_IMAGE, frames that are internal to the file format<br>
	 * but are not rendered as part of an animation, or are not the final still<br>
	 * frame of a still image, are not counted.<br>
	 * @param dec decoder object<br>
	 * @param amount the amount of frames to skip<br>
	 * Original signature : <code>void JxlDecoderSkipFrames(JxlDecoder*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:250</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSkipFrames(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	void JxlDecoderSkipFrames(Pointer dec, int amount);
	/**
	 * Makes the decoder skip the next `amount` frames. It still needs to process<br>
	 * the input, but will not output the frame events. It can be more efficient<br>
	 * when skipping frames, and even more so when using this after<br>
	 * JxlDecoderRewind. If the decoder is already processing a frame (could<br>
	 * have emitted JXL_DEC_FRAME but not yet JXL_DEC_FULL_IMAGE), it starts<br>
	 * skipping from the next frame. If the amount is larger than the amount of<br>
	 * frames remaining in the image, all remaining frames are skipped. Calling this<br>
	 * function multiple times adds the amount to skip to the already existing<br>
	 * amount.<br>
	 * A frame here is defined as a frame that without skipping emits events such as<br>
	 * JXL_DEC_FRAME and JXL_FULL_IMAGE, frames that are internal to the file format<br>
	 * but are not rendered as part of an animation, or are not the final still<br>
	 * frame of a still image, are not counted.<br>
	 * @param dec decoder object<br>
	 * @param amount the amount of frames to skip<br>
	 * Original signature : <code>void JxlDecoderSkipFrames(JxlDecoder*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:250</i>
	 */
	void JxlDecoderSkipFrames(PointerByReference dec, int amount);
	/**
	 * Get the default pixel format for this decoder.<br>
	 * Requires that the decoder can produce JxlBasicInfo.<br>
	 * @param dec JxlDecoder to query when creating the recommended pixel format.<br>
	 * @param format JxlPixelFormat to populate with the recommended settings for<br>
	 * the data loaded into this decoder.<br>
	 * @return JXL_DEC_SUCCESS if no error, JXL_DEC_NEED_MORE_INPUT if the<br>
	 * basic info isn't yet available, and JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderDefaultPixelFormat(const JxlDecoder*, JxlPixelFormat*)</code><br>
	 * <i>native declaration : jxl/decode.h:263</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderDefaultPixelFormat(com.sun.jna.ptr.PointerByReference, JxlPixelFormat)} instead
	 */
	@Deprecated 
	int JxlDecoderDefaultPixelFormat(Pointer dec, JxlPixelFormat format);
	/**
	 * Get the default pixel format for this decoder.<br>
	 * Requires that the decoder can produce JxlBasicInfo.<br>
	 * @param dec JxlDecoder to query when creating the recommended pixel format.<br>
	 * @param format JxlPixelFormat to populate with the recommended settings for<br>
	 * the data loaded into this decoder.<br>
	 * @return JXL_DEC_SUCCESS if no error, JXL_DEC_NEED_MORE_INPUT if the<br>
	 * basic info isn't yet available, and JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderDefaultPixelFormat(const JxlDecoder*, JxlPixelFormat*)</code><br>
	 * <i>native declaration : jxl/decode.h:263</i>
	 */
	int JxlDecoderDefaultPixelFormat(PointerByReference dec, JxlPixelFormat format);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * decoding.<br>
	 * @param dec decoder object<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *        be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *        runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return JXL_DEC_SUCCESS if the runner was set, JXL_DEC_ERROR<br>
	 * otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetParallelRunner(JxlDecoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:278</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetParallelRunner(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.Library.JxlParallelRunner, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlDecoderSetParallelRunner(Pointer dec, JxlParallelRunner parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * decoding.<br>
	 * @param dec decoder object<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *        be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *        runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return JXL_DEC_SUCCESS if the runner was set, JXL_DEC_ERROR<br>
	 * otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetParallelRunner(JxlDecoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:278</i>
	 */
	int JxlDecoderSetParallelRunner(PointerByReference dec, JxlParallelRunner parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * decoding.<br>
	 * @param dec decoder object<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *        be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *        runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return JXL_DEC_SUCCESS if the runner was set, JXL_DEC_ERROR<br>
	 * otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetParallelRunner(JxlDecoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:278</i>
	 */
	int JxlDecoderSetParallelRunner(PointerByReference dec, Pointer parallel_runner, Pointer parallel_runner_opaque);
	@Deprecated
	int JxlDecoderSetParallelRunner(Pointer dec, Pointer parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Returns a hint indicating how many more bytes the decoder is expected to<br>
	 * need to make JxlDecoderGetBasicInfo available after the next<br>
	 * JxlDecoderProcessInput call. This is a suggested large enough value for<br>
	 * the amount of bytes to provide in the next JxlDecoderSetInput call, but it is<br>
	 * not guaranteed to be an upper bound nor a lower bound.<br>
	 * Can be used before the first JxlDecoderProcessInput call, and is correct<br>
	 * the first time in most cases. If not, JxlDecoderSizeHintBasicInfo can be<br>
	 * called again to get an updated hint.<br>
	 * @param dec decoder object<br>
	 * @return the size hint in bytes if the basic info is not yet fully decoded.<br>
	 * return 0 when the basic info is already available.<br>
	 * Original signature : <code>size_t JxlDecoderSizeHintBasicInfo(const JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:296</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSizeHintBasicInfo(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderSizeHintBasicInfo(Pointer dec);
	/**
	 * Returns a hint indicating how many more bytes the decoder is expected to<br>
	 * need to make JxlDecoderGetBasicInfo available after the next<br>
	 * JxlDecoderProcessInput call. This is a suggested large enough value for<br>
	 * the amount of bytes to provide in the next JxlDecoderSetInput call, but it is<br>
	 * not guaranteed to be an upper bound nor a lower bound.<br>
	 * Can be used before the first JxlDecoderProcessInput call, and is correct<br>
	 * the first time in most cases. If not, JxlDecoderSizeHintBasicInfo can be<br>
	 * called again to get an updated hint.<br>
	 * @param dec decoder object<br>
	 * @return the size hint in bytes if the basic info is not yet fully decoded.<br>
	 * return 0 when the basic info is already available.<br>
	 * Original signature : <code>size_t JxlDecoderSizeHintBasicInfo(const JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:296</i>
	 */
	int JxlDecoderSizeHintBasicInfo(PointerByReference dec);
	/**
	 * Select for which informative events (JXL_DEC_BASIC_INFO, etc...) the<br>
	 * decoder should return with a status. It is not required to subscribe to any<br>
	 * events, data can still be requested from the decoder as soon as it available.<br>
	 * By default, the decoder is subscribed to no events (events_wanted == 0), and<br>
	 * the decoder will then only return when it cannot continue because it needs<br>
	 * more input data or more output buffer. This function may only be be called<br>
	 * before using JxlDecoderProcessInput<br>
	 * @param dec decoder object<br>
	 * @param events_wanted bitfield of desired events.<br>
	 * @return JXL_DEC_SUCCESS if no error, JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSubscribeEvents(JxlDecoder*, int)</code><br>
	 * <i>native declaration : jxl/decode.h:310</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSubscribeEvents(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSubscribeEvents(Pointer dec, int events_wanted);
	/**
	 * Select for which informative events (JXL_DEC_BASIC_INFO, etc...) the<br>
	 * decoder should return with a status. It is not required to subscribe to any<br>
	 * events, data can still be requested from the decoder as soon as it available.<br>
	 * By default, the decoder is subscribed to no events (events_wanted == 0), and<br>
	 * the decoder will then only return when it cannot continue because it needs<br>
	 * more input data or more output buffer. This function may only be be called<br>
	 * before using JxlDecoderProcessInput<br>
	 * @param dec decoder object<br>
	 * @param events_wanted bitfield of desired events.<br>
	 * @return JXL_DEC_SUCCESS if no error, JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSubscribeEvents(JxlDecoder*, int)</code><br>
	 * <i>native declaration : jxl/decode.h:310</i>
	 */
	int JxlDecoderSubscribeEvents(PointerByReference dec, int events_wanted);
	/**
	 * Enables or disables preserving of original orientation. Some images are<br>
	 * encoded with an orientation tag indicating the image is rotated and/or<br>
	 * mirrored (here called the original orientation).<br>
	 * *) If keep_orientation is JXL_FALSE (the default): the decoder will perform<br>
	 * work to undo the transformation. This ensures the decoded pixels will not<br>
	 * be rotated or mirrored. The decoder will always set the orientation field<br>
	 * of the JxlBasicInfo to JXL_ORIENT_IDENTITY to match the returned pixel data.<br>
	 * The decoder may also swap xsize and ysize in the JxlBasicInfo compared to the<br>
	 * values inside of the codestream, to correctly match the decoded pixel data,<br>
	 * e.g. when a 90 degree rotation was performed.<br>
	 * *) If this option is JXL_TRUE: then the image is returned as-is, which may be<br>
	 * rotated or mirrored, and the user must check the orientation field in<br>
	 * JxlBasicInfo after decoding to correctly interpret the decoded pixel data.<br>
	 * This may be faster to decode since the decoder doesn't have to apply the<br>
	 * transformation, but can cause wrong display of the image if the orientation<br>
	 * tag is not correctly taken into account by the user.<br>
	 * By default, this option is disabled, and the decoder automatically corrects<br>
	 * the orientation.<br>
	 * This function must be called at the beginning, before decoding is performed.<br>
	 * @see JxlBasicInfo for the orientation field, and @see JxlOrientation for the<br>
	 * possible values.<br>
	 * @param dec decoder object<br>
	 * @param keep_orientation JXL_TRUE to enable, JXL_FALSE to disable.<br>
	 * @return JXL_DEC_SUCCESS if no error, JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetKeepOrientation(JxlDecoder*, int)</code><br>
	 * <i>native declaration : jxl/decode.h:344</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetKeepOrientation(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetKeepOrientation(Pointer dec, int keep_orientation);
	/**
	 * Enables or disables preserving of original orientation. Some images are<br>
	 * encoded with an orientation tag indicating the image is rotated and/or<br>
	 * mirrored (here called the original orientation).<br>
	 * *) If keep_orientation is JXL_FALSE (the default): the decoder will perform<br>
	 * work to undo the transformation. This ensures the decoded pixels will not<br>
	 * be rotated or mirrored. The decoder will always set the orientation field<br>
	 * of the JxlBasicInfo to JXL_ORIENT_IDENTITY to match the returned pixel data.<br>
	 * The decoder may also swap xsize and ysize in the JxlBasicInfo compared to the<br>
	 * values inside of the codestream, to correctly match the decoded pixel data,<br>
	 * e.g. when a 90 degree rotation was performed.<br>
	 * *) If this option is JXL_TRUE: then the image is returned as-is, which may be<br>
	 * rotated or mirrored, and the user must check the orientation field in<br>
	 * JxlBasicInfo after decoding to correctly interpret the decoded pixel data.<br>
	 * This may be faster to decode since the decoder doesn't have to apply the<br>
	 * transformation, but can cause wrong display of the image if the orientation<br>
	 * tag is not correctly taken into account by the user.<br>
	 * By default, this option is disabled, and the decoder automatically corrects<br>
	 * the orientation.<br>
	 * This function must be called at the beginning, before decoding is performed.<br>
	 * @see JxlBasicInfo for the orientation field, and @see JxlOrientation for the<br>
	 * possible values.<br>
	 * @param dec decoder object<br>
	 * @param keep_orientation JXL_TRUE to enable, JXL_FALSE to disable.<br>
	 * @return JXL_DEC_SUCCESS if no error, JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetKeepOrientation(JxlDecoder*, int)</code><br>
	 * <i>native declaration : jxl/decode.h:344</i>
	 */
	int JxlDecoderSetKeepOrientation(PointerByReference dec, int keep_orientation);
	/**
	 * Decodes JPEG XL file using the available bytes. Requires input has been<br>
	 * set with JxlDecoderSetInput. After JxlDecoderProcessInput, input can<br>
	 * optionally be released with JxlDecoderReleaseInput and then set again to<br>
	 * next bytes in the stream. JxlDecoderReleaseInput returns how many bytes are<br>
	 * not yet processed, before a next call to JxlDecoderProcessInput all<br>
	 * unprocessed bytes must be provided again (the address need not match, but the<br>
	 * contents must), and more bytes may be concatenated after the unprocessed<br>
	 * bytes.<br>
	 * The returned status indicates whether the decoder needs more input bytes, or<br>
	 * more output buffer for a certain type of output data. No matter what the<br>
	 * returned status is (other than JXL_DEC_ERROR), new information, such as<br>
	 * JxlDecoderGetBasicInfo, may have become available after this call. When<br>
	 * the return value is not JXL_DEC_ERROR or JXL_DEC_SUCCESS, the decoding<br>
	 * requires more JxlDecoderProcessInput calls to continue.<br>
	 * @param dec decoder object<br>
	 * @return JXL_DEC_SUCCESS when decoding finished and all events handled.<br>
	 * return JXL_DEC_ERROR when decoding failed, e.g. invalid codestream.<br>
	 * TODO(lode) document the input data mechanism<br>
	 * return JXL_DEC_NEED_MORE_INPUT more input data is necessary.<br>
	 * return JXL_DEC_BASIC_INFO when basic info such as image dimensions is<br>
	 * available and this informative event is subscribed to.<br>
	 * return JXL_DEC_EXTENSIONS when JPEG XL codestream user extensions are<br>
	 * available and this informative event is subscribed to.<br>
	 * return JXL_DEC_COLOR_ENCODING when color profile information is<br>
	 * available and this informative event is subscribed to.<br>
	 * return JXL_DEC_PREVIEW_IMAGE when preview pixel information is available and<br>
	 * output in the preview buffer.<br>
	 * return JXL_DEC_DC_IMAGE when DC pixel information (8x8 downscaled version<br>
	 * of the image) is available and output in the DC buffer.<br>
	 * return JXL_DEC_FULL_IMAGE when all pixel information at highest detail is<br>
	 * available and has been output in the pixel buffer.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderProcessInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:382</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderProcessInput(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderProcessInput(Pointer dec);
	/**
	 * Decodes JPEG XL file using the available bytes. Requires input has been<br>
	 * set with JxlDecoderSetInput. After JxlDecoderProcessInput, input can<br>
	 * optionally be released with JxlDecoderReleaseInput and then set again to<br>
	 * next bytes in the stream. JxlDecoderReleaseInput returns how many bytes are<br>
	 * not yet processed, before a next call to JxlDecoderProcessInput all<br>
	 * unprocessed bytes must be provided again (the address need not match, but the<br>
	 * contents must), and more bytes may be concatenated after the unprocessed<br>
	 * bytes.<br>
	 * The returned status indicates whether the decoder needs more input bytes, or<br>
	 * more output buffer for a certain type of output data. No matter what the<br>
	 * returned status is (other than JXL_DEC_ERROR), new information, such as<br>
	 * JxlDecoderGetBasicInfo, may have become available after this call. When<br>
	 * the return value is not JXL_DEC_ERROR or JXL_DEC_SUCCESS, the decoding<br>
	 * requires more JxlDecoderProcessInput calls to continue.<br>
	 * @param dec decoder object<br>
	 * @return JXL_DEC_SUCCESS when decoding finished and all events handled.<br>
	 * @return JXL_DEC_ERROR when decoding failed, e.g. invalid codestream.<br>
	 * TODO(lode) document the input data mechanism<br>
	 * return JXL_DEC_NEED_MORE_INPUT more input data is necessary.<br>
	 * return JXL_DEC_BASIC_INFO when basic info such as image dimensions is<br>
	 * available and this informative event is subscribed to.<br>
	 * return JXL_DEC_EXTENSIONS when JPEG XL codestream user extensions are<br>
	 * available and this informative event is subscribed to.<br>
	 * return JXL_DEC_COLOR_ENCODING when color profile information is<br>
	 * available and this informative event is subscribed to.<br>
	 * return JXL_DEC_PREVIEW_IMAGE when preview pixel information is available and<br>
	 * output in the preview buffer.<br>
	 * return JXL_DEC_DC_IMAGE when DC pixel information (8x8 downscaled version<br>
	 * of the image) is available and output in the DC buffer.<br>
	 * return JXL_DEC_FULL_IMAGE when all pixel information at highest detail is<br>
	 * available and has been output in the pixel buffer.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderProcessInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:382</i>
	 */
	int JxlDecoderProcessInput(PointerByReference dec);
	/**
	 * Sets input data for JxlDecoderProcessInput. The data is owned by the caller<br>
	 * and may be used by the decoder until JxlDecoderReleaseInput is called or<br>
	 * the decoder is destroyed or reset so must be kept alive until then.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to read from<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return JXL_DEC_ERROR if input was already set without releasing,<br>
	 * JXL_DEC_SUCCESS otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetInput(JxlDecoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:394</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetInput(com.sun.jna.ptr.PointerByReference, byte[], long)}
	 * and {@link #JxlDecoderSetInput(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, long)} instead
	 */
	@Deprecated 
	int JxlDecoderSetInput(Pointer dec, Pointer data, int size);
	/**
	 * Sets input data for JxlDecoderProcessInput. The data is owned by the caller<br>
	 * and may be used by the decoder until JxlDecoderReleaseInput is called or<br>
	 * the decoder is destroyed or reset so must be kept alive until then.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to read from<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return JXL_DEC_ERROR if input was already set without releasing,<br>
	 * JXL_DEC_SUCCESS otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetInput(JxlDecoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:394</i>
	 */
	int JxlDecoderSetInput(PointerByReference dec, byte[] data, long size);
	/**
	 * Sets input data for JxlDecoderProcessInput. The data is owned by the caller<br>
	 * and may be used by the decoder until JxlDecoderReleaseInput is called or<br>
	 * the decoder is destroyed or reset so must be kept alive until then.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to read from<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return JXL_DEC_ERROR if input was already set without releasing,<br>
	 * JXL_DEC_SUCCESS otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetInput(JxlDecoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:394</i>
	 */
	int JxlDecoderSetInput(PointerByReference dec, Pointer data, long size);
	/**
	 * Releases input which was provided with JxlDecoderSetInput. Between<br>
	 * JxlDecoderProcessInput and JxlDecoderReleaseInput, the user may not alter<br>
	 * the data in the buffer. Calling JxlDecoderReleaseInput is required whenever<br>
	 * any input is already set and new input needs to be added with<br>
	 * JxlDecoderSetInput, but is not required before JxlDecoderDestroy or<br>
	 * JxlDecoderReset. Calling JxlDecoderReleaseInput when no input is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return the amount of bytes the decoder has not yet processed that are<br>
	 * still remaining in the data set by JxlDecoderSetInput, or 0 if no input is<br>
	 * set or JxlDecoderReleaseInput was already called. For a next call to<br>
	 * JxlDecoderProcessInput, the buffer must start with these unprocessed bytes.<br>
	 * This value doesn't provide information about how many bytes the decoder<br>
	 * truly processed internally or how large the original JPEG XL codestream or<br>
	 * file are.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:415</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderReleaseInput(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderReleaseInput(Pointer dec);
	/**
	 * Releases input which was provided with JxlDecoderSetInput. Between<br>
	 * JxlDecoderProcessInput and JxlDecoderReleaseInput, the user may not alter<br>
	 * the data in the buffer. Calling JxlDecoderReleaseInput is required whenever<br>
	 * any input is already set and new input needs to be added with<br>
	 * JxlDecoderSetInput, but is not required before JxlDecoderDestroy or<br>
	 * JxlDecoderReset. Calling JxlDecoderReleaseInput when no input is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return the amount of bytes the decoder has not yet processed that are<br>
	 * still remaining in the data set by JxlDecoderSetInput, or 0 if no input is<br>
	 * set or JxlDecoderReleaseInput was already called. For a next call to<br>
	 * JxlDecoderProcessInput, the buffer must start with these unprocessed bytes.<br>
	 * This value doesn't provide information about how many bytes the decoder<br>
	 * truly processed internally or how large the original JPEG XL codestream or<br>
	 * file are.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:415</i>
	 */
	int JxlDecoderReleaseInput(PointerByReference dec);
	/**
	 * Outputs the basic image information, such as image dimensions, bit depth and<br>
	 * all other JxlBasicInfo fields, if available.<br>
	 * @param dec decoder object<br>
	 * @param info struct to copy the information into, or NULL to only check<br>
	 * whether the information is available through the return value.<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetBasicInfo(const JxlDecoder*, JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:428</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetBasicInfo(com.sun.jna.ptr.PointerByReference, JxlBasicInfo)} instead
	 */
	@Deprecated 
	int JxlDecoderGetBasicInfo(Pointer dec, JxlBasicInfo info);
	/**
	 * Outputs the basic image information, such as image dimensions, bit depth and<br>
	 * all other JxlBasicInfo fields, if available.<br>
	 * @param dec decoder object<br>
	 * @param info struct to copy the information into, or NULL to only check<br>
	 * whether the information is available through the return value.<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetBasicInfo(const JxlDecoder*, JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:428</i>
	 */
	int JxlDecoderGetBasicInfo(PointerByReference dec, JxlBasicInfo info);
	/**
	 * Outputs information for extra channel at the given index. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param info struct to copy the information into, or NULL to only check<br>
	 * whether the information is available through the return value.<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelInfo(const JxlDecoder*, size_t, JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:443</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetExtraChannelInfo(com.sun.jna.ptr.PointerByReference, int, JxlExtraChannelInfo)} instead
	 */
	@Deprecated 
	int JxlDecoderGetExtraChannelInfo(Pointer dec, int index, JxlExtraChannelInfo info);
	/**
	 * Outputs information for extra channel at the given index. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param info struct to copy the information into, or NULL to only check<br>
	 * whether the information is available through the return value.<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelInfo(const JxlDecoder*, size_t, JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:443</i>
	 */
	int JxlDecoderGetExtraChannelInfo(PointerByReference dec, int index, JxlExtraChannelInfo info);
	/**
	 * Outputs name for extra channel at the given index in UTF-8. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo. The buffer<br>
	 * for name must have at least name_length + 1 bytes allocated, gotten from<br>
	 * the associated JxlExtraChannelInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelName(const JxlDecoder*, size_t, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:460</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderGetExtraChannelName(com.sun.jna.ptr.PointerByReference, int, java.nio.ByteBuffer, int)} and {@link #JxlDecoderGetExtraChannelName(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlDecoderGetExtraChannelName(Pointer dec, int index, Pointer name, int size);
	/**
	 * Outputs name for extra channel at the given index in UTF-8. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo. The buffer<br>
	 * for name must have at least name_length + 1 bytes allocated, gotten from<br>
	 * the associated JxlExtraChannelInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelName(const JxlDecoder*, size_t, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:460</i>
	 */
	int JxlDecoderGetExtraChannelName(PointerByReference dec, int index, ByteBuffer name, int size);
	/**
	 * Outputs name for extra channel at the given index in UTF-8. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo. The buffer<br>
	 * for name must have at least name_length + 1 bytes allocated, gotten from<br>
	 * the associated JxlExtraChannelInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelName(const JxlDecoder*, size_t, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:460</i>
	 */
	int JxlDecoderGetExtraChannelName(PointerByReference dec, int index, Pointer name, int size);
	/**
	 * Outputs the color profile as JPEG XL encoded structured data, if available.<br>
	 * This is an alternative to an ICC Profile, which can represent a more limited<br>
	 * amount of color spaces, but represents them exactly through enum values.<br>
	 * It is often possible to use JxlDecoderGetColorAsICCProfile as an<br>
	 * alternative anyway. The following scenarios are possible:<br>
	 * - The JPEG XL image has an attached ICC Profile, in that case, the encoded<br>
	 *   structured data is not available, this function will return an error status<br>
	 *   and you must use JxlDecoderGetColorAsICCProfile instead.<br>
	 * - The JPEG XL image has an encoded structured color profile, and it<br>
	 *   represents an RGB or grayscale color space. This function will return it.<br>
	 *   You can still use JxlDecoderGetColorAsICCProfile as well as an<br>
	 *   alternative if desired, though depending on which RGB color space is<br>
	 *   represented, the ICC profile may be a close approximation. It is also not<br>
	 *   always feasible to deduce from an ICC profile which named color space it<br>
	 *   exactly represents, if any, as it can represent any arbitrary space.<br>
	 * - The JPEG XL image has an encoded structured color profile, and it indicates<br>
	 *   an unknown or xyb color space. In that case,<br>
	 *   JxlDecoderGetColorAsICCProfile is not available.<br>
	 * If you wish to render the image using a system that supports ICC profiles,<br>
	 * use JxlDecoderGetColorAsICCProfile first. If you're looking for a specific<br>
	 * color space possibly indicated in the JPEG XL image, use<br>
	 * JxlDecoderGetColorAsEncodedProfile first.<br>
	 * @param dec decoder object<br>
	 * @param format pixel format to output the data to. Only used for<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA, may be nullptr otherwise.<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param color_encoding struct to copy the information into, or NULL to only<br>
	 * check whether the information is available through the return value.<br>
	 * @return JXL_DEC_SUCCESS if the data is available and returned,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    the encoded structured color profile does not exist in the codestream.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsEncodedProfile(const JxlDecoder*, const JxlPixelFormat*, JxlColorProfileTarget, JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/decode.h:516</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetColorAsEncodedProfile(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, int, JxlColorEncoding)} instead
	 */
	@Deprecated 
	int JxlDecoderGetColorAsEncodedProfile(Pointer dec, JxlPixelFormat format, int target, JxlColorEncoding color_encoding);
	/**
	 * Outputs the color profile as JPEG XL encoded structured data, if available.<br>
	 * This is an alternative to an ICC Profile, which can represent a more limited<br>
	 * amount of color spaces, but represents them exactly through enum values.<br>
	 * It is often possible to use JxlDecoderGetColorAsICCProfile as an<br>
	 * alternative anyway. The following scenarios are possible:<br>
	 * - The JPEG XL image has an attached ICC Profile, in that case, the encoded<br>
	 *   structured data is not available, this function will return an error status<br>
	 *   and you must use JxlDecoderGetColorAsICCProfile instead.<br>
	 * - The JPEG XL image has an encoded structured color profile, and it<br>
	 *   represents an RGB or grayscale color space. This function will return it.<br>
	 *   You can still use JxlDecoderGetColorAsICCProfile as well as an<br>
	 *   alternative if desired, though depending on which RGB color space is<br>
	 *   represented, the ICC profile may be a close approximation. It is also not<br>
	 *   always feasible to deduce from an ICC profile which named color space it<br>
	 *   exactly represents, if any, as it can represent any arbitrary space.<br>
	 * - The JPEG XL image has an encoded structured color profile, and it indicates<br>
	 *   an unknown or xyb color space. In that case,<br>
	 *   JxlDecoderGetColorAsICCProfile is not available.<br>
	 * If you wish to render the image using a system that supports ICC profiles,<br>
	 * use JxlDecoderGetColorAsICCProfile first. If you're looking for a specific<br>
	 * color space possibly indicated in the JPEG XL image, use<br>
	 * JxlDecoderGetColorAsEncodedProfile first.<br>
	 * @param dec decoder object<br>
	 * @param format pixel format to output the data to. Only used for<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA, may be nullptr otherwise.<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param color_encoding struct to copy the information into, or NULL to only<br>
	 * check whether the information is available through the return value.<br>
	 * @return JXL_DEC_SUCCESS if the data is available and returned,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    the encoded structured color profile does not exist in the codestream.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsEncodedProfile(const JxlDecoder*, const JxlPixelFormat*, JxlColorProfileTarget, JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/decode.h:516</i>
	 */
	int JxlDecoderGetColorAsEncodedProfile(PointerByReference dec, JxlPixelFormat format, int target, JxlColorEncoding color_encoding);
	/**
	 * Outputs the size in bytes of the ICC profile returned by<br>
	 * JxlDecoderGetColorAsICCProfile, if available, or indicates there is none<br>
	 * available. In most cases, the image will have an ICC profile available, but<br>
	 * if it does not, JxlDecoderGetColorAsEncodedProfile must be used instead.<br>
	 * @see #JxlDecoderGetColorAsEncodedProfile for more information. The ICC<br>
	 * profile is either the exact ICC profile attached to the codestream metadata,<br>
	 * or a close approximation generated from JPEG XL encoded structured data,<br>
	 * depending of what is encoded in the codestream.<br>
	 * @param dec decoder object<br>
	 * @param format pixel format to output the data to. Only used for<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA, may be nullptr otherwise.<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param size variable to output the size into, or NULL to only check the<br>
	 *    return status.<br>
	 * @return JXL_DEC_SUCCESS if the ICC profile is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if the decoder has not yet received enough<br>
	 *    input data to determine whether an ICC profile is available or what its<br>
	 *    size is, JXL_DEC_ERROR in case the ICC profile is not available and<br>
	 *    cannot be generated.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetICCProfileSize(const JxlDecoder*, const JxlPixelFormat*, JxlColorProfileTarget, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:543</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetICCProfileSize(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, int, LongByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderGetICCProfileSize(Pointer dec, JxlPixelFormat format, int target, LongByReference size);
	/**
	 * Outputs the size in bytes of the ICC profile returned by<br>
	 * JxlDecoderGetColorAsICCProfile, if available, or indicates there is none<br>
	 * available. In most cases, the image will have an ICC profile available, but<br>
	 * if it does not, JxlDecoderGetColorAsEncodedProfile must be used instead.<br>
	 * @see #JxlDecoderGetColorAsEncodedProfile for more information. The ICC<br>
	 * profile is either the exact ICC profile attached to the codestream metadata,<br>
	 * or a close approximation generated from JPEG XL encoded structured data,<br>
	 * depending of what is encoded in the codestream.<br>
	 * @param dec decoder object<br>
	 * @param format pixel format to output the data to. Only used for<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA, may be nullptr otherwise.<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param size variable to output the size into, or NULL to only check the<br>
	 *    return status.<br>
	 * @return JXL_DEC_SUCCESS if the ICC profile is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if the decoder has not yet received enough<br>
	 *    input data to determine whether an ICC profile is available or what its<br>
	 *    size is, JXL_DEC_ERROR in case the ICC profile is not available and<br>
	 *    cannot be generated.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetICCProfileSize(const JxlDecoder*, const JxlPixelFormat*, JxlColorProfileTarget, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:543</i>
	 */
	int JxlDecoderGetICCProfileSize(PointerByReference dec, JxlPixelFormat format, int target, LongByReference size);
	/**
	 * Outputs ICC profile if available. The profile is only available if<br>
	 * JxlDecoderGetICCProfileSize returns success. The output buffer must have<br>
	 * at least as many bytes as given by JxlDecoderGetICCProfileSize.<br>
	 * @param dec decoder object<br>
	 * @param format pixel format to output the data to. Only used for<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA, may be nullptr otherwise.<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param icc_profile buffer to copy the ICC profile into<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS if the profile was successfully returned is<br>
	 *    available, JXL_DEC_NEED_MORE_INPUT if not yet available,<br>
	 *    JXL_DEC_ERROR if the profile doesn't exist or the output size is not<br>
	 *    large enough.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsICCProfile(const JxlDecoder*, const JxlPixelFormat*, JxlColorProfileTarget, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:564</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderGetColorAsICCProfile(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, int, java.nio.ByteBuffer, int)} and {@link #JxlDecoderGetColorAsICCProfile(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlDecoderGetColorAsICCProfile(Pointer dec, JxlPixelFormat format, int target, Pointer icc_profile, int size);
	/**
	 * Outputs ICC profile if available. The profile is only available if<br>
	 * JxlDecoderGetICCProfileSize returns success. The output buffer must have<br>
	 * at least as many bytes as given by JxlDecoderGetICCProfileSize.<br>
	 * @param dec decoder object<br>
	 * @param format pixel format to output the data to. Only used for<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA, may be nullptr otherwise.<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param icc_profile buffer to copy the ICC profile into<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS if the profile was successfully returned is<br>
	 *    available, JXL_DEC_NEED_MORE_INPUT if not yet available,<br>
	 *    JXL_DEC_ERROR if the profile doesn't exist or the output size is not<br>
	 *    large enough.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsICCProfile(const JxlDecoder*, const JxlPixelFormat*, JxlColorProfileTarget, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:564</i>
	 */
	int JxlDecoderGetColorAsICCProfile(PointerByReference dec, JxlPixelFormat format, int target, ByteBuffer icc_profile, int size);
	/**
	 * Outputs ICC profile if available. The profile is only available if<br>
	 * JxlDecoderGetICCProfileSize returns success. The output buffer must have<br>
	 * at least as many bytes as given by JxlDecoderGetICCProfileSize.<br>
	 * @param dec decoder object<br>
	 * @param format pixel format to output the data to. Only used for<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA, may be nullptr otherwise.<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param icc_profile buffer to copy the ICC profile into<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS if the profile was successfully returned is<br>
	 *    available, JXL_DEC_NEED_MORE_INPUT if not yet available,<br>
	 *    JXL_DEC_ERROR if the profile doesn't exist or the output size is not<br>
	 *    large enough.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsICCProfile(const JxlDecoder*, const JxlPixelFormat*, JxlColorProfileTarget, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:564</i>
	 */
	int JxlDecoderGetColorAsICCProfile(PointerByReference dec, JxlPixelFormat format, int target, Pointer icc_profile, int size);
	/**
	 * Sets the color profile to use for JXL_COLOR_PROFILE_TARGET_DATA for the<br>
	 * special case when the decoder has a choice. This only has effect for a JXL<br>
	 * image where uses_original_profile is false, and the original color profile is<br>
	 * encoded as an ICC color profile rather than a JxlColorEncoding with known<br>
	 * enum values. In most other cases (uses uses_original_profile is true, or the<br>
	 * color profile is already given as a JxlColorEncoding), this setting is<br>
	 * ignored and the decoder uses a profile related to the image.<br>
	 * No matter what, the JXL_COLOR_PROFILE_TARGET_DATA must still be queried to<br>
	 * know the actual data format of the decoded pixels after decoding.<br>
	 * The intended use case of this function is for cases where you are using<br>
	 * a color management system to parse the original ICC color profile<br>
	 * (JXL_COLOR_PROFILE_TARGET_ORIGINAL), from this you know that the ICC<br>
	 * profile represents one of the color profiles supported by JxlColorEncoding<br>
	 * (such as sRGB, PQ or HLG): in that case it is beneficial (but not necessary)<br>
	 * to use JxlDecoderSetPreferredColorProfile to match the parsed profile. The<br>
	 * JXL decoder has no color management system built in, but can convert XYB<br>
	 * color to any of the ones supported by JxlColorEncoding.<br>
	 * Can only be set after the JXL_DEC_COLOR_ENCODING event occurred and before<br>
	 * any other event occurred, and can affect the result of<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA (but not of JXL_COLOR_PROFILE_TARGET_ORIGINAL),<br>
	 * so should be used after getting JXL_COLOR_PROFILE_TARGET_ORIGINAL but before<br>
	 * getting JXL_COLOR_PROFILE_TARGET_DATA. The color_encoding must be grayscale<br>
	 * if num_color_channels from the basic info is 1, RGB if num_color_channels<br>
	 * from the basic info is 3.<br>
	 * If JxlDecoderSetPreferredColorProfile is not used, then for images for which<br>
	 * uses_original_profile is false and with ICC color profile, the decoder will<br>
	 * choose linear sRGB for color images, linear grayscale for grayscale images.<br>
	 * This function only sets a preference, since for other images the decoder has<br>
	 * no choice what color profile to use, it is determined by the image.<br>
	 * @param dec decoder object<br>
	 * @param color_encoding the default color encoding to set<br>
	 * @return JXL_DEC_SUCCESS if the preference was set successfully, JXL_DEC_ERROR<br>
	 *    otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreferredColorProfile(JxlDecoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/decode.h:606</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetPreferredColorProfile(com.sun.jna.ptr.PointerByReference, JxlColorEncoding)} instead
	 */
	@Deprecated 
	int JxlDecoderSetPreferredColorProfile(Pointer dec, JxlColorEncoding color_encoding);
	/**
	 * Sets the color profile to use for JXL_COLOR_PROFILE_TARGET_DATA for the<br>
	 * special case when the decoder has a choice. This only has effect for a JXL<br>
	 * image where uses_original_profile is false, and the original color profile is<br>
	 * encoded as an ICC color profile rather than a JxlColorEncoding with known<br>
	 * enum values. In most other cases (uses uses_original_profile is true, or the<br>
	 * color profile is already given as a JxlColorEncoding), this setting is<br>
	 * ignored and the decoder uses a profile related to the image.<br>
	 * No matter what, the JXL_COLOR_PROFILE_TARGET_DATA must still be queried to<br>
	 * know the actual data format of the decoded pixels after decoding.<br>
	 * The intended use case of this function is for cases where you are using<br>
	 * a color management system to parse the original ICC color profile<br>
	 * (JXL_COLOR_PROFILE_TARGET_ORIGINAL), from this you know that the ICC<br>
	 * profile represents one of the color profiles supported by JxlColorEncoding<br>
	 * (such as sRGB, PQ or HLG): in that case it is beneficial (but not necessary)<br>
	 * to use JxlDecoderSetPreferredColorProfile to match the parsed profile. The<br>
	 * JXL decoder has no color management system built in, but can convert XYB<br>
	 * color to any of the ones supported by JxlColorEncoding.<br>
	 * Can only be set after the JXL_DEC_COLOR_ENCODING event occurred and before<br>
	 * any other event occurred, and can affect the result of<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA (but not of JXL_COLOR_PROFILE_TARGET_ORIGINAL),<br>
	 * so should be used after getting JXL_COLOR_PROFILE_TARGET_ORIGINAL but before<br>
	 * getting JXL_COLOR_PROFILE_TARGET_DATA. The color_encoding must be grayscale<br>
	 * if num_color_channels from the basic info is 1, RGB if num_color_channels<br>
	 * from the basic info is 3.<br>
	 * If JxlDecoderSetPreferredColorProfile is not used, then for images for which<br>
	 * uses_original_profile is false and with ICC color profile, the decoder will<br>
	 * choose linear sRGB for color images, linear grayscale for grayscale images.<br>
	 * This function only sets a preference, since for other images the decoder has<br>
	 * no choice what color profile to use, it is determined by the image.<br>
	 * @param dec decoder object<br>
	 * @param color_encoding the default color encoding to set<br>
	 * @return JXL_DEC_SUCCESS if the preference was set successfully, JXL_DEC_ERROR<br>
	 *    otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreferredColorProfile(JxlDecoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/decode.h:606</i>
	 */
	int JxlDecoderSetPreferredColorProfile(PointerByReference dec, JxlColorEncoding color_encoding);
	/**
	 * Returns the minimum size in bytes of the preview image output pixel buffer<br>
	 * for the given format. This is the buffer for JxlDecoderSetPreviewOutBuffer.<br>
	 * Requires the preview header information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 *    information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderPreviewOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:620</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderPreviewOutBufferSize(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, LongByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderPreviewOutBufferSize(Pointer dec, JxlPixelFormat format, LongByReference size);
	/**
	 * Returns the minimum size in bytes of the preview image output pixel buffer<br>
	 * for the given format. This is the buffer for JxlDecoderSetPreviewOutBuffer.<br>
	 * Requires the preview header information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 *    information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderPreviewOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:620</i>
	 */
	int JxlDecoderPreviewOutBufferSize(PointerByReference dec, JxlPixelFormat format, LongByReference size);
	/**
	 * Sets the buffer to write the small resolution preview image<br>
	 * to. The size of the buffer must be at least as large as given by<br>
	 * JxlDecoderPreviewOutBufferSize. The buffer follows the format described by<br>
	 * JxlPixelFormat. The preview image dimensions are given by the<br>
	 * JxlPreviewHeader. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels. Object owned by user and its contents are<br>
	 * copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreviewOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:638</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetPreviewOutBuffer(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetPreviewOutBuffer(Pointer dec, JxlPixelFormat format, Pointer buffer, int size);
	/**
	 * Sets the buffer to write the small resolution preview image<br>
	 * to. The size of the buffer must be at least as large as given by<br>
	 * JxlDecoderPreviewOutBufferSize. The buffer follows the format described by<br>
	 * JxlPixelFormat. The preview image dimensions are given by the<br>
	 * JxlPreviewHeader. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels. Object owned by user and its contents are<br>
	 * copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreviewOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:638</i>
	 */
	int JxlDecoderSetPreviewOutBuffer(PointerByReference dec, JxlPixelFormat format, Pointer buffer, int size);
	/**
	 * Outputs the information from the frame, such as duration when have_animation.<br>
	 * This function can be called when JXL_DEC_FRAME occurred for the current<br>
	 * frame, even when have_animation in the JxlBasicInfo is JXL_FALSE.<br>
	 * @param dec decoder object<br>
	 * @param header struct to copy the information into, or NULL to only check<br>
	 * whether the information is available through the return value.<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameHeader(const JxlDecoder*, JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/decode.h:653</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetFrameHeader(com.sun.jna.ptr.PointerByReference, JxlFrameHeader)} instead
	 */
	@Deprecated 
	int JxlDecoderGetFrameHeader(Pointer dec, JxlFrameHeader header);
	/**
	 * Outputs the information from the frame, such as duration when have_animation.<br>
	 * This function can be called when JXL_DEC_FRAME occurred for the current<br>
	 * frame, even when have_animation in the JxlBasicInfo is JXL_FALSE.<br>
	 * @param dec decoder object<br>
	 * @param header struct to copy the information into, or NULL to only check<br>
	 * whether the information is available through the return value.<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameHeader(const JxlDecoder*, JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/decode.h:653</i>
	 */
	int JxlDecoderGetFrameHeader(PointerByReference dec, JxlFrameHeader header);
	/**
	 * Outputs name for the current frame. The buffer<br>
	 * for name must have at least name_length + 1 bytes allocated, gotten from<br>
	 * the associated JxlFrameHeader.<br>
	 * @param dec decoder object<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes, including zero termination<br>
	 *    character, so this must be at least JxlFrameHeader.name_length + 1.<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameName(const JxlDecoder*, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:669</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderGetFrameName(com.sun.jna.ptr.PointerByReference, java.nio.ByteBuffer, int)} and {@link #JxlDecoderGetFrameName(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlDecoderGetFrameName(Pointer dec, Pointer name, int size);
	/**
	 * Outputs name for the current frame. The buffer<br>
	 * for name must have at least name_length + 1 bytes allocated, gotten from<br>
	 * the associated JxlFrameHeader.<br>
	 * @param dec decoder object<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes, including zero termination<br>
	 *    character, so this must be at least JxlFrameHeader.name_length + 1.<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameName(const JxlDecoder*, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:669</i>
	 */
	int JxlDecoderGetFrameName(PointerByReference dec, ByteBuffer name, int size);
	/**
	 * Outputs name for the current frame. The buffer<br>
	 * for name must have at least name_length + 1 bytes allocated, gotten from<br>
	 * the associated JxlFrameHeader.<br>
	 * @param dec decoder object<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes, including zero termination<br>
	 *    character, so this must be at least JxlFrameHeader.name_length + 1.<br>
	 * @return JXL_DEC_SUCCESS if the value is available,<br>
	 *    JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case<br>
	 *    of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameName(const JxlDecoder*, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:669</i>
	 */
	int JxlDecoderGetFrameName(PointerByReference dec, Pointer name, int size);
	/**
	 * Returns the minimum size in bytes of the DC image output buffer<br>
	 * for the given format. This is the buffer for JxlDecoderSetDCOutBuffer.<br>
	 * Requires the basic image information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 *    information not available yet.<br>
	 * DEPRECATED: the DC feature in this form will be removed. You can use<br>
	 * JxlDecoderFlushImage for progressive rendering.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderDCOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:686</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderDCOutBufferSize(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, LongByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderDCOutBufferSize(Pointer dec, JxlPixelFormat format, LongByReference size);
	/**
	 * Returns the minimum size in bytes of the DC image output buffer<br>
	 * for the given format. This is the buffer for JxlDecoderSetDCOutBuffer.<br>
	 * Requires the basic image information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 *    information not available yet.<br>
	 * DEPRECATED: the DC feature in this form will be removed. You can use<br>
	 * JxlDecoderFlushImage for progressive rendering.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderDCOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:686</i>
	 */
	int JxlDecoderDCOutBufferSize(PointerByReference dec, JxlPixelFormat format, LongByReference size);
	/**
	 * Sets the buffer to write the lower resolution (8x8 sub-sampled) DC image<br>
	 * to. The size of the buffer must be at least as large as given by<br>
	 * JxlDecoderDCOutBufferSize. The buffer follows the format described by<br>
	 * JxlPixelFormat. The DC image has dimensions ceil(xsize / 8) * ceil(ysize /<br>
	 * 8). The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels. Object owned by user and its contents are<br>
	 * copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * size too small.<br>
	 * DEPRECATED: the DC feature in this form will be removed. You can use<br>
	 * JxlDecoderFlushImage for progressive rendering.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetDCOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:707</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetDCOutBuffer(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetDCOutBuffer(Pointer dec, JxlPixelFormat format, Pointer buffer, int size);
	/**
	 * Sets the buffer to write the lower resolution (8x8 sub-sampled) DC image<br>
	 * to. The size of the buffer must be at least as large as given by<br>
	 * JxlDecoderDCOutBufferSize. The buffer follows the format described by<br>
	 * JxlPixelFormat. The DC image has dimensions ceil(xsize / 8) * ceil(ysize /<br>
	 * 8). The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels. Object owned by user and its contents are<br>
	 * copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * size too small.<br>
	 * DEPRECATED: the DC feature in this form will be removed. You can use<br>
	 * JxlDecoderFlushImage for progressive rendering.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetDCOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:707</i>
	 */
	int JxlDecoderSetDCOutBuffer(PointerByReference dec, JxlPixelFormat format, Pointer buffer, int size);
	/**
	 * Returns the minimum size in bytes of the image output pixel buffer for the<br>
	 * given format. This is the buffer for JxlDecoderSetImageOutBuffer. Requires<br>
	 * the basic image information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 *    information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderImageOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:721</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderImageOutBufferSize(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, LongByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderImageOutBufferSize(Pointer dec, JxlPixelFormat format, LongByReference size);
	/**
	 * Returns the minimum size in bytes of the image output pixel buffer for the<br>
	 * given format. This is the buffer for JxlDecoderSetImageOutBuffer. Requires<br>
	 * the basic image information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 *    information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderImageOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:721</i>
	 */
	int JxlDecoderImageOutBufferSize(PointerByReference dec, JxlPixelFormat format, LongByReference size);
	/**
	 * Sets the buffer to write the full resolution image to. This can be set when<br>
	 * the JXL_DEC_FRAME event occurs, must be set when the<br>
	 * JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and applies only for the current<br>
	 * frame. The size of the buffer must be at least as large as given by<br>
	 * JxlDecoderImageOutBufferSize. The buffer follows the format described by<br>
	 * JxlPixelFormat. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 * are copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:740</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetImageOutBuffer(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, com.sun.jna.Pointer, long)} instead
	 */
	@Deprecated 
	int JxlDecoderSetImageOutBuffer(Pointer dec, JxlPixelFormat format, Pointer buffer, int size);
	/**
	 * Sets the buffer to write the full resolution image to. This can be set when<br>
	 * the JXL_DEC_FRAME event occurs, must be set when the<br>
	 * JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and applies only for the current<br>
	 * frame. The size of the buffer must be at least as large as given by<br>
	 * JxlDecoderImageOutBufferSize. The buffer follows the format described by<br>
	 * JxlPixelFormat. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 * are copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:740</i>
	 */
	int JxlDecoderSetImageOutBuffer(PointerByReference dec, JxlPixelFormat format, Pointer buffer, long size);
	/**
	 * Sets pixel output callback. This is an alternative to<br>
	 * JxlDecoderSetImageOutBuffer. This can be set when the JXL_DEC_FRAME event<br>
	 * occurs, must be set when the JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and<br>
	 * applies only for the current frame. Only one of JxlDecoderSetImageOutBuffer<br>
	 * or JxlDecoderSetImageOutCallback may be used for the same frame, not both at<br>
	 * the same time.<br>
	 * The callback will be called multiple times, to receive the image<br>
	 * data in small chunks. The callback receives a horizontal stripe of pixel<br>
	 * data, 1 pixel high, xsize pixels wide, called a scanline. The xsize here is<br>
	 * not the same as the full image width, the scanline may be a partial section,<br>
	 * and xsize may differ between calls. The user can then process and/or copy the<br>
	 * partial scanline to an image buffer. The callback may be called<br>
	 * simultaneously by different threads when using a threaded parallel runner, on<br>
	 * different pixels.<br>
	 * If JxlDecoderFlushImage is not used, then each pixel will be visited exactly<br>
	 * once by the different callback calls, during processing with one or more<br>
	 * JxlDecoderProcessInput calls. These pixels are decoded to full detail, they<br>
	 * are not part of a lower resolution or lower quality progressive pass, but the<br>
	 * final pass.<br>
	 * If JxlDecoderFlushImage is used, then in addition each pixel will be visited<br>
	 * zero or one times during the blocking JxlDecoderFlushImage call. Pixels<br>
	 * visited as a result of JxlDecoderFlushImage may represent a lower resolution<br>
	 * or lower quality intermediate progressive pass of the image. Any visited<br>
	 * pixel will be of a quality at least as good or better than previous visits of<br>
	 * this pixel. A pixel may be visited zero times if it cannot be decoded yet<br>
	 * or if it was already decoded to full precision (this behavior is not<br>
	 * guaranteed).<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 * are copied internally.<br>
	 * @param callback the callback function receiving partial scanlines of pixel<br>
	 * data.<br>
	 * @param opaque optional user data, which will be passed on to the callback,<br>
	 * may be NULL.<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * JxlDecoderSetImageOutBuffer already set.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutCallback(JxlDecoder*, const JxlPixelFormat*, JxlImageOutCallback, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:804</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetImageOutCallback(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, vavi.awt.image.jna.jpegxl.decode.DecodeLibrary.JxlImageOutCallback, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlDecoderSetImageOutCallback(Pointer dec, JxlPixelFormat format, DecodeLibrary.JxlImageOutCallback callback, Pointer opaque);
	/**
	 * Sets pixel output callback. This is an alternative to<br>
	 * JxlDecoderSetImageOutBuffer. This can be set when the JXL_DEC_FRAME event<br>
	 * occurs, must be set when the JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and<br>
	 * applies only for the current frame. Only one of JxlDecoderSetImageOutBuffer<br>
	 * or JxlDecoderSetImageOutCallback may be used for the same frame, not both at<br>
	 * the same time.<br>
	 * The callback will be called multiple times, to receive the image<br>
	 * data in small chunks. The callback receives a horizontal stripe of pixel<br>
	 * data, 1 pixel high, xsize pixels wide, called a scanline. The xsize here is<br>
	 * not the same as the full image width, the scanline may be a partial section,<br>
	 * and xsize may differ between calls. The user can then process and/or copy the<br>
	 * partial scanline to an image buffer. The callback may be called<br>
	 * simultaneously by different threads when using a threaded parallel runner, on<br>
	 * different pixels.<br>
	 * If JxlDecoderFlushImage is not used, then each pixel will be visited exactly<br>
	 * once by the different callback calls, during processing with one or more<br>
	 * JxlDecoderProcessInput calls. These pixels are decoded to full detail, they<br>
	 * are not part of a lower resolution or lower quality progressive pass, but the<br>
	 * final pass.<br>
	 * If JxlDecoderFlushImage is used, then in addition each pixel will be visited<br>
	 * zero or one times during the blocking JxlDecoderFlushImage call. Pixels<br>
	 * visited as a result of JxlDecoderFlushImage may represent a lower resolution<br>
	 * or lower quality intermediate progressive pass of the image. Any visited<br>
	 * pixel will be of a quality at least as good or better than previous visits of<br>
	 * this pixel. A pixel may be visited zero times if it cannot be decoded yet<br>
	 * or if it was already decoded to full precision (this behavior is not<br>
	 * guaranteed).<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 * are copied internally.<br>
	 * @param callback the callback function receiving partial scanlines of pixel<br>
	 * data.<br>
	 * @param opaque optional user data, which will be passed on to the callback,<br>
	 * may be NULL.<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * JxlDecoderSetImageOutBuffer already set.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutCallback(JxlDecoder*, const JxlPixelFormat*, JxlImageOutCallback, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:804</i>
	 */
	int JxlDecoderSetImageOutCallback(PointerByReference dec, JxlPixelFormat format, DecodeLibrary.JxlImageOutCallback callback, Pointer opaque);
	/**
	 * Returns the minimum size in bytes of an extra channel pixel buffer for the<br>
	 * given format. This is the buffer for JxlDecoderSetExtraChannelBuffer.<br>
	 * Requires the basic image information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. The num_channels value is ignored and is<br>
	 * always treated to be 1.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @param index which extra channel to get, matching the index used in @see<br>
	 * JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in the<br>
	 * associated JxlBasicInfo.<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 *    information not available yet or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderExtraChannelBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:823</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderExtraChannelBufferSize(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, LongByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderExtraChannelBufferSize(Pointer dec, JxlPixelFormat format, LongByReference size, int index);
	/**
	 * Returns the minimum size in bytes of an extra channel pixel buffer for the<br>
	 * given format. This is the buffer for JxlDecoderSetExtraChannelBuffer.<br>
	 * Requires the basic image information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. The num_channels value is ignored and is<br>
	 * always treated to be 1.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @param index which extra channel to get, matching the index used in @see<br>
	 * JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in the<br>
	 * associated JxlBasicInfo.<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 *    information not available yet or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderExtraChannelBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:823</i>
	 */
	int JxlDecoderExtraChannelBufferSize(PointerByReference dec, JxlPixelFormat format, LongByReference size, int index);
	/**
	 * Sets the buffer to write an extra channel to. This can be set when<br>
	 * the JXL_DEC_FRAME or JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and applies<br>
	 * only for the current frame. The size of the buffer must be at least as large<br>
	 * as given by JxlDecoderExtraChannelBufferSize. The buffer follows the format<br>
	 * described by JxlPixelFormat, but where num_channels is 1. The buffer is owned<br>
	 * by the caller. The amount of extra channels is given by the<br>
	 * num_extra_channels field in the associated JxlBasicInfo, and the information<br>
	 * of individual extra channels can be queried with @see<br>
	 * JxlDecoderGetExtraChannelInfo. To get multiple extra channels, this function<br>
	 * must be called multiple times, once for each wanted index. Not all images<br>
	 * have extra channels. The alpha channel is an extra channel and can be gotten<br>
	 * as part of the color channels when using an RGBA pixel buffer with<br>
	 * JxlDecoderSetImageOutBuffer, but additionally also can be gotten separately<br>
	 * as extra channel. The color channels themselves cannot be gotten this way.<br>
	 * *<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 * are copied internally. The num_channels value is ignored and is always<br>
	 * treated to be 1.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @param index which extra channel to get, matching the index used in @see<br>
	 * JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in the<br>
	 * associated JxlBasicInfo.<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * size too small or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetExtraChannelBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:856</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetExtraChannelBuffer(com.sun.jna.ptr.PointerByReference, JxlPixelFormat, com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetExtraChannelBuffer(Pointer dec, JxlPixelFormat format, Pointer buffer, int size, int index);
	/**
	 * Sets the buffer to write an extra channel to. This can be set when<br>
	 * the JXL_DEC_FRAME or JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and applies<br>
	 * only for the current frame. The size of the buffer must be at least as large<br>
	 * as given by JxlDecoderExtraChannelBufferSize. The buffer follows the format<br>
	 * described by JxlPixelFormat, but where num_channels is 1. The buffer is owned<br>
	 * by the caller. The amount of extra channels is given by the<br>
	 * num_extra_channels field in the associated JxlBasicInfo, and the information<br>
	 * of individual extra channels can be queried with @see<br>
	 * JxlDecoderGetExtraChannelInfo. To get multiple extra channels, this function<br>
	 * must be called multiple times, once for each wanted index. Not all images<br>
	 * have extra channels. The alpha channel is an extra channel and can be gotten<br>
	 * as part of the color channels when using an RGBA pixel buffer with<br>
	 * JxlDecoderSetImageOutBuffer, but additionally also can be gotten separately<br>
	 * as extra channel. The color channels themselves cannot be gotten this way.<br>
	 * *<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 * are copied internally. The num_channels value is ignored and is always<br>
	 * treated to be 1.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @param index which extra channel to get, matching the index used in @see<br>
	 * JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in the<br>
	 * associated JxlBasicInfo.<br>
	 * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as<br>
	 * size too small or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetExtraChannelBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:856</i>
	 */
	int JxlDecoderSetExtraChannelBuffer(PointerByReference dec, JxlPixelFormat format, Pointer buffer, int size, int index);
	/**
	 * Sets output buffer for reconstructed JPEG codestream.<br>
	 * The data is owned by the caller<br>
	 * and may be used by the decoder until JxlDecoderReleaseJPEGBuffer is called or<br>
	 * the decoder is destroyed or reset so must be kept alive until then.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to write to<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return JXL_DEC_ERROR if input was already set without releasing,<br>
	 * JXL_DEC_SUCCESS otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetJPEGBuffer(JxlDecoder*, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:873</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetJPEGBuffer(com.sun.jna.ptr.PointerByReference, java.nio.ByteBuffer, int)} and {@link #JxlDecoderSetJPEGBuffer(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetJPEGBuffer(Pointer dec, Pointer data, int size);
	/**
	 * Sets output buffer for reconstructed JPEG codestream.<br>
	 * The data is owned by the caller<br>
	 * and may be used by the decoder until JxlDecoderReleaseJPEGBuffer is called or<br>
	 * the decoder is destroyed or reset so must be kept alive until then.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to write to<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return JXL_DEC_ERROR if input was already set without releasing,<br>
	 * JXL_DEC_SUCCESS otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetJPEGBuffer(JxlDecoder*, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:873</i>
	 */
	int JxlDecoderSetJPEGBuffer(PointerByReference dec, ByteBuffer data, int size);
	/**
	 * Sets output buffer for reconstructed JPEG codestream.<br>
	 * The data is owned by the caller<br>
	 * and may be used by the decoder until JxlDecoderReleaseJPEGBuffer is called or<br>
	 * the decoder is destroyed or reset so must be kept alive until then.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to write to<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return JXL_DEC_ERROR if input was already set without releasing,<br>
	 * JXL_DEC_SUCCESS otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetJPEGBuffer(JxlDecoder*, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:873</i>
	 */
	int JxlDecoderSetJPEGBuffer(PointerByReference dec, Pointer data, int size);
	/**
	 * Releases buffer which was provided with JxlDecoderSetJPEGBuffer.<br>
	 * Calling JxlDecoderReleaseJPEGBuffer is required whenever<br>
	 * a buffer is already set and a new buffer needs to be added with<br>
	 * JxlDecoderSetJPEGBuffer, but is not required before JxlDecoderDestroy or<br>
	 * JxlDecoderReset.<br>
	 * Calling JxlDecoderReleaseJPEGBuffer when no input is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return the amount of bytes the decoder has not yet written to of the data<br>
	 * set by JxlDecoderSetJPEGBuffer, or 0 if no buffer is set or<br>
	 * JxlDecoderReleaseJPEGBuffer was already called.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseJPEGBuffer(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:892</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderReleaseJPEGBuffer(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderReleaseJPEGBuffer(Pointer dec);
	/**
	 * Releases buffer which was provided with JxlDecoderSetJPEGBuffer.<br>
	 * Calling JxlDecoderReleaseJPEGBuffer is required whenever<br>
	 * a buffer is already set and a new buffer needs to be added with<br>
	 * JxlDecoderSetJPEGBuffer, but is not required before JxlDecoderDestroy or<br>
	 * JxlDecoderReset.<br>
	 * Calling JxlDecoderReleaseJPEGBuffer when no input is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return the amount of bytes the decoder has not yet written to of the data<br>
	 * set by JxlDecoderSetJPEGBuffer, or 0 if no buffer is set or<br>
	 * JxlDecoderReleaseJPEGBuffer was already called.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseJPEGBuffer(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:892</i>
	 */
	int JxlDecoderReleaseJPEGBuffer(PointerByReference dec);
	/**
	 * Outputs progressive step towards the decoded image so far when only partial<br>
	 * input was received. If the flush was successful, the buffer set with<br>
	 * JxlDecoderSetImageOutBuffer will contain partial image data.<br>
	 * Can be called when JxlDecoderProcessInput returns JXL_DEC_NEED_MORE_INPUT,<br>
	 * after the JXL_DEC_FRAME event already occurred and before the<br>
	 * JXL_DEC_FULL_IMAGE event occurred for a frame.<br>
	 * @param dec decoder object<br>
	 * @return JXL_DEC_SUCCESS if image data was flushed to the output buffer, or<br>
	 * JXL_DEC_ERROR when no flush was done, e.g. if not enough image data was<br>
	 * available yet even for flush, or no output buffer was set yet. An error is<br>
	 * not fatal, it only indicates no flushed image is available now, regular,<br>
	 *  decoding can still be performed.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderFlushImage(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:910</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderFlushImage(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderFlushImage(Pointer dec);
	/**
	 * Outputs progressive step towards the decoded image so far when only partial<br>
	 * input was received. If the flush was successful, the buffer set with<br>
	 * JxlDecoderSetImageOutBuffer will contain partial image data.<br>
	 * Can be called when JxlDecoderProcessInput returns JXL_DEC_NEED_MORE_INPUT,<br>
	 * after the JXL_DEC_FRAME event already occurred and before the<br>
	 * JXL_DEC_FULL_IMAGE event occurred for a frame.<br>
	 * @param dec decoder object<br>
	 * @return JXL_DEC_SUCCESS if image data was flushed to the output buffer, or<br>
	 * JXL_DEC_ERROR when no flush was done, e.g. if not enough image data was<br>
	 * available yet even for flush, or no output buffer was set yet. An error is<br>
	 * not fatal, it only indicates no flushed image is available now, regular,<br>
	 *  decoding can still be performed.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderFlushImage(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:910</i>
	 */
	int JxlDecoderFlushImage(PointerByReference dec);
	class JxlDecoder extends PointerType {
		public JxlDecoder(Pointer address) {
			super(address);
		}
		public JxlDecoder() {
			super();
		}
	}
}
