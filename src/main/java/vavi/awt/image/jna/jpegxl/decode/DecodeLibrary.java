package vavi.awt.image.jna.jpegxl.decode;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.NativeLongByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.LongBuffer;

import vavi.awt.image.jna.jpegxl.JxlBasicInfo;
import vavi.awt.image.jna.jpegxl.JxlBlendInfo;
import vavi.awt.image.jna.jpegxl.JxlCmsInterface;
import vavi.awt.image.jna.jpegxl.JxlColorEncoding;
import vavi.awt.image.jna.jpegxl.JxlExtraChannelInfo;
import vavi.awt.image.jna.jpegxl.JxlFrameHeader;
import vavi.awt.image.jna.jpegxl.JxlMemoryManagerStruct;
import vavi.awt.image.jna.jpegxl.JxlPixelFormat;
import vavi.awt.image.jna.jpegxl.JxlBitDepth;
import vavi.awt.image.jna.jpegxl.JxlBoxType;
/**
 * JNA Wrapper for library <b>decode</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface DecodeLibrary extends Library {
	String JNA_LIBRARY_NAME = "jxl";
	NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(DecodeLibrary.JNA_LIBRARY_NAME);
	DecodeLibrary INSTANCE = Native.load(DecodeLibrary.JNA_LIBRARY_NAME, DecodeLibrary.class);
	/**
	 * <i>native declaration : jxl/decode.h</i><br>
	 * enum values
	 */
	interface JxlSignature {
		/** <i>native declaration : jxl/decode.h:20</i> */
		int JXL_SIG_NOT_ENOUGH_BYTES = 0;
		/** <i>native declaration : jxl/decode.h:23</i> */
		int JXL_SIG_INVALID = 1;
		/** <i>native declaration : jxl/decode.h:28</i> */
		int JXL_SIG_CODESTREAM = 2;
		/** <i>native declaration : jxl/decode.h:33</i> */
		int JXL_SIG_CONTAINER = 3;
	};
	/**
	 * <i>native declaration : jxl/decode.h</i><br>
	 * enum values
	 */
	interface JxlDecoderStatus {
		/** <i>native declaration : jxl/decode.h:111</i> */
		int JXL_DEC_SUCCESS = 0;
		/** <i>native declaration : jxl/decode.h:116</i> */
		int JXL_DEC_ERROR = 1;
		/** <i>native declaration : jxl/decode.h:132</i> */
		int JXL_DEC_NEED_MORE_INPUT = 2;
		/** <i>native declaration : jxl/decode.h:143</i> */
		int JXL_DEC_NEED_PREVIEW_OUT_BUFFER = 3;
		/** <i>native declaration : jxl/decode.h:152</i> */
		int JXL_DEC_NEED_IMAGE_OUT_BUFFER = 5;
		/** <i>native declaration : jxl/decode.h:159</i> */
		int JXL_DEC_JPEG_NEED_MORE_OUTPUT = 6;
		/** <i>native declaration : jxl/decode.h:165</i> */
		int JXL_DEC_BOX_NEED_MORE_OUTPUT = 7;
		/** <i>native declaration : jxl/decode.h:174</i> */
		int JXL_DEC_BASIC_INFO = 0x40;
		/** <i>native declaration : jxl/decode.h:184</i> */
		int JXL_DEC_COLOR_ENCODING = 0x100;
		/** <i>native declaration : jxl/decode.h:194</i> */
		int JXL_DEC_PREVIEW_IMAGE = 0x200;
		/** <i>native declaration : jxl/decode.h:215</i> */
		int JXL_DEC_FRAME = 0x400;
		/** <i>native declaration : jxl/decode.h:228</i> */
		int JXL_DEC_FULL_IMAGE = 0x1000;
		/** <i>native declaration : jxl/decode.h:241</i> */
		int JXL_DEC_JPEG_RECONSTRUCTION = 0x2000;
		/** <i>native declaration : jxl/decode.h:278</i> */
		int JXL_DEC_BOX = 0x4000;
		/** <i>native declaration : jxl/decode.h:295</i> */
		int JXL_DEC_FRAME_PROGRESSION = 0x8000;
	};
	/**
	 * <i>native declaration : jxl/decode.h</i><br>
	 * enum values
	 */
	interface JxlProgressiveDetail {
		/** <i>native declaration : jxl/decode.h:308</i> */
		int kFrames = 0;
		/** <i>native declaration : jxl/decode.h:310</i> */
		int kDC = 1;
		/** <i>native declaration : jxl/decode.h:313</i> */
		int kLastPasses = 2;
		/** <i>native declaration : jxl/decode.h:316</i> */
		int kPasses = 3;
		/** <i>native declaration : jxl/decode.h:318</i> */
		int kDCProgressive = 4;
		/** <i>native declaration : jxl/decode.h:320</i> */
		int kDCGroups = 5;
		/** <i>native declaration : jxl/decode.h:322</i> */
		int kGroups = 6;
	};
	/**
	 * <i>native declaration : jxl/decode.h</i><br>
	 * enum values
	 */
	interface JxlColorProfileTarget {
		/** <i>native declaration : jxl/decode.h:670</i> */
		int JXL_COLOR_PROFILE_TARGET_ORIGINAL = 0;
		/** <i>native declaration : jxl/decode.h:673</i> */
		int JXL_COLOR_PROFILE_TARGET_DATA = 1;
	};
	/** <i>native declaration : jxl/decode.h</i> */
	public interface JxlImageOutCallback extends Callback {
		void apply(Pointer opaque, NativeLong x, NativeLong y, NativeLong num_pixels, Pointer pixels);
	};
	/** <i>native declaration : jxl/decode.h</i> */
	public interface JxlImageOutInitCallback extends Callback {
		Pointer apply(Pointer init_opaque, NativeLong num_threads, NativeLong num_pixels_per_thread);
	};
	/** <i>native declaration : jxl/decode.h</i> */
	public interface JxlImageOutRunCallback extends Callback {
		void apply(Pointer run_opaque, NativeLong thread_id, NativeLong x, NativeLong y, NativeLong num_pixels, Pointer pixels);
	};
	/** <i>native declaration : jxl/decode.h</i> */
	public interface JxlImageOutDestroyCallback extends Callback {
		void apply(Pointer run_opaque);
	};
	/**
	 * Decoder library version.<br>
	 * @return the decoder library version as an integer:<br>
	 * MAJOR_VERSION * 1000000 + MINOR_VERSION * 1000 + PATCH_VERSION. For example,<br>
	 * version 1.2.3 would return 1002003.<br>
	 * Original signature : <code>uint32_t JxlDecoderVersion()</code><br>
	 * <i>native declaration : jxl/decode.h:13</i>
	 */
	int JxlDecoderVersion();
	/**
	 * JPEG XL signature identification.<br>
	 * Checks if the passed buffer contains a valid JPEG XL signature. The passed @p<br>
	 * buf of size<br>
	 * @p size doesn't need to be a full image, only the beginning of the file.<br>
	 * @return a flag indicating if a JPEG XL signature was found and what type.<br>
	 *  - @ref JXL_SIG_NOT_ENOUGH_BYTES if not enough bytes were passed to<br>
	 *    determine if a valid signature is there.<br>
	 *  - @ref JXL_SIG_INVALID if no valid signature found for JPEG XL decoding.<br>
	 *  - @ref JXL_SIG_CODESTREAM if a valid JPEG XL codestream signature was<br>
	 *    found.<br>
	 *  - @ref JXL_SIG_CONTAINER if a valid JPEG XL container signature was found.<br>
	 * Original signature : <code>JxlSignature JxlSignatureCheck(const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:51</i><br>
	 * @deprecated use the safer methods {@link #JxlSignatureCheck(byte[], NativeLong)} and {@link #JxlSignatureCheck(com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlSignatureCheck(Pointer buf, NativeLong len);
	/**
	 * JPEG XL signature identification.<br>
	 * Checks if the passed buffer contains a valid JPEG XL signature. The passed @p<br>
	 * buf of size<br>
	 * @p size doesn't need to be a full image, only the beginning of the file.<br>
	 * @return a flag indicating if a JPEG XL signature was found and what type.<br>
	 *  - @ref JXL_SIG_NOT_ENOUGH_BYTES if not enough bytes were passed to<br>
	 *    determine if a valid signature is there.<br>
	 *  - @ref JXL_SIG_INVALID if no valid signature found for JPEG XL decoding.<br>
	 *  - @ref JXL_SIG_CODESTREAM if a valid JPEG XL codestream signature was<br>
	 *    found.<br>
	 *  - @ref JXL_SIG_CONTAINER if a valid JPEG XL container signature was found.<br>
	 * Original signature : <code>JxlSignature JxlSignatureCheck(const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:51</i>
	 */
	int JxlSignatureCheck(byte buf[], NativeLong len);
	/**
	 * Creates an instance of @ref JxlDecoder and initializes it.<br>
	 * @p memory_manager will be used for all the library dynamic allocations made<br>
	 * from this instance. The parameter may be NULL, in which case the default<br>
	 * allocator will be used. See jxl/memory_manager.h for details.<br>
	 * @param memory_manager custom allocator function. It may be NULL. The memory<br>
	 *        manager will be copied internally.<br>
	 * @return @c NULL if the instance can not be allocated or initialized<br>
	 * @return pointer to initialized @ref JxlDecoder otherwise<br>
	 * Original signature : <code>JxlDecoder* JxlDecoderCreate(const JxlMemoryManagerStruct*)</code><br>
	 * <i>native declaration : jxl/decode.h:73</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderCreate(vavi.awt.image.jna.jpegxl.JxlMemoryManagerStruct[])} and {@link #JxlDecoderCreate(vavi.awt.image.jna.jpegxl.JxlMemoryManagerStruct)} instead
	 */
	@Deprecated 
	PointerByReference JxlDecoderCreate(JxlMemoryManagerStruct memory_manager);
	/**
	 * Creates an instance of @ref JxlDecoder and initializes it.<br>
	 * @p memory_manager will be used for all the library dynamic allocations made<br>
	 * from this instance. The parameter may be NULL, in which case the default<br>
	 * allocator will be used. See jxl/memory_manager.h for details.<br>
	 * @param memory_manager custom allocator function. It may be NULL. The memory<br>
	 *        manager will be copied internally.<br>
	 * @return @c NULL if the instance can not be allocated or initialized<br>
	 * @return pointer to initialized @ref JxlDecoder otherwise<br>
	 * Original signature : <code>JxlDecoder* JxlDecoderCreate(const JxlMemoryManagerStruct*)</code><br>
	 * <i>native declaration : jxl/decode.h:73</i>
	 */
	PointerByReference JxlDecoderCreate(JxlMemoryManagerStruct memory_manager[]);
	/**
	 * Re-initializes a @ref JxlDecoder instance, so it can be re-used for decoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with @ref JxlDecoderCreate, but the memory manager is kept.<br>
	 * @param dec instance to be re-initialized.<br>
	 * Original signature : <code>void JxlDecoderReset(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:82</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderReset(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlDecoderReset(Pointer dec);
	/**
	 * Re-initializes a @ref JxlDecoder instance, so it can be re-used for decoding<br>
	 * another image. All state and settings are reset as if the object was<br>
	 * newly created with @ref JxlDecoderCreate, but the memory manager is kept.<br>
	 * @param dec instance to be re-initialized.<br>
	 * Original signature : <code>void JxlDecoderReset(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:82</i>
	 */
	void JxlDecoderReset(PointerByReference dec);
	/**
	 * Deinitializes and frees @ref JxlDecoder instance.<br>
	 * @param dec instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlDecoderDestroy(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:89</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderDestroy(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlDecoderDestroy(Pointer dec);
	/**
	 * Deinitializes and frees @ref JxlDecoder instance.<br>
	 * @param dec instance to be cleaned up and deallocated.<br>
	 * Original signature : <code>void JxlDecoderDestroy(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:89</i>
	 */
	void JxlDecoderDestroy(PointerByReference dec);
	/**
	 * Rewinds decoder to the beginning. The same input must be given again from<br>
	 * the beginning of the file and the decoder will emit events from the beginning<br>
	 * again. When rewinding (as opposed to @ref JxlDecoderReset), the decoder can<br>
	 * keep state about the image, which it can use to skip to a requested frame<br>
	 * more efficiently with @ref JxlDecoderSkipFrames. Settings such as parallel<br>
	 * runner or subscribed events are kept. After rewind, @ref<br>
	 * JxlDecoderSubscribeEvents can be used again, and it is feasible to leave out<br>
	 * events that were already handled before, such as @ref JXL_DEC_BASIC_INFO<br>
	 * and @ref JXL_DEC_COLOR_ENCODING, since they will provide the same information<br>
	 * as before.<br>
	 * The difference to @ref JxlDecoderReset is that some state is kept, namely<br>
	 * settings set by a call to<br>
	 *  - @ref JxlDecoderSetCoalescing,<br>
	 *  - @ref JxlDecoderSetDesiredIntensityTarget,<br>
	 *  - @ref JxlDecoderSetDecompressBoxes,<br>
	 *  - @ref JxlDecoderSetKeepOrientation,<br>
	 *  - @ref JxlDecoderSetUnpremultiplyAlpha,<br>
	 *  - @ref JxlDecoderSetParallelRunner,<br>
	 *  - @ref JxlDecoderSetRenderSpotcolors, and<br>
	 *  - @ref JxlDecoderSubscribeEvents.<br>
	 * @param dec decoder object<br>
	 * Original signature : <code>void JxlDecoderRewind(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:348</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderRewind(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlDecoderRewind(Pointer dec);
	/**
	 * Rewinds decoder to the beginning. The same input must be given again from<br>
	 * the beginning of the file and the decoder will emit events from the beginning<br>
	 * again. When rewinding (as opposed to @ref JxlDecoderReset), the decoder can<br>
	 * keep state about the image, which it can use to skip to a requested frame<br>
	 * more efficiently with @ref JxlDecoderSkipFrames. Settings such as parallel<br>
	 * runner or subscribed events are kept. After rewind, @ref<br>
	 * JxlDecoderSubscribeEvents can be used again, and it is feasible to leave out<br>
	 * events that were already handled before, such as @ref JXL_DEC_BASIC_INFO<br>
	 * and @ref JXL_DEC_COLOR_ENCODING, since they will provide the same information<br>
	 * as before.<br>
	 * The difference to @ref JxlDecoderReset is that some state is kept, namely<br>
	 * settings set by a call to<br>
	 *  - @ref JxlDecoderSetCoalescing,<br>
	 *  - @ref JxlDecoderSetDesiredIntensityTarget,<br>
	 *  - @ref JxlDecoderSetDecompressBoxes,<br>
	 *  - @ref JxlDecoderSetKeepOrientation,<br>
	 *  - @ref JxlDecoderSetUnpremultiplyAlpha,<br>
	 *  - @ref JxlDecoderSetParallelRunner,<br>
	 *  - @ref JxlDecoderSetRenderSpotcolors, and<br>
	 *  - @ref JxlDecoderSubscribeEvents.<br>
	 * @param dec decoder object<br>
	 * Original signature : <code>void JxlDecoderRewind(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:348</i>
	 */
	void JxlDecoderRewind(PointerByReference dec);
	/**
	 * Makes the decoder skip the next `amount` frames. It still needs to process<br>
	 * the input, but will not output the frame events. It can be more efficient<br>
	 * when skipping frames, and even more so when using this after @ref<br>
	 * JxlDecoderRewind. If the decoder is already processing a frame (could<br>
	 * have emitted @ref JXL_DEC_FRAME but not yet @ref JXL_DEC_FULL_IMAGE), it<br>
	 * starts skipping from the next frame. If the amount is larger than the amount<br>
	 * of frames remaining in the image, all remaining frames are skipped. Calling<br>
	 * this function multiple times adds the amount to skip to the already existing<br>
	 * amount.<br>
	 * A frame here is defined as a frame that without skipping emits events such<br>
	 * as @ref JXL_DEC_FRAME and @ref JXL_DEC_FULL_IMAGE, frames that are internal<br>
	 * to the file format but are not rendered as part of an animation, or are not<br>
	 * the final still frame of a still image, are not counted.<br>
	 * @param dec decoder object<br>
	 * @param amount the amount of frames to skip<br>
	 * Original signature : <code>void JxlDecoderSkipFrames(JxlDecoder*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:368</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSkipFrames(com.sun.jna.ptr.PointerByReference, NativeLong)} instead
	 */
	@Deprecated 
	void JxlDecoderSkipFrames(Pointer dec, NativeLong amount);
	/**
	 * Makes the decoder skip the next `amount` frames. It still needs to process<br>
	 * the input, but will not output the frame events. It can be more efficient<br>
	 * when skipping frames, and even more so when using this after @ref<br>
	 * JxlDecoderRewind. If the decoder is already processing a frame (could<br>
	 * have emitted @ref JXL_DEC_FRAME but not yet @ref JXL_DEC_FULL_IMAGE), it<br>
	 * starts skipping from the next frame. If the amount is larger than the amount<br>
	 * of frames remaining in the image, all remaining frames are skipped. Calling<br>
	 * this function multiple times adds the amount to skip to the already existing<br>
	 * amount.<br>
	 * A frame here is defined as a frame that without skipping emits events such<br>
	 * as @ref JXL_DEC_FRAME and @ref JXL_DEC_FULL_IMAGE, frames that are internal<br>
	 * to the file format but are not rendered as part of an animation, or are not<br>
	 * the final still frame of a still image, are not counted.<br>
	 * @param dec decoder object<br>
	 * @param amount the amount of frames to skip<br>
	 * Original signature : <code>void JxlDecoderSkipFrames(JxlDecoder*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:368</i>
	 */
	void JxlDecoderSkipFrames(PointerByReference dec, NativeLong amount);
	/**
	 * Skips processing the current frame. Can be called after frame processing<br>
	 * already started, signaled by a @ref JXL_DEC_NEED_IMAGE_OUT_BUFFER event,<br>
	 * but before the corresponding @ref JXL_DEC_FULL_IMAGE event. The next signaled<br>
	 * event will be another @ref JXL_DEC_FRAME, or @ref JXL_DEC_SUCCESS if there<br>
	 * are no more frames. If pixel data is required from the already processed part<br>
	 * of the frame, @ref JxlDecoderFlushImage must be called before this.<br>
	 * @param dec decoder object<br>
	 * @return @ref JXL_DEC_SUCCESS if there is a frame to skip, and @ref<br>
	 *     JXL_DEC_ERROR if the function was not called during frame processing.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSkipCurrentFrame(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:382</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSkipCurrentFrame(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderSkipCurrentFrame(Pointer dec);
	/**
	 * Skips processing the current frame. Can be called after frame processing<br>
	 * already started, signaled by a @ref JXL_DEC_NEED_IMAGE_OUT_BUFFER event,<br>
	 * but before the corresponding @ref JXL_DEC_FULL_IMAGE event. The next signaled<br>
	 * event will be another @ref JXL_DEC_FRAME, or @ref JXL_DEC_SUCCESS if there<br>
	 * are no more frames. If pixel data is required from the already processed part<br>
	 * of the frame, @ref JxlDecoderFlushImage must be called before this.<br>
	 * @param dec decoder object<br>
	 * @return @ref JXL_DEC_SUCCESS if there is a frame to skip, and @ref<br>
	 *     JXL_DEC_ERROR if the function was not called during frame processing.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSkipCurrentFrame(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:382</i>
	 */
	int JxlDecoderSkipCurrentFrame(PointerByReference dec);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * decoding.<br>
	 * @param dec decoder object<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *     be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *     runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return @ref JXL_DEC_SUCCESS if the runner was set, @ref JXL_DEC_ERROR<br>
	 *     otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetParallelRunner(JxlDecoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:396</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetParallelRunner(com.sun.jna.ptr.PointerByReference, Pointer , com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlDecoderSetParallelRunner(Pointer dec, Pointer /* JxlParallelRunner */ parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Set the parallel runner for multithreading. May only be set before starting<br>
	 * decoding.<br>
	 * @param dec decoder object<br>
	 * @param parallel_runner function pointer to runner for multithreading. It may<br>
	 *     be NULL to use the default, single-threaded, runner. A multithreaded<br>
	 *     runner should be set to reach fast performance.<br>
	 * @param parallel_runner_opaque opaque pointer for parallel_runner.<br>
	 * @return @ref JXL_DEC_SUCCESS if the runner was set, @ref JXL_DEC_ERROR<br>
	 *     otherwise (the previous runner remains set).<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetParallelRunner(JxlDecoder*, JxlParallelRunner, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:396</i>
	 */
	int JxlDecoderSetParallelRunner(PointerByReference dec, Pointer /* JxlParallelRunner */ parallel_runner, Pointer parallel_runner_opaque);
	/**
	 * Returns a hint indicating how many more bytes the decoder is expected to<br>
	 * need to make @ref JxlDecoderGetBasicInfo available after the next @ref<br>
	 * JxlDecoderProcessInput call. This is a suggested large enough value for<br>
	 * the amount of bytes to provide in the next @ref JxlDecoderSetInput call, but<br>
	 * it is not guaranteed to be an upper bound nor a lower bound. This number does<br>
	 * not include bytes that have already been released from the input. Can be used<br>
	 * before the first @ref JxlDecoderProcessInput call, and is correct the first<br>
	 * time in most cases. If not, @ref JxlDecoderSizeHintBasicInfo can be called<br>
	 * again to get an updated hint.<br>
	 * @param dec decoder object<br>
	 * @return the size hint in bytes if the basic info is not yet fully decoded.<br>
	 * @return 0 when the basic info is already available.<br>
	 * Original signature : <code>size_t JxlDecoderSizeHintBasicInfo(const JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:415</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSizeHintBasicInfo(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	NativeLong JxlDecoderSizeHintBasicInfo(Pointer dec);
	/**
	 * Returns a hint indicating how many more bytes the decoder is expected to<br>
	 * need to make @ref JxlDecoderGetBasicInfo available after the next @ref<br>
	 * JxlDecoderProcessInput call. This is a suggested large enough value for<br>
	 * the amount of bytes to provide in the next @ref JxlDecoderSetInput call, but<br>
	 * it is not guaranteed to be an upper bound nor a lower bound. This number does<br>
	 * not include bytes that have already been released from the input. Can be used<br>
	 * before the first @ref JxlDecoderProcessInput call, and is correct the first<br>
	 * time in most cases. If not, @ref JxlDecoderSizeHintBasicInfo can be called<br>
	 * again to get an updated hint.<br>
	 * @param dec decoder object<br>
	 * @return the size hint in bytes if the basic info is not yet fully decoded.<br>
	 * @return 0 when the basic info is already available.<br>
	 * Original signature : <code>size_t JxlDecoderSizeHintBasicInfo(const JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:415</i>
	 */
	NativeLong JxlDecoderSizeHintBasicInfo(PointerByReference dec);
	/**
	 * Select for which informative events, i.e. @ref JXL_DEC_BASIC_INFO, etc., the<br>
	 * decoder should return with a status. It is not required to subscribe to any<br>
	 * events, data can still be requested from the decoder as soon as it available.<br>
	 * By default, the decoder is subscribed to no events (events_wanted == 0), and<br>
	 * the decoder will then only return when it cannot continue because it needs<br>
	 * more input data or more output buffer. This function may only be be called<br>
	 * before using @ref JxlDecoderProcessInput.<br>
	 * @param dec decoder object<br>
	 * @param events_wanted bitfield of desired events.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSubscribeEvents(JxlDecoder*, int)</code><br>
	 * <i>native declaration : jxl/decode.h:429</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSubscribeEvents(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSubscribeEvents(Pointer dec, int events_wanted);
	/**
	 * Select for which informative events, i.e. @ref JXL_DEC_BASIC_INFO, etc., the<br>
	 * decoder should return with a status. It is not required to subscribe to any<br>
	 * events, data can still be requested from the decoder as soon as it available.<br>
	 * By default, the decoder is subscribed to no events (events_wanted == 0), and<br>
	 * the decoder will then only return when it cannot continue because it needs<br>
	 * more input data or more output buffer. This function may only be be called<br>
	 * before using @ref JxlDecoderProcessInput.<br>
	 * @param dec decoder object<br>
	 * @param events_wanted bitfield of desired events.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSubscribeEvents(JxlDecoder*, int)</code><br>
	 * <i>native declaration : jxl/decode.h:429</i>
	 */
	int JxlDecoderSubscribeEvents(PointerByReference dec, int events_wanted);
	/**
	 * Enables or disables preserving of as-in-bitstream pixeldata<br>
	 * orientation. Some images are encoded with an Orientation tag<br>
	 * indicating that the decoder must perform a rotation and/or<br>
	 * mirroring to the encoded image data.<br>
	 *  - If skip_reorientation is JXL_FALSE (the default): the decoder<br>
	 *    will apply the transformation from the orientation setting, hence<br>
	 *    rendering the image according to its specified intent. When<br>
	 *    producing a JxlBasicInfo, the decoder will always set the<br>
	 *    orientation field to JXL_ORIENT_IDENTITY (matching the returned<br>
	 *    pixel data) and also align xsize and ysize so that they correspond<br>
	 *    to the width and the height of the returned pixel data.<br>
	 *  - If skip_reorientation is JXL_TRUE: the decoder will skip<br>
	 *    applying the transformation from the orientation setting, returning<br>
	 *    the image in the as-in-bitstream pixeldata orientation.<br>
	 *    This may be faster to decode since the decoder doesn't have to apply the<br>
	 *    transformation, but can cause wrong display of the image if the<br>
	 *    orientation tag is not correctly taken into account by the user.<br>
	 * By default, this option is disabled, and the returned pixel data is<br>
	 * re-oriented according to the image's Orientation setting.<br>
	 * This function must be called at the beginning, before decoding is performed.<br>
	 * @see JxlBasicInfo for the orientation field, and @ref JxlOrientation for the<br>
	 * possible values.<br>
	 * @param dec decoder object<br>
	 * @param skip_reorientation JXL_TRUE to enable, JXL_FALSE to disable.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetKeepOrientation(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:463</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetKeepOrientation(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetKeepOrientation(Pointer dec, int /* JXL_BOOL */ skip_reorientation);
	/**
	 * Enables or disables preserving of as-in-bitstream pixeldata<br>
	 * orientation. Some images are encoded with an Orientation tag<br>
	 * indicating that the decoder must perform a rotation and/or<br>
	 * mirroring to the encoded image data.<br>
	 *  - If skip_reorientation is JXL_FALSE (the default): the decoder<br>
	 *    will apply the transformation from the orientation setting, hence<br>
	 *    rendering the image according to its specified intent. When<br>
	 *    producing a JxlBasicInfo, the decoder will always set the<br>
	 *    orientation field to JXL_ORIENT_IDENTITY (matching the returned<br>
	 *    pixel data) and also align xsize and ysize so that they correspond<br>
	 *    to the width and the height of the returned pixel data.<br>
	 *  - If skip_reorientation is JXL_TRUE: the decoder will skip<br>
	 *    applying the transformation from the orientation setting, returning<br>
	 *    the image in the as-in-bitstream pixeldata orientation.<br>
	 *    This may be faster to decode since the decoder doesn't have to apply the<br>
	 *    transformation, but can cause wrong display of the image if the<br>
	 *    orientation tag is not correctly taken into account by the user.<br>
	 * By default, this option is disabled, and the returned pixel data is<br>
	 * re-oriented according to the image's Orientation setting.<br>
	 * This function must be called at the beginning, before decoding is performed.<br>
	 * @see JxlBasicInfo for the orientation field, and @ref JxlOrientation for the<br>
	 * possible values.<br>
	 * @param dec decoder object<br>
	 * @param skip_reorientation JXL_TRUE to enable, JXL_FALSE to disable.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetKeepOrientation(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:463</i>
	 */
	int JxlDecoderSetKeepOrientation(PointerByReference dec, int /* JXL_BOOL */ skip_reorientation);
	/**
	 * Enables or disables preserving of associated alpha channels. If<br>
	 * unpremul_alpha is set to JXL_FALSE then for associated alpha channel, the<br>
	 * pixel data is returned with premultiplied colors. If it is set to JXL_TRUE,<br>
	 * The colors will be unpremultiplied based on the alpha channel. This function<br>
	 * has no effect if the image does not have an associated alpha channel.<br>
	 * By default, this option is disabled, and the returned pixel data "as is".<br>
	 * This function must be called at the beginning, before decoding is performed.<br>
	 * @param dec decoder object<br>
	 * @param unpremul_alpha JXL_TRUE to enable, JXL_FALSE to disable.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetUnpremultiplyAlpha(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:481</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetUnpremultiplyAlpha(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetUnpremultiplyAlpha(Pointer dec, int /* JXL_BOOL */ unpremul_alpha);
	/**
	 * Enables or disables preserving of associated alpha channels. If<br>
	 * unpremul_alpha is set to JXL_FALSE then for associated alpha channel, the<br>
	 * pixel data is returned with premultiplied colors. If it is set to JXL_TRUE,<br>
	 * The colors will be unpremultiplied based on the alpha channel. This function<br>
	 * has no effect if the image does not have an associated alpha channel.<br>
	 * By default, this option is disabled, and the returned pixel data "as is".<br>
	 * This function must be called at the beginning, before decoding is performed.<br>
	 * @param dec decoder object<br>
	 * @param unpremul_alpha JXL_TRUE to enable, JXL_FALSE to disable.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetUnpremultiplyAlpha(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:481</i>
	 */
	int JxlDecoderSetUnpremultiplyAlpha(PointerByReference dec, int /* JXL_BOOL */ unpremul_alpha);
	/**
	 * Enables or disables rendering spot colors. By default, spot colors<br>
	 * are rendered, which is OK for viewing the decoded image. If render_spotcolors<br>
	 * is JXL_FALSE, then spot colors are not rendered, and have to be retrieved<br>
	 * separately using @ref JxlDecoderSetExtraChannelBuffer. This is useful for<br>
	 * e.g. printing applications.<br>
	 * @param dec decoder object<br>
	 * @param render_spotcolors JXL_TRUE to enable (default), JXL_FALSE to disable.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetRenderSpotcolors(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:494</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetRenderSpotcolors(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetRenderSpotcolors(Pointer dec, int /* JXL_BOOL */ render_spotcolors);
	/**
	 * Enables or disables rendering spot colors. By default, spot colors<br>
	 * are rendered, which is OK for viewing the decoded image. If render_spotcolors<br>
	 * is JXL_FALSE, then spot colors are not rendered, and have to be retrieved<br>
	 * separately using @ref JxlDecoderSetExtraChannelBuffer. This is useful for<br>
	 * e.g. printing applications.<br>
	 * @param dec decoder object<br>
	 * @param render_spotcolors JXL_TRUE to enable (default), JXL_FALSE to disable.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetRenderSpotcolors(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:494</i>
	 */
	int JxlDecoderSetRenderSpotcolors(PointerByReference dec, int /* JXL_BOOL */ render_spotcolors);
	/**
	 * Enables or disables coalescing of zero-duration frames. By default, frames<br>
	 * are returned with coalescing enabled, i.e. all frames have the image<br>
	 * dimensions, and are blended if needed. When coalescing is disabled, frames<br>
	 * can have arbitrary dimensions, a non-zero crop offset, and blending is not<br>
	 * performed. For display, coalescing is recommended. For loading a multi-layer<br>
	 * still image as separate layers (as opposed to the merged image), coalescing<br>
	 * has to be disabled.<br>
	 * @param dec decoder object<br>
	 * @param coalescing JXL_TRUE to enable coalescing (default), JXL_FALSE to<br>
	 *     disable it.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetCoalescing(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:510</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetCoalescing(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetCoalescing(Pointer dec, int /* JXL_BOOL */ coalescing);
	/**
	 * Enables or disables coalescing of zero-duration frames. By default, frames<br>
	 * are returned with coalescing enabled, i.e. all frames have the image<br>
	 * dimensions, and are blended if needed. When coalescing is disabled, frames<br>
	 * can have arbitrary dimensions, a non-zero crop offset, and blending is not<br>
	 * performed. For display, coalescing is recommended. For loading a multi-layer<br>
	 * still image as separate layers (as opposed to the merged image), coalescing<br>
	 * has to be disabled.<br>
	 * @param dec decoder object<br>
	 * @param coalescing JXL_TRUE to enable coalescing (default), JXL_FALSE to<br>
	 *     disable it.<br>
	 * @return @ref JXL_DEC_SUCCESS if no error, @ref JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetCoalescing(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:510</i>
	 */
	int JxlDecoderSetCoalescing(PointerByReference dec, int /* JXL_BOOL */ coalescing);
	/**
	 * Decodes JPEG XL file using the available bytes. Requires input has been<br>
	 * set with @ref JxlDecoderSetInput. After @ref JxlDecoderProcessInput, input<br>
	 * can optionally be released with @ref JxlDecoderReleaseInput and then set<br>
	 * again to next bytes in the stream. @ref JxlDecoderReleaseInput returns how<br>
	 * many bytes are not yet processed, before a next call to @ref<br>
	 * JxlDecoderProcessInput all unprocessed bytes must be provided again (the<br>
	 * address need not match, but the contents must), and more bytes may be<br>
	 * concatenated after the unprocessed bytes.<br>
	 * The returned status indicates whether the decoder needs more input bytes, or<br>
	 * more output buffer for a certain type of output data. No matter what the<br>
	 * returned status is (other than @ref JXL_DEC_ERROR), new information, such<br>
	 * as @ref JxlDecoderGetBasicInfo, may have become available after this call.<br>
	 * When the return value is not @ref JXL_DEC_ERROR or @ref JXL_DEC_SUCCESS, the<br>
	 * decoding requires more @ref JxlDecoderProcessInput calls to continue.<br>
	 * @param dec decoder object<br>
	 * @return @ref JXL_DEC_SUCCESS when decoding finished and all events handled.<br>
	 *     If you still have more unprocessed input data anyway, then you can still<br>
	 *     continue by using @ref JxlDecoderSetInput and calling @ref<br>
	 *     JxlDecoderProcessInput again, similar to handling @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT. @ref JXL_DEC_SUCCESS can occur instead of @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT when, for example, the input data ended right at<br>
	 *     the boundary of a box of the container format, all essential codestream<br>
	 *     boxes were already decoded, but extra metadata boxes are still present in<br>
	 *     the next data. @ref JxlDecoderProcessInput cannot return success if all<br>
	 *     codestream boxes have not been seen yet.<br>
	 * @return @ref JXL_DEC_ERROR when decoding failed, e.g. invalid codestream.<br>
	 *     TODO(lode): document the input data mechanism<br>
	 * @return @ref JXL_DEC_NEED_MORE_INPUT when more input data is necessary.<br>
	 * @return @ref JXL_DEC_BASIC_INFO when basic info such as image dimensions is<br>
	 *     available and this informative event is subscribed to.<br>
	 * @return @ref JXL_DEC_COLOR_ENCODING when color profile information is<br>
	 *     available and this informative event is subscribed to.<br>
	 * @return @ref JXL_DEC_PREVIEW_IMAGE when preview pixel information is<br>
	 *     available and output in the preview buffer.<br>
	 * @return @ref JXL_DEC_FULL_IMAGE when all pixel information at highest detail<br>
	 *     is available and has been output in the pixel buffer.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderProcessInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:553</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderProcessInput(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderProcessInput(Pointer dec);
	/**
	 * Decodes JPEG XL file using the available bytes. Requires input has been<br>
	 * set with @ref JxlDecoderSetInput. After @ref JxlDecoderProcessInput, input<br>
	 * can optionally be released with @ref JxlDecoderReleaseInput and then set<br>
	 * again to next bytes in the stream. @ref JxlDecoderReleaseInput returns how<br>
	 * many bytes are not yet processed, before a next call to @ref<br>
	 * JxlDecoderProcessInput all unprocessed bytes must be provided again (the<br>
	 * address need not match, but the contents must), and more bytes may be<br>
	 * concatenated after the unprocessed bytes.<br>
	 * The returned status indicates whether the decoder needs more input bytes, or<br>
	 * more output buffer for a certain type of output data. No matter what the<br>
	 * returned status is (other than @ref JXL_DEC_ERROR), new information, such<br>
	 * as @ref JxlDecoderGetBasicInfo, may have become available after this call.<br>
	 * When the return value is not @ref JXL_DEC_ERROR or @ref JXL_DEC_SUCCESS, the<br>
	 * decoding requires more @ref JxlDecoderProcessInput calls to continue.<br>
	 * @param dec decoder object<br>
	 * @return @ref JXL_DEC_SUCCESS when decoding finished and all events handled.<br>
	 *     If you still have more unprocessed input data anyway, then you can still<br>
	 *     continue by using @ref JxlDecoderSetInput and calling @ref<br>
	 *     JxlDecoderProcessInput again, similar to handling @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT. @ref JXL_DEC_SUCCESS can occur instead of @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT when, for example, the input data ended right at<br>
	 *     the boundary of a box of the container format, all essential codestream<br>
	 *     boxes were already decoded, but extra metadata boxes are still present in<br>
	 *     the next data. @ref JxlDecoderProcessInput cannot return success if all<br>
	 *     codestream boxes have not been seen yet.<br>
	 * @return @ref JXL_DEC_ERROR when decoding failed, e.g. invalid codestream.<br>
	 *     TODO(lode): document the input data mechanism<br>
	 * @return @ref JXL_DEC_NEED_MORE_INPUT when more input data is necessary.<br>
	 * @return @ref JXL_DEC_BASIC_INFO when basic info such as image dimensions is<br>
	 *     available and this informative event is subscribed to.<br>
	 * @return @ref JXL_DEC_COLOR_ENCODING when color profile information is<br>
	 *     available and this informative event is subscribed to.<br>
	 * @return @ref JXL_DEC_PREVIEW_IMAGE when preview pixel information is<br>
	 *     available and output in the preview buffer.<br>
	 * @return @ref JXL_DEC_FULL_IMAGE when all pixel information at highest detail<br>
	 *     is available and has been output in the pixel buffer.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderProcessInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:553</i>
	 */
	int JxlDecoderProcessInput(PointerByReference dec);
	/**
	 * Sets input data for @ref JxlDecoderProcessInput. The data is owned by the<br>
	 * caller and may be used by the decoder until @ref JxlDecoderReleaseInput is<br>
	 * called or the decoder is destroyed or reset so must be kept alive until then.<br>
	 * Cannot be called if @ref JxlDecoderSetInput was already called and @ref<br>
	 * JxlDecoderReleaseInput was not yet called, and cannot be called after @ref<br>
	 * JxlDecoderCloseInput indicating the end of input was called.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to read from<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return @ref JXL_DEC_ERROR if input was already set without releasing or @ref<br>
	 *     JxlDecoderCloseInput was already called, @ref JXL_DEC_SUCCESS otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetInput(JxlDecoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:569</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetInput(com.sun.jna.ptr.PointerByReference, byte[], NativeLong)} and {@link #JxlDecoderSetInput(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlDecoderSetInput(Pointer dec, Pointer data, NativeLong size);
	/**
	 * Sets input data for @ref JxlDecoderProcessInput. The data is owned by the<br>
	 * caller and may be used by the decoder until @ref JxlDecoderReleaseInput is<br>
	 * called or the decoder is destroyed or reset so must be kept alive until then.<br>
	 * Cannot be called if @ref JxlDecoderSetInput was already called and @ref<br>
	 * JxlDecoderReleaseInput was not yet called, and cannot be called after @ref<br>
	 * JxlDecoderCloseInput indicating the end of input was called.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to read from<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return @ref JXL_DEC_ERROR if input was already set without releasing or @ref<br>
	 *     JxlDecoderCloseInput was already called, @ref JXL_DEC_SUCCESS otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetInput(JxlDecoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:569</i>
	 */
	int JxlDecoderSetInput(PointerByReference dec, byte data[], NativeLong size);
	/**
	 * Sets input data for @ref JxlDecoderProcessInput. The data is owned by the<br>
	 * caller and may be used by the decoder until @ref JxlDecoderReleaseInput is<br>
	 * called or the decoder is destroyed or reset so must be kept alive until then.<br>
	 * Cannot be called if @ref JxlDecoderSetInput was already called and @ref<br>
	 * JxlDecoderReleaseInput was not yet called, and cannot be called after @ref<br>
	 * JxlDecoderCloseInput indicating the end of input was called.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to read from<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return @ref JXL_DEC_ERROR if input was already set without releasing or @ref<br>
	 *     JxlDecoderCloseInput was already called, @ref JXL_DEC_SUCCESS otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetInput(JxlDecoder*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:569</i>
	 */
	int JxlDecoderSetInput(PointerByReference dec, Pointer data, NativeLong size);
	/**
	 * Releases input which was provided with @ref JxlDecoderSetInput. Between @ref<br>
	 * JxlDecoderProcessInput and @ref JxlDecoderReleaseInput, the user may not<br>
	 * alter the data in the buffer. Calling @ref JxlDecoderReleaseInput is required<br>
	 * whenever any input is already set and new input needs to be added with @ref<br>
	 * JxlDecoderSetInput, but is not required before @ref JxlDecoderDestroy or @ref<br>
	 * JxlDecoderReset. Calling @ref JxlDecoderReleaseInput when no input is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return The amount of bytes the decoder has not yet processed that are still<br>
	 *     remaining in the data set by @ref JxlDecoderSetInput, or 0 if no input is<br>
	 *     set or @ref JxlDecoderReleaseInput was already called. For a next call<br>
	 *     to @ref JxlDecoderProcessInput, the buffer must start with these<br>
	 *     unprocessed bytes. From this value it is possible to infer the position<br>
	 *     of certain JPEG XL codestream elements (e.g. end of headers, frame<br>
	 *     start/end). See the documentation of individual values of @ref<br>
	 *     JxlDecoderStatus for more information.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:592</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderReleaseInput(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	NativeLong JxlDecoderReleaseInput(Pointer dec);
	/**
	 * Releases input which was provided with @ref JxlDecoderSetInput. Between @ref<br>
	 * JxlDecoderProcessInput and @ref JxlDecoderReleaseInput, the user may not<br>
	 * alter the data in the buffer. Calling @ref JxlDecoderReleaseInput is required<br>
	 * whenever any input is already set and new input needs to be added with @ref<br>
	 * JxlDecoderSetInput, but is not required before @ref JxlDecoderDestroy or @ref<br>
	 * JxlDecoderReset. Calling @ref JxlDecoderReleaseInput when no input is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return The amount of bytes the decoder has not yet processed that are still<br>
	 *     remaining in the data set by @ref JxlDecoderSetInput, or 0 if no input is<br>
	 *     set or @ref JxlDecoderReleaseInput was already called. For a next call<br>
	 *     to @ref JxlDecoderProcessInput, the buffer must start with these<br>
	 *     unprocessed bytes. From this value it is possible to infer the position<br>
	 *     of certain JPEG XL codestream elements (e.g. end of headers, frame<br>
	 *     start/end). See the documentation of individual values of @ref<br>
	 *     JxlDecoderStatus for more information.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:592</i>
	 */
	NativeLong JxlDecoderReleaseInput(PointerByReference dec);
	/**
	 * Marks the input as finished, indicates that no more @ref JxlDecoderSetInput<br>
	 * will be called. This function allows the decoder to determine correctly if it<br>
	 * should return success, need more input or error in certain cases. For<br>
	 * backwards compatibility with a previous version of the API, using this<br>
	 * function is optional when not using the @ref JXL_DEC_BOX event (the decoder<br>
	 * is able to determine the end of the image frames without marking the end),<br>
	 * but using this function is required when using @ref JXL_DEC_BOX for getting<br>
	 * metadata box contents. This function does not replace @ref<br>
	 * JxlDecoderReleaseInput, that function should still be called if its return<br>
	 * value is needed.<br>
	 * @ref JxlDecoderCloseInput should be called as soon as all known input bytes<br>
	 * are set (e.g. at the beginning when not streaming but setting all input<br>
	 * at once), before the final @ref JxlDecoderProcessInput calls.<br>
	 * @param dec decoder object<br>
	 * Original signature : <code>void JxlDecoderCloseInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:612</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderCloseInput(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void JxlDecoderCloseInput(Pointer dec);
	/**
	 * Marks the input as finished, indicates that no more @ref JxlDecoderSetInput<br>
	 * will be called. This function allows the decoder to determine correctly if it<br>
	 * should return success, need more input or error in certain cases. For<br>
	 * backwards compatibility with a previous version of the API, using this<br>
	 * function is optional when not using the @ref JXL_DEC_BOX event (the decoder<br>
	 * is able to determine the end of the image frames without marking the end),<br>
	 * but using this function is required when using @ref JXL_DEC_BOX for getting<br>
	 * metadata box contents. This function does not replace @ref<br>
	 * JxlDecoderReleaseInput, that function should still be called if its return<br>
	 * value is needed.<br>
	 * @ref JxlDecoderCloseInput should be called as soon as all known input bytes<br>
	 * are set (e.g. at the beginning when not streaming but setting all input<br>
	 * at once), before the final @ref JxlDecoderProcessInput calls.<br>
	 * @param dec decoder object<br>
	 * Original signature : <code>void JxlDecoderCloseInput(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:612</i>
	 */
	void JxlDecoderCloseInput(PointerByReference dec);
	/**
	 * Outputs the basic image information, such as image dimensions, bit depth and<br>
	 * all other JxlBasicInfo fields, if available.<br>
	 * @param dec decoder object<br>
	 * @param info struct to copy the information into, or NULL to only check<br>
	 *     whether the information is available through the return value.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR<br>
	 *     in case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetBasicInfo(const JxlDecoder*, JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:625</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetBasicInfo(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlBasicInfo)} instead
	 */
	@Deprecated 
	int JxlDecoderGetBasicInfo(Pointer dec, JxlBasicInfo info);
	/**
	 * Outputs the basic image information, such as image dimensions, bit depth and<br>
	 * all other JxlBasicInfo fields, if available.<br>
	 * @param dec decoder object<br>
	 * @param info struct to copy the information into, or NULL to only check<br>
	 *     whether the information is available through the return value.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR<br>
	 *     in case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetBasicInfo(const JxlDecoder*, JxlBasicInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:625</i>
	 */
	int JxlDecoderGetBasicInfo(PointerByReference dec, JxlBasicInfo info);
	/**
	 * Outputs information for extra channel at the given index. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param info struct to copy the information into, or NULL to only check<br>
	 *     whether the information is available through the return value.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR<br>
	 *     in case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelInfo(const JxlDecoder*, size_t, JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:640</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetExtraChannelInfo(com.sun.jna.ptr.PointerByReference, com.sun.jna.NativeLong, vavi.awt.image.jna.jpegxl.JxlExtraChannelInfo)} instead
	 */
	@Deprecated 
	int JxlDecoderGetExtraChannelInfo(Pointer dec, NativeLong index, JxlExtraChannelInfo info);
	/**
	 * Outputs information for extra channel at the given index. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param info struct to copy the information into, or NULL to only check<br>
	 *     whether the information is available through the return value.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR<br>
	 *     in case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelInfo(const JxlDecoder*, size_t, JxlExtraChannelInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:640</i>
	 */
	int JxlDecoderGetExtraChannelInfo(PointerByReference dec, NativeLong index, JxlExtraChannelInfo info);
	/**
	 * Outputs name for extra channel at the given index in UTF-8. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo. The buffer<br>
	 * for name must have at least name_length + 1 bytes allocated, gotten from<br>
	 * the associated JxlExtraChannelInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR<br>
	 *     in case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelName(const JxlDecoder*, size_t, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:657</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderGetExtraChannelName(com.sun.jna.ptr.PointerByReference, NativeLong, java.nio.ByteBuffer, NativeLong)} and {@link #JxlDecoderGetExtraChannelName(com.sun.jna.ptr.PointerByReference, NativeLong, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlDecoderGetExtraChannelName(Pointer dec, NativeLong index, Pointer name, NativeLong size);
	/**
	 * Outputs name for extra channel at the given index in UTF-8. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo. The buffer<br>
	 * for name must have at least name_length + 1 bytes allocated, gotten from<br>
	 * the associated JxlExtraChannelInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR<br>
	 *     in case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelName(const JxlDecoder*, size_t, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:657</i>
	 */
	int JxlDecoderGetExtraChannelName(PointerByReference dec, NativeLong index, ByteBuffer name, NativeLong size);
	/**
	 * Outputs name for extra channel at the given index in UTF-8. The index must be<br>
	 * smaller than num_extra_channels in the associated JxlBasicInfo. The buffer<br>
	 * for name must have at least name_length + 1 bytes allocated, gotten from<br>
	 * the associated JxlExtraChannelInfo.<br>
	 * @param dec decoder object<br>
	 * @param index index of the extra channel to query.<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR<br>
	 *     in case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelName(const JxlDecoder*, size_t, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:657</i>
	 */
	int JxlDecoderGetExtraChannelName(PointerByReference dec, NativeLong index, Pointer name, NativeLong size);
	/**
	 * Outputs the color profile as JPEG XL encoded structured data, if available.<br>
	 * This is an alternative to an ICC Profile, which can represent a more limited<br>
	 * amount of color spaces, but represents them exactly through enum values.<br>
	 * It is often possible to use @ref JxlDecoderGetColorAsICCProfile as an<br>
	 * alternative anyway. The following scenarios are possible:<br>
	 *  - The JPEG XL image has an attached ICC Profile, in that case, the encoded<br>
	 *    structured data is not available, this function will return an error<br>
	 *    status. @ref JxlDecoderGetColorAsICCProfile should be called instead.<br>
	 *  - The JPEG XL image has an encoded structured color profile, and it<br>
	 *    represents an RGB or grayscale color space. This function will return it.<br>
	 *    You can still use @ref JxlDecoderGetColorAsICCProfile as well as an<br>
	 *    alternative if desired, though depending on which RGB color space is<br>
	 *    represented, the ICC profile may be a close approximation. It is also not<br>
	 *    always feasible to deduce from an ICC profile which named color space it<br>
	 *    exactly represents, if any, as it can represent any arbitrary space.<br>
	 *    HDR color spaces such as those using PQ and HLG are also potentially<br>
	 *    problematic, in that: while ICC profiles can encode a transfer function<br>
	 *    that happens to approximate those of PQ and HLG (HLG for only one given<br>
	 *    system gamma at a time, and necessitating a 3D LUT if gamma is to be<br>
	 *    different from 1), they cannot (before ICCv4.4) semantically signal that<br>
	 *    this is the color space that they represent. Therefore, they will<br>
	 *    typically not actually be interpreted as representing an HDR color space.<br>
	 *    This is especially detrimental to PQ which will then be interpreted as if<br>
	 *    the maximum signal value represented SDR white instead of 10000 cd/m^2,<br>
	 *    meaning that the image will be displayed two orders of magnitude (5-7 EV)<br>
	 *    too dim.<br>
	 *  - The JPEG XL image has an encoded structured color profile, and it<br>
	 *    indicates an unknown or xyb color space. In that case, @ref<br>
	 *    JxlDecoderGetColorAsICCProfile is not available.<br>
	 * When rendering an image on a system where ICC-based color management is used,<br>
	 * @ref JxlDecoderGetColorAsICCProfile should generally be used first as it will<br>
	 * return a ready-to-use profile (with the aforementioned caveat about HDR).<br>
	 * When knowledge about the nominal color space is desired if available, @ref<br>
	 * JxlDecoderGetColorAsEncodedProfile should be used first.<br>
	 * @param dec decoder object<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param color_encoding struct to copy the information into, or NULL to only<br>
	 *     check whether the information is available through the return value.<br>
	 * @return @ref JXL_DEC_SUCCESS if the data is available and returned, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR in<br>
	 *     case the encoded structured color profile does not exist in the<br>
	 *     codestream.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsEncodedProfile(const JxlDecoder*, JxlColorProfileTarget, JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/decode.h:724</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetColorAsEncodedProfile(com.sun.jna.ptr.PointerByReference, int, vavi.awt.image.jna.jpegxl.JxlColorEncoding)} instead
	 */
	@Deprecated 
	int JxlDecoderGetColorAsEncodedProfile(Pointer dec, int target, JxlColorEncoding color_encoding);
	/**
	 * Outputs the color profile as JPEG XL encoded structured data, if available.<br>
	 * This is an alternative to an ICC Profile, which can represent a more limited<br>
	 * amount of color spaces, but represents them exactly through enum values.<br>
	 * It is often possible to use @ref JxlDecoderGetColorAsICCProfile as an<br>
	 * alternative anyway. The following scenarios are possible:<br>
	 *  - The JPEG XL image has an attached ICC Profile, in that case, the encoded<br>
	 *    structured data is not available, this function will return an error<br>
	 *    status. @ref JxlDecoderGetColorAsICCProfile should be called instead.<br>
	 *  - The JPEG XL image has an encoded structured color profile, and it<br>
	 *    represents an RGB or grayscale color space. This function will return it.<br>
	 *    You can still use @ref JxlDecoderGetColorAsICCProfile as well as an<br>
	 *    alternative if desired, though depending on which RGB color space is<br>
	 *    represented, the ICC profile may be a close approximation. It is also not<br>
	 *    always feasible to deduce from an ICC profile which named color space it<br>
	 *    exactly represents, if any, as it can represent any arbitrary space.<br>
	 *    HDR color spaces such as those using PQ and HLG are also potentially<br>
	 *    problematic, in that: while ICC profiles can encode a transfer function<br>
	 *    that happens to approximate those of PQ and HLG (HLG for only one given<br>
	 *    system gamma at a time, and necessitating a 3D LUT if gamma is to be<br>
	 *    different from 1), they cannot (before ICCv4.4) semantically signal that<br>
	 *    this is the color space that they represent. Therefore, they will<br>
	 *    typically not actually be interpreted as representing an HDR color space.<br>
	 *    This is especially detrimental to PQ which will then be interpreted as if<br>
	 *    the maximum signal value represented SDR white instead of 10000 cd/m^2,<br>
	 *    meaning that the image will be displayed two orders of magnitude (5-7 EV)<br>
	 *    too dim.<br>
	 *  - The JPEG XL image has an encoded structured color profile, and it<br>
	 *    indicates an unknown or xyb color space. In that case, @ref<br>
	 *    JxlDecoderGetColorAsICCProfile is not available.<br>
	 * When rendering an image on a system where ICC-based color management is used,<br>
	 * {@link #JxlDecoderGetColorAsICCProfile} should generally be used first as it will<br>
	 * return a ready-to-use profile (with the aforementioned caveat about HDR).<br>
	 * When knowledge about the nominal color space is desired if available, @ref<br>
	 * JxlDecoderGetColorAsEncodedProfile should be used first.<br>
	 * @param dec decoder object<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param color_encoding struct to copy the information into, or NULL to only<br>
	 *     check whether the information is available through the return value.<br>
	 * @return @ref JXL_DEC_SUCCESS if the data is available and returned, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR in<br>
	 *     case the encoded structured color profile does not exist in the<br>
	 *     codestream.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsEncodedProfile(const JxlDecoder*, JxlColorProfileTarget, JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/decode.h:724</i>
	 */
	int JxlDecoderGetColorAsEncodedProfile(PointerByReference dec, int target, JxlColorEncoding color_encoding);
	/**
	 * Outputs the size in bytes of the ICC profile returned by @ref<br>
	 * JxlDecoderGetColorAsICCProfile, if available, or indicates there is none<br>
	 * available. In most cases, the image will have an ICC profile available, but<br>
	 * if it does not, @ref JxlDecoderGetColorAsEncodedProfile must be used instead.<br>
	 * @see #JxlDecoderGetColorAsEncodedProfile for more information. The ICC<br>
	 * profile is either the exact ICC profile attached to the codestream metadata,<br>
	 * or a close approximation generated from JPEG XL encoded structured data,<br>
	 * depending of what is encoded in the codestream.<br>
	 * @param dec decoder object<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param size variable to output the size into, or NULL to only check the<br>
	 *     return status.<br>
	 * @return @ref JXL_DEC_SUCCESS if the ICC profile is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if the decoder has not yet received enough<br>
	 *     input data to determine whether an ICC profile is available or what its<br>
	 *     size is, @ref JXL_DEC_ERROR in case the ICC profile is not available and<br>
	 *     cannot be generated.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetICCProfileSize(const JxlDecoder*, JxlColorProfileTarget, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:750</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetICCProfileSize(com.sun.jna.ptr.PointerByReference, int, NativeLongByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderGetICCProfileSize(Pointer dec, int target, NativeLongByReference size);
	/**
	 * Outputs the size in bytes of the ICC profile returned by @ref<br>
	 * JxlDecoderGetColorAsICCProfile, if available, or indicates there is none<br>
	 * available. In most cases, the image will have an ICC profile available, but<br>
	 * if it does not, @ref JxlDecoderGetColorAsEncodedProfile must be used instead.<br>
	 * @see #JxlDecoderGetColorAsEncodedProfile for more information. The ICC<br>
	 * profile is either the exact ICC profile attached to the codestream metadata,<br>
	 * or a close approximation generated from JPEG XL encoded structured data,<br>
	 * depending of what is encoded in the codestream.<br>
	 * @param dec decoder object<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param size variable to output the size into, or NULL to only check the<br>
	 *     return status.<br>
	 * @return @ref JXL_DEC_SUCCESS if the ICC profile is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if the decoder has not yet received enough<br>
	 *     input data to determine whether an ICC profile is available or what its<br>
	 *     size is, @ref JXL_DEC_ERROR in case the ICC profile is not available and<br>
	 *     cannot be generated.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetICCProfileSize(const JxlDecoder*, JxlColorProfileTarget, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:750</i>
	 */
	int JxlDecoderGetICCProfileSize(PointerByReference dec, int target, NativeLongByReference size);
	/**
	 * Outputs ICC profile if available. The profile is only available if @ref<br>
	 * JxlDecoderGetICCProfileSize returns success. The output buffer must have<br>
	 * at least as many bytes as given by @ref JxlDecoderGetICCProfileSize.<br>
	 * @param dec decoder object<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param icc_profile buffer to copy the ICC profile into<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS if the profile was successfully returned is<br>
	 *     available, @ref JXL_DEC_NEED_MORE_INPUT if not yet available, @ref<br>
	 *     JXL_DEC_ERROR if the profile doesn't exist or the output size is not<br>
	 *     large enough.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsICCProfile(const JxlDecoder*, JxlColorProfileTarget, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:768</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderGetColorAsICCProfile(com.sun.jna.ptr.PointerByReference, int, java.nio.ByteBuffer, NativeLong)} and {@link #JxlDecoderGetColorAsICCProfile(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlDecoderGetColorAsICCProfile(Pointer dec, int target, Pointer icc_profile, NativeLong size);
	/**
	 * Outputs ICC profile if available. The profile is only available if @ref<br>
	 * JxlDecoderGetICCProfileSize returns success. The output buffer must have<br>
	 * at least as many bytes as given by @ref JxlDecoderGetICCProfileSize.<br>
	 * @param dec decoder object<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param icc_profile buffer to copy the ICC profile into<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS if the profile was successfully returned is<br>
	 *     available, @ref JXL_DEC_NEED_MORE_INPUT if not yet available, @ref<br>
	 *     JXL_DEC_ERROR if the profile doesn't exist or the output size is not<br>
	 *     large enough.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsICCProfile(const JxlDecoder*, JxlColorProfileTarget, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:768</i>
	 */
	int JxlDecoderGetColorAsICCProfile(PointerByReference dec, int target, ByteBuffer icc_profile, NativeLong size);
	/**
	 * Outputs ICC profile if available. The profile is only available if @ref<br>
	 * JxlDecoderGetICCProfileSize returns success. The output buffer must have<br>
	 * at least as many bytes as given by @ref JxlDecoderGetICCProfileSize.<br>
	 * @param dec decoder object<br>
	 * @param target whether to get the original color profile from the metadata<br>
	 *     or the color profile of the decoded pixels.<br>
	 * @param icc_profile buffer to copy the ICC profile into<br>
	 * @param size size of the icc_profile buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS if the profile was successfully returned is<br>
	 *     available, @ref JXL_DEC_NEED_MORE_INPUT if not yet available, @ref<br>
	 *     JXL_DEC_ERROR if the profile doesn't exist or the output size is not<br>
	 *     large enough.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetColorAsICCProfile(const JxlDecoder*, JxlColorProfileTarget, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:768</i>
	 */
	int JxlDecoderGetColorAsICCProfile(PointerByReference dec, int target, Pointer icc_profile, NativeLong size);
	/**
	 * Sets the desired output color profile of the decoded image by calling<br>
	 * @ref JxlDecoderSetOutputColorProfile, passing on @c color_encoding and<br>
	 * setting @c icc_data to NULL. See @ref JxlDecoderSetOutputColorProfile for<br>
	 * details.<br>
	 * @param dec decoder object<br>
	 * @param color_encoding the default color encoding to set<br>
	 * @return @ref JXL_DEC_SUCCESS if the preference was set successfully, @ref<br>
	 *     JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreferredColorProfile(JxlDecoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/decode.h:782</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetPreferredColorProfile(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlColorEncoding[])} and {@link #JxlDecoderSetPreferredColorProfile(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlColorEncoding)} instead
	 */
	@Deprecated 
	int JxlDecoderSetPreferredColorProfile(Pointer dec, JxlColorEncoding color_encoding);
	/**
	 * Sets the desired output color profile of the decoded image by calling<br>
	 * @ref JxlDecoderSetOutputColorProfile, passing on @c color_encoding and<br>
	 * setting @c icc_data to NULL. See @ref JxlDecoderSetOutputColorProfile for<br>
	 * details.<br>
	 * @param dec decoder object<br>
	 * @param color_encoding the default color encoding to set<br>
	 * @return @ref JXL_DEC_SUCCESS if the preference was set successfully, @ref<br>
	 *     JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreferredColorProfile(JxlDecoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/decode.h:782</i>
	 */
	int JxlDecoderSetPreferredColorProfile(PointerByReference dec, JxlColorEncoding color_encoding[]);
	/**
	 * Sets the desired output color profile of the decoded image by calling<br>
	 * @ref JxlDecoderSetOutputColorProfile, passing on @c color_encoding and<br>
	 * setting @c icc_data to NULL. See @ref JxlDecoderSetOutputColorProfile for<br>
	 * details.<br>
	 * @param dec decoder object<br>
	 * @param color_encoding the default color encoding to set<br>
	 * @return @ref JXL_DEC_SUCCESS if the preference was set successfully, @ref<br>
	 *     JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreferredColorProfile(JxlDecoder*, const JxlColorEncoding*)</code><br>
	 * <i>native declaration : jxl/decode.h:782</i>
	 */
	int JxlDecoderSetPreferredColorProfile(PointerByReference dec, JxlColorEncoding color_encoding);
	/**
	 * Requests that the decoder perform tone mapping to the peak display luminance<br>
	 * passed as @c desired_intensity_target, if appropriate.<br>
	 * @note This is provided for convenience and the exact tone mapping that is<br>
	 * performed is not meant to be considered authoritative in any way. It may<br>
	 * change from version to version.<br>
	 * @param dec decoder object<br>
	 * @param desired_intensity_target the intended target peak luminance<br>
	 * @return @ref JXL_DEC_SUCCESS if the preference was set successfully, @ref<br>
	 * JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetDesiredIntensityTarget(JxlDecoder*, float)</code><br>
	 * <i>native declaration : jxl/decode.h:795</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetDesiredIntensityTarget(com.sun.jna.ptr.PointerByReference, float)} instead
	 */
	@Deprecated 
	int JxlDecoderSetDesiredIntensityTarget(Pointer dec, float desired_intensity_target);
	/**
	 * Requests that the decoder perform tone mapping to the peak display luminance<br>
	 * passed as @c desired_intensity_target, if appropriate.<br>
	 * @note This is provided for convenience and the exact tone mapping that is<br>
	 * performed is not meant to be considered authoritative in any way. It may<br>
	 * change from version to version.<br>
	 * @param dec decoder object<br>
	 * @param desired_intensity_target the intended target peak luminance<br>
	 * @return @ref JXL_DEC_SUCCESS if the preference was set successfully, @ref<br>
	 * JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetDesiredIntensityTarget(JxlDecoder*, float)</code><br>
	 * <i>native declaration : jxl/decode.h:795</i>
	 */
	int JxlDecoderSetDesiredIntensityTarget(PointerByReference dec, float desired_intensity_target);
	/**
	 * Sets the desired output color profile of the decoded image either from a<br>
	 * color encoding or an ICC profile. Valid calls of this function have either @c<br>
	 * color_encoding or @c icc_data set to NULL and @c icc_size must be 0 if and<br>
	 * only if @c icc_data is NULL.<br>
	 * Depending on whether a color management system (CMS) has been set the<br>
	 * behavior is as follows:<br>
	 * If a color management system (CMS) has been set with @ref JxlDecoderSetCms,<br>
	 * and the CMS supports output to the desired color encoding or ICC profile,<br>
	 * then it will provide the output in that color encoding or ICC profile. If the<br>
	 * desired color encoding or the ICC is not supported, then an error will be<br>
	 * returned.<br>
	 * If no CMS has been set with @ref JxlDecoderSetCms, there are two cases:<br>
	 * (1) Calling this function with a color encoding will convert XYB images to<br>
	 * the desired color encoding. In this case, if the requested color encoding has<br>
	 * a narrower gamut, or the white points differ, then the resulting image can<br>
	 * have significant color distortion. Non-XYB images will not be converted to<br>
	 * the desired color space.<br>
	 * (2) Calling this function with an ICC profile will result in an error.<br>
	 * If called with an ICC profile (after a call to @ref JxlDecoderSetCms), the<br>
	 * ICC profile has to be a valid RGB or grayscale color profile.<br>
	 * Can only be set after the @ref JXL_DEC_COLOR_ENCODING event occurred and<br>
	 * before any other event occurred, and should be used before getting<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA.<br>
	 * This function must not be called before JxlDecoderSetCms.<br>
	 * @param dec decoder orbject<br>
	 * @param color_encoding the output color encoding<br>
	 * @param icc_data bytes of the icc profile<br>
	 * @param icc_size size of the icc profile in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS if the color profile was set successfully, @ref<br>
	 *     JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetOutputColorProfile(JxlDecoder*, const JxlColorEncoding*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:839</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetOutputColorProfile(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlColorEncoding[], byte[], NativeLong)} and {@link #JxlDecoderSetOutputColorProfile(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlColorEncoding, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlDecoderSetOutputColorProfile(Pointer dec, JxlColorEncoding color_encoding, Pointer icc_data, NativeLong icc_size);
	/**
	 * Sets the desired output color profile of the decoded image either from a<br>
	 * color encoding or an ICC profile. Valid calls of this function have either @c<br>
	 * color_encoding or @c icc_data set to NULL and @c icc_size must be 0 if and<br>
	 * only if @c icc_data is NULL.<br>
	 * Depending on whether a color management system (CMS) has been set the<br>
	 * behavior is as follows:<br>
	 * If a color management system (CMS) has been set with @ref JxlDecoderSetCms,<br>
	 * and the CMS supports output to the desired color encoding or ICC profile,<br>
	 * then it will provide the output in that color encoding or ICC profile. If the<br>
	 * desired color encoding or the ICC is not supported, then an error will be<br>
	 * returned.<br>
	 * If no CMS has been set with @ref JxlDecoderSetCms, there are two cases:<br>
	 * (1) Calling this function with a color encoding will convert XYB images to<br>
	 * the desired color encoding. In this case, if the requested color encoding has<br>
	 * a narrower gamut, or the white points differ, then the resulting image can<br>
	 * have significant color distortion. Non-XYB images will not be converted to<br>
	 * the desired color space.<br>
	 * (2) Calling this function with an ICC profile will result in an error.<br>
	 * If called with an ICC profile (after a call to @ref JxlDecoderSetCms), the<br>
	 * ICC profile has to be a valid RGB or grayscale color profile.<br>
	 * Can only be set after the @ref JXL_DEC_COLOR_ENCODING event occurred and<br>
	 * before any other event occurred, and should be used before getting<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA.<br>
	 * This function must not be called before JxlDecoderSetCms.<br>
	 * @param dec decoder orbject<br>
	 * @param color_encoding the output color encoding<br>
	 * @param icc_data bytes of the icc profile<br>
	 * @param icc_size size of the icc profile in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS if the color profile was set successfully, @ref<br>
	 *     JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetOutputColorProfile(JxlDecoder*, const JxlColorEncoding*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:839</i>
	 */
	int JxlDecoderSetOutputColorProfile(PointerByReference dec, JxlColorEncoding color_encoding[], byte icc_data[], NativeLong icc_size);
	/**
	 * Sets the desired output color profile of the decoded image either from a<br>
	 * color encoding or an ICC profile. Valid calls of this function have either @c<br>
	 * color_encoding or @c icc_data set to NULL and @c icc_size must be 0 if and<br>
	 * only if @c icc_data is NULL.<br>
	 * Depending on whether a color management system (CMS) has been set the<br>
	 * behavior is as follows:<br>
	 * If a color management system (CMS) has been set with @ref JxlDecoderSetCms,<br>
	 * and the CMS supports output to the desired color encoding or ICC profile,<br>
	 * then it will provide the output in that color encoding or ICC profile. If the<br>
	 * desired color encoding or the ICC is not supported, then an error will be<br>
	 * returned.<br>
	 * If no CMS has been set with @ref JxlDecoderSetCms, there are two cases:<br>
	 * (1) Calling this function with a color encoding will convert XYB images to<br>
	 * the desired color encoding. In this case, if the requested color encoding has<br>
	 * a narrower gamut, or the white points differ, then the resulting image can<br>
	 * have significant color distortion. Non-XYB images will not be converted to<br>
	 * the desired color space.<br>
	 * (2) Calling this function with an ICC profile will result in an error.<br>
	 * If called with an ICC profile (after a call to @ref JxlDecoderSetCms), the<br>
	 * ICC profile has to be a valid RGB or grayscale color profile.<br>
	 * Can only be set after the @ref JXL_DEC_COLOR_ENCODING event occurred and<br>
	 * before any other event occurred, and should be used before getting<br>
	 * JXL_COLOR_PROFILE_TARGET_DATA.<br>
	 * This function must not be called before JxlDecoderSetCms.<br>
	 * @param dec decoder orbject<br>
	 * @param color_encoding the output color encoding<br>
	 * @param icc_data bytes of the icc profile<br>
	 * @param icc_size size of the icc profile in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS if the color profile was set successfully, @ref<br>
	 *     JXL_DEC_ERROR otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetOutputColorProfile(JxlDecoder*, const JxlColorEncoding*, const uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:839</i>
	 */
	int JxlDecoderSetOutputColorProfile(PointerByReference dec, JxlColorEncoding color_encoding, Pointer icc_data, NativeLong icc_size);
	/**
	 * Sets the color management system (CMS) that will be used for color<br>
	 * conversion (if applicable) during decoding. May only be set before starting<br>
	 * decoding and must not be called after @ref JxlDecoderSetOutputColorProfile.<br>
	 * See @ref JxlDecoderSetOutputColorProfile for how color conversions are done<br>
	 * depending on whether or not a CMS has been set with @ref JxlDecoderSetCms.<br>
	 * @param dec decoder object.<br>
	 * @param cms structure representing a CMS implementation. See @ref<br>
	 * JxlCmsInterface for more details.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetCms(JxlDecoder*, JxlCmsInterface)</code><br>
	 * <i>native declaration : jxl/decode.h:855</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetCms(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlCmsInterface)} instead
	 */
	@Deprecated 
	int JxlDecoderSetCms(Pointer dec, JxlCmsInterface cms);
	/**
	 * Sets the color management system (CMS) that will be used for color<br>
	 * conversion (if applicable) during decoding. May only be set before starting<br>
	 * decoding and must not be called after @ref JxlDecoderSetOutputColorProfile.<br>
	 * See @ref JxlDecoderSetOutputColorProfile for how color conversions are done<br>
	 * depending on whether or not a CMS has been set with @ref JxlDecoderSetCms.<br>
	 * @param dec decoder object.<br>
	 * @param cms structure representing a CMS implementation. See @ref<br>
	 * JxlCmsInterface for more details.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetCms(JxlDecoder*, JxlCmsInterface)</code><br>
	 * <i>native declaration : jxl/decode.h:855</i>
	 */
	int JxlDecoderSetCms(PointerByReference dec, JxlCmsInterface cms);
	/**
	 * Returns the minimum size in bytes of the preview image output pixel buffer<br>
	 * for the given format. This is the buffer for @ref<br>
	 * JxlDecoderSetPreviewOutBuffer. Requires the preview header information is<br>
	 * available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderPreviewOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:872</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderPreviewOutBufferSize(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], NativeLongByReference)} and {@link #JxlDecoderPreviewOutBufferSize(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, NativeLongByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderPreviewOutBufferSize(Pointer dec, JxlPixelFormat format, NativeLongByReference size);
	/**
	 * Returns the minimum size in bytes of the preview image output pixel buffer<br>
	 * for the given format. This is the buffer for @ref<br>
	 * JxlDecoderSetPreviewOutBuffer. Requires the preview header information is<br>
	 * available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderPreviewOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:872</i>
	 */
	int JxlDecoderPreviewOutBufferSize(PointerByReference dec, JxlPixelFormat format[], NativeLongByReference size);
	/**
	 * Returns the minimum size in bytes of the preview image output pixel buffer<br>
	 * for the given format. This is the buffer for @ref<br>
	 * JxlDecoderSetPreviewOutBuffer. Requires the preview header information is<br>
	 * available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderPreviewOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:872</i>
	 */
	int JxlDecoderPreviewOutBufferSize(PointerByReference dec, JxlPixelFormat format, NativeLongByReference size);
	/**
	 * Sets the buffer to write the small resolution preview image<br>
	 * to. The size of the buffer must be at least as large as given by @ref<br>
	 * JxlDecoderPreviewOutBufferSize. The buffer follows the format described<br>
	 * by JxlPixelFormat. The preview image dimensions are given by the<br>
	 * JxlPreviewHeader. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels. Object owned by user and its contents are<br>
	 *     copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreviewOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:890</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetPreviewOutBuffer(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], com.sun.jna.Pointer, NativeLong)} and {@link #JxlDecoderSetPreviewOutBuffer(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlDecoderSetPreviewOutBuffer(Pointer dec, JxlPixelFormat format, Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to write the small resolution preview image<br>
	 * to. The size of the buffer must be at least as large as given by @ref<br>
	 * JxlDecoderPreviewOutBufferSize. The buffer follows the format described<br>
	 * by JxlPixelFormat. The preview image dimensions are given by the<br>
	 * JxlPreviewHeader. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels. Object owned by user and its contents are<br>
	 *     copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreviewOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:890</i>
	 */
	int JxlDecoderSetPreviewOutBuffer(PointerByReference dec, JxlPixelFormat format[], Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to write the small resolution preview image<br>
	 * to. The size of the buffer must be at least as large as given by @ref<br>
	 * JxlDecoderPreviewOutBufferSize. The buffer follows the format described<br>
	 * by JxlPixelFormat. The preview image dimensions are given by the<br>
	 * JxlPreviewHeader. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of pixels. Object owned by user and its contents are<br>
	 *     copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetPreviewOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:890</i>
	 */
	int JxlDecoderSetPreviewOutBuffer(PointerByReference dec, JxlPixelFormat format, Pointer buffer, NativeLong size);
	/**
	 * Outputs the information from the frame, such as duration when have_animation.<br>
	 * This function can be called when @ref JXL_DEC_FRAME occurred for the current<br>
	 * frame, even when have_animation in the JxlBasicInfo is JXL_FALSE.<br>
	 * @param dec decoder object<br>
	 * @param header struct to copy the information into, or NULL to only check<br>
	 *     whether the information is available through the return value.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR in<br>
	 *     case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameHeader(const JxlDecoder*, JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/decode.h:905</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetFrameHeader(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlFrameHeader)} instead
	 */
	@Deprecated 
	int JxlDecoderGetFrameHeader(Pointer dec, JxlFrameHeader header);
	/**
	 * Outputs the information from the frame, such as duration when have_animation.<br>
	 * This function can be called when @ref JXL_DEC_FRAME occurred for the current<br>
	 * frame, even when have_animation in the JxlBasicInfo is JXL_FALSE.<br>
	 * @param dec decoder object<br>
	 * @param header struct to copy the information into, or NULL to only check<br>
	 *     whether the information is available through the return value.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR in<br>
	 *     case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameHeader(const JxlDecoder*, JxlFrameHeader*)</code><br>
	 * <i>native declaration : jxl/decode.h:905</i>
	 */
	int JxlDecoderGetFrameHeader(PointerByReference dec, JxlFrameHeader header);
	/**
	 * Outputs name for the current frame. The buffer for name must have at least<br>
	 * name_length + 1 bytes allocated, gotten from the associated JxlFrameHeader.<br>
	 * @param dec decoder object<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes, including zero termination<br>
	 *    character, so this must be at least JxlFrameHeader.name_length + 1.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR in<br>
	 *     case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameName(const JxlDecoder*, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:920</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderGetFrameName(com.sun.jna.ptr.PointerByReference, java.nio.ByteBuffer, NativeLong)} and {@link #JxlDecoderGetFrameName(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlDecoderGetFrameName(Pointer dec, Pointer name, NativeLong size);
	/**
	 * Outputs name for the current frame. The buffer for name must have at least<br>
	 * name_length + 1 bytes allocated, gotten from the associated JxlFrameHeader.<br>
	 * @param dec decoder object<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes, including zero termination<br>
	 *    character, so this must be at least JxlFrameHeader.name_length + 1.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR in<br>
	 *     case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameName(const JxlDecoder*, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:920</i>
	 */
	int JxlDecoderGetFrameName(PointerByReference dec, ByteBuffer name, NativeLong size);
	/**
	 * Outputs name for the current frame. The buffer for name must have at least<br>
	 * name_length + 1 bytes allocated, gotten from the associated JxlFrameHeader.<br>
	 * @param dec decoder object<br>
	 * @param name buffer to copy the name into<br>
	 * @param size size of the name buffer in bytes, including zero termination<br>
	 *    character, so this must be at least JxlFrameHeader.name_length + 1.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref<br>
	 *     JXL_DEC_NEED_MORE_INPUT if not yet available, @ref JXL_DEC_ERROR in<br>
	 *     case of other error conditions.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetFrameName(const JxlDecoder*, char*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:920</i>
	 */
	int JxlDecoderGetFrameName(PointerByReference dec, Pointer name, NativeLong size);
	/**
	 * Outputs the blend information for the current frame for a specific extra<br>
	 * channel. This function can be called when @ref JXL_DEC_FRAME occurred for the<br>
	 * current frame, even when have_animation in the JxlBasicInfo is JXL_FALSE.<br>
	 * This information is only useful if coalescing is disabled; otherwise the<br>
	 * decoder will have performed blending already.<br>
	 * @param dec decoder object<br>
	 * @param index the index of the extra channel<br>
	 * @param blend_info struct to copy the information into<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelBlendInfo(const JxlDecoder*, size_t, JxlBlendInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:935</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetExtraChannelBlendInfo(com.sun.jna.ptr.PointerByReference, NativeLong, vavi.awt.image.jna.jpegxl.JxlBlendInfo)} instead
	 */
	@Deprecated 
	int JxlDecoderGetExtraChannelBlendInfo(Pointer dec, NativeLong index, JxlBlendInfo blend_info);
	/**
	 * Outputs the blend information for the current frame for a specific extra<br>
	 * channel. This function can be called when @ref JXL_DEC_FRAME occurred for the<br>
	 * current frame, even when have_animation in the JxlBasicInfo is JXL_FALSE.<br>
	 * This information is only useful if coalescing is disabled; otherwise the<br>
	 * decoder will have performed blending already.<br>
	 * @param dec decoder object<br>
	 * @param index the index of the extra channel<br>
	 * @param blend_info struct to copy the information into<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetExtraChannelBlendInfo(const JxlDecoder*, size_t, JxlBlendInfo*)</code><br>
	 * <i>native declaration : jxl/decode.h:935</i>
	 */
	int JxlDecoderGetExtraChannelBlendInfo(PointerByReference dec, NativeLong index, JxlBlendInfo blend_info);
	/**
	 * Returns the minimum size in bytes of the image output pixel buffer for the<br>
	 * given format. This is the buffer for @ref JxlDecoderSetImageOutBuffer.<br>
	 * Requires that the basic image information is available in the decoder in the<br>
	 * case of coalescing enabled (default). In case coalescing is disabled, this<br>
	 * can only be called after the @ref JXL_DEC_FRAME event occurs. In that case,<br>
	 * it will return the size required to store the possibly cropped frame (which<br>
	 * can be larger or smaller than the image dimensions).<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderImageOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:953</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderImageOutBufferSize(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], NativeLongByReference)} and {@link #JxlDecoderImageOutBufferSize(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, NativeLongByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderImageOutBufferSize(Pointer dec, JxlPixelFormat format, NativeLongByReference size);
	/**
	 * Returns the minimum size in bytes of the image output pixel buffer for the<br>
	 * given format. This is the buffer for @ref JxlDecoderSetImageOutBuffer.<br>
	 * Requires that the basic image information is available in the decoder in the<br>
	 * case of coalescing enabled (default). In case coalescing is disabled, this<br>
	 * can only be called after the @ref JXL_DEC_FRAME event occurs. In that case,<br>
	 * it will return the size required to store the possibly cropped frame (which<br>
	 * can be larger or smaller than the image dimensions).<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderImageOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:953</i>
	 */
	int JxlDecoderImageOutBufferSize(PointerByReference dec, JxlPixelFormat format[], NativeLongByReference size);
	/**
	 * Returns the minimum size in bytes of the image output pixel buffer for the<br>
	 * given format. This is the buffer for @ref JxlDecoderSetImageOutBuffer.<br>
	 * Requires that the basic image information is available in the decoder in the<br>
	 * case of coalescing enabled (default). In case coalescing is disabled, this<br>
	 * can only be called after the @ref JXL_DEC_FRAME event occurs. In that case,<br>
	 * it will return the size required to store the possibly cropped frame (which<br>
	 * can be larger or smaller than the image dimensions).<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     information not available yet.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderImageOutBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:953</i>
	 */
	int JxlDecoderImageOutBufferSize(PointerByReference dec, JxlPixelFormat format, NativeLongByReference size);
	/**
	 * Sets the buffer to write the full resolution image to. This can be set when<br>
	 * the @ref JXL_DEC_FRAME event occurs, must be set when the @ref<br>
	 * JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and applies only for the<br>
	 * current frame. The size of the buffer must be at least as large as given<br>
	 * by @ref JxlDecoderImageOutBufferSize. The buffer follows the format described<br>
	 * by JxlPixelFormat. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 *     are copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:972</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetImageOutBuffer(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], com.sun.jna.Pointer, NativeLong)} and {@link #JxlDecoderSetImageOutBuffer(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlDecoderSetImageOutBuffer(Pointer dec, JxlPixelFormat format, Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to write the full resolution image to. This can be set when<br>
	 * the @ref JXL_DEC_FRAME event occurs, must be set when the @ref<br>
	 * JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and applies only for the<br>
	 * current frame. The size of the buffer must be at least as large as given<br>
	 * by @ref JxlDecoderImageOutBufferSize. The buffer follows the format described<br>
	 * by JxlPixelFormat. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 *     are copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:972</i>
	 */
	int JxlDecoderSetImageOutBuffer(PointerByReference dec, JxlPixelFormat format[], Pointer buffer, NativeLong size);
	/**
	 * Sets the buffer to write the full resolution image to. This can be set when<br>
	 * the @ref JXL_DEC_FRAME event occurs, must be set when the @ref<br>
	 * JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and applies only for the<br>
	 * current frame. The size of the buffer must be at least as large as given<br>
	 * by @ref JxlDecoderImageOutBufferSize. The buffer follows the format described<br>
	 * by JxlPixelFormat. The buffer is owned by the caller.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 *     are copied internally.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     size too small.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:972</i>
	 */
	int JxlDecoderSetImageOutBuffer(PointerByReference dec, JxlPixelFormat format, Pointer buffer, NativeLong size);
	/**
	 * Sets pixel output callback. This is an alternative to @ref<br>
	 * JxlDecoderSetImageOutBuffer. This can be set when the @ref JXL_DEC_FRAME<br>
	 * event occurs, must be set when the @ref JXL_DEC_NEED_IMAGE_OUT_BUFFER event<br>
	 * occurs, and applies only for the current frame. Only one of @ref<br>
	 * JxlDecoderSetImageOutBuffer or @ref JxlDecoderSetImageOutCallback may be used<br>
	 * for the same frame, not both at the same time.<br>
	 * The callback will be called multiple times, to receive the image<br>
	 * data in small chunks. The callback receives a horizontal stripe of pixel<br>
	 * data, 1 pixel high, xsize pixels wide, called a scanline. The xsize here is<br>
	 * not the same as the full image width, the scanline may be a partial section,<br>
	 * and xsize may differ between calls. The user can then process and/or copy the<br>
	 * partial scanline to an image buffer. The callback may be called<br>
	 * simultaneously by different threads when using a threaded parallel runner, on<br>
	 * different pixels.<br>
	 * If @ref JxlDecoderFlushImage is not used, then each pixel will be visited<br>
	 * exactly once by the different callback calls, during processing with one or<br>
	 * more @ref JxlDecoderProcessInput calls. These pixels are decoded to full<br>
	 * detail, they are not part of a lower resolution or lower quality progressive<br>
	 * pass, but the final pass.<br>
	 * If @ref JxlDecoderFlushImage is used, then in addition each pixel will be<br>
	 * visited zero or one times during the blocking @ref JxlDecoderFlushImage call.<br>
	 * Pixels visited as a result of @ref JxlDecoderFlushImage may represent a lower<br>
	 * resolution or lower quality intermediate progressive pass of the image. Any<br>
	 * visited pixel will be of a quality at least as good or better than previous<br>
	 * visits of this pixel. A pixel may be visited zero times if it cannot be<br>
	 * decoded yet or if it was already decoded to full precision (this behavior is<br>
	 * not guaranteed).<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user; its contents are<br>
	 *     copied internally.<br>
	 * @param callback the callback function receiving partial scanlines of pixel<br>
	 *     data.<br>
	 * @param opaque optional user data, which will be passed on to the callback,<br>
	 *     may be NULL.<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such<br>
	 *     as @ref JxlDecoderSetImageOutBuffer already set.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutCallback(JxlDecoder*, const JxlPixelFormat*, JxlImageOutCallback, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:1080</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetImageOutCallback(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], vavi.awt.image.jna.jpegxl.decode.DecodeLibrary.JxlImageOutCallback, com.sun.jna.Pointer)} and {@link #JxlDecoderSetImageOutCallback(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, vavi.awt.image.jna.jpegxl.decode.DecodeLibrary.JxlImageOutCallback, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlDecoderSetImageOutCallback(Pointer dec, JxlPixelFormat format, DecodeLibrary.JxlImageOutCallback callback, Pointer opaque);
	/**
	 * Sets pixel output callback. This is an alternative to @ref<br>
	 * JxlDecoderSetImageOutBuffer. This can be set when the @ref JXL_DEC_FRAME<br>
	 * event occurs, must be set when the @ref JXL_DEC_NEED_IMAGE_OUT_BUFFER event<br>
	 * occurs, and applies only for the current frame. Only one of @ref<br>
	 * JxlDecoderSetImageOutBuffer or @ref JxlDecoderSetImageOutCallback may be used<br>
	 * for the same frame, not both at the same time.<br>
	 * The callback will be called multiple times, to receive the image<br>
	 * data in small chunks. The callback receives a horizontal stripe of pixel<br>
	 * data, 1 pixel high, xsize pixels wide, called a scanline. The xsize here is<br>
	 * not the same as the full image width, the scanline may be a partial section,<br>
	 * and xsize may differ between calls. The user can then process and/or copy the<br>
	 * partial scanline to an image buffer. The callback may be called<br>
	 * simultaneously by different threads when using a threaded parallel runner, on<br>
	 * different pixels.<br>
	 * If @ref JxlDecoderFlushImage is not used, then each pixel will be visited<br>
	 * exactly once by the different callback calls, during processing with one or<br>
	 * more @ref JxlDecoderProcessInput calls. These pixels are decoded to full<br>
	 * detail, they are not part of a lower resolution or lower quality progressive<br>
	 * pass, but the final pass.<br>
	 * If @ref JxlDecoderFlushImage is used, then in addition each pixel will be<br>
	 * visited zero or one times during the blocking @ref JxlDecoderFlushImage call.<br>
	 * Pixels visited as a result of @ref JxlDecoderFlushImage may represent a lower<br>
	 * resolution or lower quality intermediate progressive pass of the image. Any<br>
	 * visited pixel will be of a quality at least as good or better than previous<br>
	 * visits of this pixel. A pixel may be visited zero times if it cannot be<br>
	 * decoded yet or if it was already decoded to full precision (this behavior is<br>
	 * not guaranteed).<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user; its contents are<br>
	 *     copied internally.<br>
	 * @param callback the callback function receiving partial scanlines of pixel<br>
	 *     data.<br>
	 * @param opaque optional user data, which will be passed on to the callback,<br>
	 *     may be NULL.<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such<br>
	 *     as @ref JxlDecoderSetImageOutBuffer already set.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutCallback(JxlDecoder*, const JxlPixelFormat*, JxlImageOutCallback, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:1080</i>
	 */
	int JxlDecoderSetImageOutCallback(PointerByReference dec, JxlPixelFormat format[], DecodeLibrary.JxlImageOutCallback callback, Pointer opaque);
	/**
	 * Sets pixel output callback. This is an alternative to @ref<br>
	 * JxlDecoderSetImageOutBuffer. This can be set when the @ref JXL_DEC_FRAME<br>
	 * event occurs, must be set when the @ref JXL_DEC_NEED_IMAGE_OUT_BUFFER event<br>
	 * occurs, and applies only for the current frame. Only one of @ref<br>
	 * JxlDecoderSetImageOutBuffer or @ref JxlDecoderSetImageOutCallback may be used<br>
	 * for the same frame, not both at the same time.<br>
	 * The callback will be called multiple times, to receive the image<br>
	 * data in small chunks. The callback receives a horizontal stripe of pixel<br>
	 * data, 1 pixel high, xsize pixels wide, called a scanline. The xsize here is<br>
	 * not the same as the full image width, the scanline may be a partial section,<br>
	 * and xsize may differ between calls. The user can then process and/or copy the<br>
	 * partial scanline to an image buffer. The callback may be called<br>
	 * simultaneously by different threads when using a threaded parallel runner, on<br>
	 * different pixels.<br>
	 * If @ref JxlDecoderFlushImage is not used, then each pixel will be visited<br>
	 * exactly once by the different callback calls, during processing with one or<br>
	 * more @ref JxlDecoderProcessInput calls. These pixels are decoded to full<br>
	 * detail, they are not part of a lower resolution or lower quality progressive<br>
	 * pass, but the final pass.<br>
	 * If @ref JxlDecoderFlushImage is used, then in addition each pixel will be<br>
	 * visited zero or one times during the blocking @ref JxlDecoderFlushImage call.<br>
	 * Pixels visited as a result of @ref JxlDecoderFlushImage may represent a lower<br>
	 * resolution or lower quality intermediate progressive pass of the image. Any<br>
	 * visited pixel will be of a quality at least as good or better than previous<br>
	 * visits of this pixel. A pixel may be visited zero times if it cannot be<br>
	 * decoded yet or if it was already decoded to full precision (this behavior is<br>
	 * not guaranteed).<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user; its contents are<br>
	 *     copied internally.<br>
	 * @param callback the callback function receiving partial scanlines of pixel<br>
	 *     data.<br>
	 * @param opaque optional user data, which will be passed on to the callback,<br>
	 *     may be NULL.<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such<br>
	 *     as @ref JxlDecoderSetImageOutBuffer already set.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutCallback(JxlDecoder*, const JxlPixelFormat*, JxlImageOutCallback, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:1080</i>
	 */
	int JxlDecoderSetImageOutCallback(PointerByReference dec, JxlPixelFormat format, DecodeLibrary.JxlImageOutCallback callback, Pointer opaque);
	/**
	 * Similar to @ref JxlDecoderSetImageOutCallback except that the callback is<br>
	 * allowed an initialization phase during which it is informed of how many<br>
	 * threads will call it concurrently, and those calls are further informed of<br>
	 * which thread they are occurring in.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user; its contents are<br>
	 *     copied internally.<br>
	 * @param init_callback initialization callback.<br>
	 * @param run_callback the callback function receiving partial scanlines of<br>
	 *     pixel data.<br>
	 * @param destroy_callback clean-up callback invoked after all calls to @c<br>
	 *     run_callback. May be NULL if no clean-up is necessary.<br>
	 * @param init_opaque optional user data passed to @c init_callback, may be NULL<br>
	 *     (unlike the return value from @c init_callback which may only be NULL if<br>
	 *     initialization failed).<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such<br>
	 *     as @ref JxlDecoderSetImageOutBuffer having already been called.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetMultithreadedImageOutCallback(JxlDecoder*, const JxlPixelFormat*, JxlImageOutInitCallback, JxlImageOutRunCallback, JxlImageOutDestroyCallback, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:1103</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetMultithreadedImageOutCallback(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], vavi.awt.image.jna.jpegxl.decode.DecodeLibrary.JxlImageOutInitCallback, vavi.awt.image.jna.jpegxl.decode.DecodeLibrary.JxlImageOutRunCallback, vavi.awt.image.jna.jpegxl.decode.DecodeLibrary.JxlImageOutDestroyCallback, com.sun.jna.Pointer)} and {@link #JxlDecoderSetMultithreadedImageOutCallback(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, vavi.awt.image.jna.jpegxl.decode.DecodeLibrary.JxlImageOutInitCallback, vavi.awt.image.jna.jpegxl.decode.DecodeLibrary.JxlImageOutRunCallback, vavi.awt.image.jna.jpegxl.decode.DecodeLibrary.JxlImageOutDestroyCallback, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int JxlDecoderSetMultithreadedImageOutCallback(Pointer dec, JxlPixelFormat format, DecodeLibrary.JxlImageOutInitCallback init_callback, DecodeLibrary.JxlImageOutRunCallback run_callback, DecodeLibrary.JxlImageOutDestroyCallback destroy_callback, Pointer init_opaque);
	/**
	 * Similar to @ref JxlDecoderSetImageOutCallback except that the callback is<br>
	 * allowed an initialization phase during which it is informed of how many<br>
	 * threads will call it concurrently, and those calls are further informed of<br>
	 * which thread they are occurring in.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user; its contents are<br>
	 *     copied internally.<br>
	 * @param init_callback initialization callback.<br>
	 * @param run_callback the callback function receiving partial scanlines of<br>
	 *     pixel data.<br>
	 * @param destroy_callback clean-up callback invoked after all calls to @c<br>
	 *     run_callback. May be NULL if no clean-up is necessary.<br>
	 * @param init_opaque optional user data passed to @c init_callback, may be NULL<br>
	 *     (unlike the return value from @c init_callback which may only be NULL if<br>
	 *     initialization failed).<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such<br>
	 *     as @ref JxlDecoderSetImageOutBuffer having already been called.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetMultithreadedImageOutCallback(JxlDecoder*, const JxlPixelFormat*, JxlImageOutInitCallback, JxlImageOutRunCallback, JxlImageOutDestroyCallback, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:1103</i>
	 */
	int JxlDecoderSetMultithreadedImageOutCallback(PointerByReference dec, JxlPixelFormat format[], DecodeLibrary.JxlImageOutInitCallback init_callback, DecodeLibrary.JxlImageOutRunCallback run_callback, DecodeLibrary.JxlImageOutDestroyCallback destroy_callback, Pointer init_opaque);
	/**
	 * Similar to @ref JxlDecoderSetImageOutCallback except that the callback is<br>
	 * allowed an initialization phase during which it is informed of how many<br>
	 * threads will call it concurrently, and those calls are further informed of<br>
	 * which thread they are occurring in.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user; its contents are<br>
	 *     copied internally.<br>
	 * @param init_callback initialization callback.<br>
	 * @param run_callback the callback function receiving partial scanlines of<br>
	 *     pixel data.<br>
	 * @param destroy_callback clean-up callback invoked after all calls to @c<br>
	 *     run_callback. May be NULL if no clean-up is necessary.<br>
	 * @param init_opaque optional user data passed to @c init_callback, may be NULL<br>
	 *     (unlike the return value from @c init_callback which may only be NULL if<br>
	 *     initialization failed).<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such<br>
	 *     as @ref JxlDecoderSetImageOutBuffer having already been called.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetMultithreadedImageOutCallback(JxlDecoder*, const JxlPixelFormat*, JxlImageOutInitCallback, JxlImageOutRunCallback, JxlImageOutDestroyCallback, void*)</code><br>
	 * <i>native declaration : jxl/decode.h:1103</i>
	 */
	int JxlDecoderSetMultithreadedImageOutCallback(PointerByReference dec, JxlPixelFormat format, DecodeLibrary.JxlImageOutInitCallback init_callback, DecodeLibrary.JxlImageOutRunCallback run_callback, DecodeLibrary.JxlImageOutDestroyCallback destroy_callback, Pointer init_opaque);
	/**
	 * Returns the minimum size in bytes of an extra channel pixel buffer for the<br>
	 * given format. This is the buffer for @ref JxlDecoderSetExtraChannelBuffer.<br>
	 * Requires the basic image information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. The num_channels value is ignored and is<br>
	 *     always treated to be 1.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @param index which extra channel to get, matching the index used in @ref<br>
	 *     JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in<br>
	 *     the associated JxlBasicInfo.<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     information not available yet or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderExtraChannelBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1123</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderExtraChannelBufferSize(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], NativeLongByReference, int)} and {@link #JxlDecoderExtraChannelBufferSize(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, NativeLongByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderExtraChannelBufferSize(Pointer dec, JxlPixelFormat format, NativeLongByReference size, int index);
	/**
	 * Returns the minimum size in bytes of an extra channel pixel buffer for the<br>
	 * given format. This is the buffer for @ref JxlDecoderSetExtraChannelBuffer.<br>
	 * Requires the basic image information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. The num_channels value is ignored and is<br>
	 *     always treated to be 1.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @param index which extra channel to get, matching the index used in @ref<br>
	 *     JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in<br>
	 *     the associated JxlBasicInfo.<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     information not available yet or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderExtraChannelBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1123</i>
	 */
	int JxlDecoderExtraChannelBufferSize(PointerByReference dec, JxlPixelFormat format[], NativeLongByReference size, int index);
	/**
	 * Returns the minimum size in bytes of an extra channel pixel buffer for the<br>
	 * given format. This is the buffer for @ref JxlDecoderSetExtraChannelBuffer.<br>
	 * Requires the basic image information is available in the decoder.<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. The num_channels value is ignored and is<br>
	 *     always treated to be 1.<br>
	 * @param size output value, buffer size in bytes<br>
	 * @param index which extra channel to get, matching the index used in @ref<br>
	 *     JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in<br>
	 *     the associated JxlBasicInfo.<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     information not available yet or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderExtraChannelBufferSize(const JxlDecoder*, const JxlPixelFormat*, size_t*, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1123</i>
	 */
	int JxlDecoderExtraChannelBufferSize(PointerByReference dec, JxlPixelFormat format, NativeLongByReference size, int index);
	/**
	 * Sets the buffer to write an extra channel to. This can be set when<br>
	 * the @ref JXL_DEC_FRAME or @ref JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs,<br>
	 * and applies only for the current frame. The size of the buffer must be at<br>
	 * least as large as given by @ref JxlDecoderExtraChannelBufferSize. The buffer<br>
	 * follows the format described by JxlPixelFormat, but where num_channels is 1.<br>
	 * The buffer is owned by the caller. The amount of extra channels is given by<br>
	 * the num_extra_channels field in the associated JxlBasicInfo, and the<br>
	 * information of individual extra channels can be queried with @ref<br>
	 * JxlDecoderGetExtraChannelInfo. To get multiple extra channels, this function<br>
	 * must be called multiple times, once for each wanted index. Not all images<br>
	 * have extra channels. The alpha channel is an extra channel and can be gotten<br>
	 * as part of the color channels when using an RGBA pixel buffer with @ref<br>
	 * JxlDecoderSetImageOutBuffer, but additionally also can be gotten<br>
	 * separately as extra channel. The color channels themselves cannot be gotten<br>
	 * this way.<br>
	 * *<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 *     are copied internally. The num_channels value is ignored and is always<br>
	 *     treated to be 1.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @param index which extra channel to get, matching the index used in @ref<br>
	 *     JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in<br>
	 *     the associated JxlBasicInfo.<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     size too small or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetExtraChannelBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1157</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetExtraChannelBuffer(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat[], com.sun.jna.Pointer, NativeLong, int)} and {@link #JxlDecoderSetExtraChannelBuffer(com.sun.jna.ptr.PointerByReference, vavi.awt.image.jna.jpegxl.JxlPixelFormat, com.sun.jna.Pointer, NativeLong, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetExtraChannelBuffer(Pointer dec, JxlPixelFormat format, Pointer buffer, NativeLong size, int index);
	/**
	 * Sets the buffer to write an extra channel to. This can be set when<br>
	 * the @ref JXL_DEC_FRAME or @ref JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs,<br>
	 * and applies only for the current frame. The size of the buffer must be at<br>
	 * least as large as given by @ref JxlDecoderExtraChannelBufferSize. The buffer<br>
	 * follows the format described by JxlPixelFormat, but where num_channels is 1.<br>
	 * The buffer is owned by the caller. The amount of extra channels is given by<br>
	 * the num_extra_channels field in the associated JxlBasicInfo, and the<br>
	 * information of individual extra channels can be queried with @ref<br>
	 * JxlDecoderGetExtraChannelInfo. To get multiple extra channels, this function<br>
	 * must be called multiple times, once for each wanted index. Not all images<br>
	 * have extra channels. The alpha channel is an extra channel and can be gotten<br>
	 * as part of the color channels when using an RGBA pixel buffer with @ref<br>
	 * JxlDecoderSetImageOutBuffer, but additionally also can be gotten<br>
	 * separately as extra channel. The color channels themselves cannot be gotten<br>
	 * this way.<br>
	 * *<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 *     are copied internally. The num_channels value is ignored and is always<br>
	 *     treated to be 1.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @param index which extra channel to get, matching the index used in @ref<br>
	 *     JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in<br>
	 *     the associated JxlBasicInfo.<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     size too small or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetExtraChannelBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1157</i>
	 */
	int JxlDecoderSetExtraChannelBuffer(PointerByReference dec, JxlPixelFormat format[], Pointer buffer, NativeLong size, int index);
	/**
	 * Sets the buffer to write an extra channel to. This can be set when<br>
	 * the @ref JXL_DEC_FRAME or @ref JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs,<br>
	 * and applies only for the current frame. The size of the buffer must be at<br>
	 * least as large as given by @ref JxlDecoderExtraChannelBufferSize. The buffer<br>
	 * follows the format described by JxlPixelFormat, but where num_channels is 1.<br>
	 * The buffer is owned by the caller. The amount of extra channels is given by<br>
	 * the num_extra_channels field in the associated JxlBasicInfo, and the<br>
	 * information of individual extra channels can be queried with @ref<br>
	 * JxlDecoderGetExtraChannelInfo. To get multiple extra channels, this function<br>
	 * must be called multiple times, once for each wanted index. Not all images<br>
	 * have extra channels. The alpha channel is an extra channel and can be gotten<br>
	 * as part of the color channels when using an RGBA pixel buffer with @ref<br>
	 * JxlDecoderSetImageOutBuffer, but additionally also can be gotten<br>
	 * separately as extra channel. The color channels themselves cannot be gotten<br>
	 * this way.<br>
	 * *<br>
	 * @param dec decoder object<br>
	 * @param format format of the pixels. Object owned by user and its contents<br>
	 *     are copied internally. The num_channels value is ignored and is always<br>
	 *     treated to be 1.<br>
	 * @param buffer buffer type to output the pixel data to<br>
	 * @param size size of buffer in bytes<br>
	 * @param index which extra channel to get, matching the index used in @ref<br>
	 *     JxlDecoderGetExtraChannelInfo. Must be smaller than num_extra_channels in<br>
	 *     the associated JxlBasicInfo.<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     size too small or invalid index.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetExtraChannelBuffer(JxlDecoder*, const JxlPixelFormat*, void*, size_t, uint32_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1157</i>
	 */
	int JxlDecoderSetExtraChannelBuffer(PointerByReference dec, JxlPixelFormat format, Pointer buffer, NativeLong size, int index);
	/**
	 * Sets output buffer for reconstructed JPEG codestream.<br>
	 * The data is owned by the caller and may be used by the decoder until @ref<br>
	 * JxlDecoderReleaseJPEGBuffer is called or the decoder is destroyed or<br>
	 * reset so must be kept alive until then.<br>
	 * If a JPEG buffer was set before and released with @ref<br>
	 * JxlDecoderReleaseJPEGBuffer, bytes that the decoder has already output<br>
	 * should not be included, only the remaining bytes output must be set.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to write to<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return @ref JXL_DEC_ERROR if output buffer was already set and @ref<br>
	 *     JxlDecoderReleaseJPEGBuffer was not called on it, @ref JXL_DEC_SUCCESS<br>
	 *     otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetJPEGBuffer(JxlDecoder*, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1179</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetJPEGBuffer(com.sun.jna.ptr.PointerByReference, java.nio.ByteBuffer, NativeLong)} and {@link #JxlDecoderSetJPEGBuffer(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlDecoderSetJPEGBuffer(Pointer dec, Pointer data, NativeLong size);
	/**
	 * Sets output buffer for reconstructed JPEG codestream.<br>
	 * The data is owned by the caller and may be used by the decoder until @ref<br>
	 * JxlDecoderReleaseJPEGBuffer is called or the decoder is destroyed or<br>
	 * reset so must be kept alive until then.<br>
	 * If a JPEG buffer was set before and released with @ref<br>
	 * JxlDecoderReleaseJPEGBuffer, bytes that the decoder has already output<br>
	 * should not be included, only the remaining bytes output must be set.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to write to<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return @ref JXL_DEC_ERROR if output buffer was already set and @ref<br>
	 *     JxlDecoderReleaseJPEGBuffer was not called on it, @ref JXL_DEC_SUCCESS<br>
	 *     otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetJPEGBuffer(JxlDecoder*, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1179</i>
	 */
	int JxlDecoderSetJPEGBuffer(PointerByReference dec, ByteBuffer data, NativeLong size);
	/**
	 * Sets output buffer for reconstructed JPEG codestream.<br>
	 * The data is owned by the caller and may be used by the decoder until @ref<br>
	 * JxlDecoderReleaseJPEGBuffer is called or the decoder is destroyed or<br>
	 * reset so must be kept alive until then.<br>
	 * If a JPEG buffer was set before and released with @ref<br>
	 * JxlDecoderReleaseJPEGBuffer, bytes that the decoder has already output<br>
	 * should not be included, only the remaining bytes output must be set.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to write to<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return @ref JXL_DEC_ERROR if output buffer was already set and @ref<br>
	 *     JxlDecoderReleaseJPEGBuffer was not called on it, @ref JXL_DEC_SUCCESS<br>
	 *     otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetJPEGBuffer(JxlDecoder*, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1179</i>
	 */
	int JxlDecoderSetJPEGBuffer(PointerByReference dec, Pointer data, NativeLong size);
	/**
	 * Releases buffer which was provided with @ref JxlDecoderSetJPEGBuffer.<br>
	 * Calling @ref JxlDecoderReleaseJPEGBuffer is required whenever<br>
	 * a buffer is already set and a new buffer needs to be added with @ref<br>
	 * JxlDecoderSetJPEGBuffer, but is not required before @ref<br>
	 * JxlDecoderDestroy or @ref JxlDecoderReset.<br>
	 * Calling @ref JxlDecoderReleaseJPEGBuffer when no buffer is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return the amount of bytes the decoder has not yet written to of the data<br>
	 *     set by @ref JxlDecoderSetJPEGBuffer, or 0 if no buffer is set or @ref<br>
	 *     JxlDecoderReleaseJPEGBuffer was already called.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseJPEGBuffer(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:1198</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderReleaseJPEGBuffer(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	NativeLong JxlDecoderReleaseJPEGBuffer(Pointer dec);
	/**
	 * Releases buffer which was provided with @ref JxlDecoderSetJPEGBuffer.<br>
	 * Calling @ref JxlDecoderReleaseJPEGBuffer is required whenever<br>
	 * a buffer is already set and a new buffer needs to be added with @ref<br>
	 * JxlDecoderSetJPEGBuffer, but is not required before @ref<br>
	 * JxlDecoderDestroy or @ref JxlDecoderReset.<br>
	 * Calling @ref JxlDecoderReleaseJPEGBuffer when no buffer is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return the amount of bytes the decoder has not yet written to of the data<br>
	 *     set by @ref JxlDecoderSetJPEGBuffer, or 0 if no buffer is set or @ref<br>
	 *     JxlDecoderReleaseJPEGBuffer was already called.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseJPEGBuffer(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:1198</i>
	 */
	NativeLong JxlDecoderReleaseJPEGBuffer(PointerByReference dec);
	/**
	 * Sets output buffer for box output codestream.<br>
	 * The data is owned by the caller and may be used by the decoder until @ref<br>
	 * JxlDecoderReleaseBoxBuffer is called or the decoder is destroyed or<br>
	 * reset so must be kept alive until then.<br>
	 * If for the current box a box buffer was set before and released with @ref<br>
	 * JxlDecoderReleaseBoxBuffer, bytes that the decoder has already output<br>
	 * should not be included, only the remaining bytes output must be set.<br>
	 * The @ref JxlDecoderReleaseBoxBuffer must be used at the next @ref JXL_DEC_BOX<br>
	 * event or final @ref JXL_DEC_SUCCESS event to compute the size of the output<br>
	 * box bytes.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to write to<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return @ref JXL_DEC_ERROR if output buffer was already set and @ref<br>
	 *     JxlDecoderReleaseBoxBuffer was not called on it, @ref JXL_DEC_SUCCESS<br>
	 *     otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetBoxBuffer(JxlDecoder*, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1222</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetBoxBuffer(com.sun.jna.ptr.PointerByReference, java.nio.ByteBuffer, NativeLong)} and {@link #JxlDecoderSetBoxBuffer(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, NativeLong)} instead
	 */
	@Deprecated 
	int JxlDecoderSetBoxBuffer(Pointer dec, Pointer data, NativeLong size);
	/**
	 * Sets output buffer for box output codestream.<br>
	 * The data is owned by the caller and may be used by the decoder until @ref<br>
	 * JxlDecoderReleaseBoxBuffer is called or the decoder is destroyed or<br>
	 * reset so must be kept alive until then.<br>
	 * If for the current box a box buffer was set before and released with @ref<br>
	 * JxlDecoderReleaseBoxBuffer, bytes that the decoder has already output<br>
	 * should not be included, only the remaining bytes output must be set.<br>
	 * The @ref JxlDecoderReleaseBoxBuffer must be used at the next @ref JXL_DEC_BOX<br>
	 * event or final @ref JXL_DEC_SUCCESS event to compute the size of the output<br>
	 * box bytes.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to write to<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return @ref JXL_DEC_ERROR if output buffer was already set and @ref<br>
	 *     JxlDecoderReleaseBoxBuffer was not called on it, @ref JXL_DEC_SUCCESS<br>
	 *     otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetBoxBuffer(JxlDecoder*, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1222</i>
	 */
	int JxlDecoderSetBoxBuffer(PointerByReference dec, ByteBuffer data, NativeLong size);
	/**
	 * Sets output buffer for box output codestream.<br>
	 * The data is owned by the caller and may be used by the decoder until @ref<br>
	 * JxlDecoderReleaseBoxBuffer is called or the decoder is destroyed or<br>
	 * reset so must be kept alive until then.<br>
	 * If for the current box a box buffer was set before and released with @ref<br>
	 * JxlDecoderReleaseBoxBuffer, bytes that the decoder has already output<br>
	 * should not be included, only the remaining bytes output must be set.<br>
	 * The @ref JxlDecoderReleaseBoxBuffer must be used at the next @ref JXL_DEC_BOX<br>
	 * event or final @ref JXL_DEC_SUCCESS event to compute the size of the output<br>
	 * box bytes.<br>
	 * @param dec decoder object<br>
	 * @param data pointer to next bytes to write to<br>
	 * @param size amount of bytes available starting from data<br>
	 * @return @ref JXL_DEC_ERROR if output buffer was already set and @ref<br>
	 *     JxlDecoderReleaseBoxBuffer was not called on it, @ref JXL_DEC_SUCCESS<br>
	 *     otherwise<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetBoxBuffer(JxlDecoder*, uint8_t*, size_t)</code><br>
	 * <i>native declaration : jxl/decode.h:1222</i>
	 */
	int JxlDecoderSetBoxBuffer(PointerByReference dec, Pointer data, NativeLong size);
	/**
	 * Releases buffer which was provided with @ref JxlDecoderSetBoxBuffer.<br>
	 * Calling @ref JxlDecoderReleaseBoxBuffer is required whenever<br>
	 * a buffer is already set and a new buffer needs to be added with @ref<br>
	 * JxlDecoderSetBoxBuffer, but is not required before @ref<br>
	 * JxlDecoderDestroy or @ref JxlDecoderReset.<br>
	 * Calling @ref JxlDecoderReleaseBoxBuffer when no buffer is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return the amount of bytes the decoder has not yet written to of the data<br>
	 *     set by @ref JxlDecoderSetBoxBuffer, or 0 if no buffer is set or @ref<br>
	 *     JxlDecoderReleaseBoxBuffer was already called.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseBoxBuffer(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:1241</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderReleaseBoxBuffer(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	NativeLong JxlDecoderReleaseBoxBuffer(Pointer dec);
	/**
	 * Releases buffer which was provided with @ref JxlDecoderSetBoxBuffer.<br>
	 * Calling @ref JxlDecoderReleaseBoxBuffer is required whenever<br>
	 * a buffer is already set and a new buffer needs to be added with @ref<br>
	 * JxlDecoderSetBoxBuffer, but is not required before @ref<br>
	 * JxlDecoderDestroy or @ref JxlDecoderReset.<br>
	 * Calling @ref JxlDecoderReleaseBoxBuffer when no buffer is set is<br>
	 * not an error and returns 0.<br>
	 * @param dec decoder object<br>
	 * @return the amount of bytes the decoder has not yet written to of the data<br>
	 *     set by @ref JxlDecoderSetBoxBuffer, or 0 if no buffer is set or @ref<br>
	 *     JxlDecoderReleaseBoxBuffer was already called.<br>
	 * Original signature : <code>size_t JxlDecoderReleaseBoxBuffer(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:1241</i>
	 */
	NativeLong JxlDecoderReleaseBoxBuffer(PointerByReference dec);
	/**
	 * Configures whether to get boxes in raw mode or in decompressed mode. In raw<br>
	 * mode, boxes are output as their bytes appear in the container file, which may<br>
	 * be decompressed, or compressed if their type is "brob". In decompressed mode,<br>
	 * "brob" boxes are decompressed with Brotli before outputting them. The size of<br>
	 * the decompressed stream is not known before the decompression has already<br>
	 * finished.<br>
	 * The default mode is raw. This setting can only be changed before decoding, or<br>
	 * directly after a @ref JXL_DEC_BOX event, and is remembered until the decoder<br>
	 * is reset or destroyed.<br>
	 * Enabling decompressed mode requires Brotli support from the library.<br>
	 * @param dec decoder object<br>
	 * @param decompress JXL_TRUE to transparently decompress, JXL_FALSE to get<br>
	 *     boxes in raw mode.<br>
	 * @return @ref JXL_DEC_ERROR if decompressed mode is set and Brotli is not<br>
	 *     available, @ref JXL_DEC_SUCCESS otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetDecompressBoxes(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:1263</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetDecompressBoxes(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetDecompressBoxes(Pointer dec, int /* JXL_BOOL */ decompress);
	/**
	 * Configures whether to get boxes in raw mode or in decompressed mode. In raw<br>
	 * mode, boxes are output as their bytes appear in the container file, which may<br>
	 * be decompressed, or compressed if their type is "brob". In decompressed mode,<br>
	 * "brob" boxes are decompressed with Brotli before outputting them. The size of<br>
	 * the decompressed stream is not known before the decompression has already<br>
	 * finished.<br>
	 * The default mode is raw. This setting can only be changed before decoding, or<br>
	 * directly after a @ref JXL_DEC_BOX event, and is remembered until the decoder<br>
	 * is reset or destroyed.<br>
	 * Enabling decompressed mode requires Brotli support from the library.<br>
	 * @param dec decoder object<br>
	 * @param decompress JXL_TRUE to transparently decompress, JXL_FALSE to get<br>
	 *     boxes in raw mode.<br>
	 * @return @ref JXL_DEC_ERROR if decompressed mode is set and Brotli is not<br>
	 *     available, @ref JXL_DEC_SUCCESS otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetDecompressBoxes(JxlDecoder*, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:1263</i>
	 */
	int JxlDecoderSetDecompressBoxes(PointerByReference dec, int /* JXL_BOOL */ decompress);
	/**
	 * Outputs the type of the current box, after a @ref JXL_DEC_BOX event occurred,<br>
	 * as 4 characters without null termination character. In case of a compressed<br>
	 * "brob" box, this will return "brob" if the decompressed argument is<br>
	 * JXL_FALSE, or the underlying box type if the decompressed argument is<br>
	 * JXL_TRUE.<br>
	 * The following box types are currently described in ISO/IEC 18181-2:<br>
	 *  - "Exif": a box with EXIF metadata.  Starts with a 4-byte tiff header offset<br>
	 *    (big-endian uint32) that indicates the start of the actual EXIF data<br>
	 *    (which starts with a tiff header). Usually the offset will be zero and the<br>
	 *    EXIF data starts immediately after the offset field. The Exif orientation<br>
	 *    should be ignored by applications; the JPEG XL codestream orientation<br>
	 *    takes precedence and libjxl will by default apply the correct orientation<br>
	 *    automatically (see @ref JxlDecoderSetKeepOrientation).<br>
	 *  - "xml ": a box with XML data, in particular XMP metadata.<br>
	 *  - "jumb": a JUMBF superbox (JPEG Universal Metadata Box Format, ISO/IEC<br>
	 *    19566-5).<br>
	 *  - "JXL ": mandatory signature box, must come first, 12 bytes long including<br>
	 *    the box header<br>
	 *  - "ftyp": a second mandatory signature box, must come second, 20 bytes long<br>
	 *    including the box header<br>
	 *  - "jxll": a JXL level box. This indicates if the codestream is level 5 or<br>
	 *    level 10 compatible. If not present, it is level 5. Level 10 allows more<br>
	 *    features such as very high image resolution and bit-depths above 16 bits<br>
	 *    per channel. Added automatically by the encoder when<br>
	 *    JxlEncoderSetCodestreamLevel is used<br>
	 *  - "jxlc": a box with the image codestream, in case the codestream is not<br>
	 *    split across multiple boxes. The codestream contains the JPEG XL image<br>
	 *    itself, including the basic info such as image dimensions, ICC color<br>
	 *    profile, and all the pixel data of all the image frames.<br>
	 *  - "jxlp": a codestream box in case it is split across multiple boxes.<br>
	 *    The contents are the same as in case of a jxlc box, when concatenated.<br>
	 *  - "brob": a Brotli-compressed box, which otherwise represents an existing<br>
	 *    type of box such as Exif or "xml ". When @ref JxlDecoderSetDecompressBoxes<br>
	 *    is set to JXL_TRUE, these boxes will be transparently decompressed by the<br>
	 *    decoder.<br>
	 *  - "jxli": frame index box, can list the keyframes in case of a JPEG XL<br>
	 *    animation allowing the decoder to jump to individual frames more<br>
	 *    efficiently.<br>
	 *  - "jbrd": JPEG reconstruction box, contains the information required to<br>
	 *    byte-for-byte losslessly recontruct a JPEG-1 image. The JPEG DCT<br>
	 *    coefficients (pixel content) themselves as well as the ICC profile are<br>
	 *    encoded in the JXL codestream (jxlc or jxlp) itself. EXIF, XMP and JUMBF<br>
	 *    metadata is encoded in the corresponding boxes. The jbrd box itself<br>
	 *    contains information such as the remaining app markers of the JPEG-1 file<br>
	 *    and everything else required to fit the information together into the<br>
	 *    exact original JPEG file.<br>
	 * Other application-specific boxes can exist. Their typename should not begin<br>
	 * with "jxl" or "JXL" or conflict with other existing typenames.<br>
	 * The signature, jxl* and jbrd boxes are processed by the decoder and would<br>
	 * typically be ignored by applications. The typical way to use this function is<br>
	 * to check if an encountered box contains metadata that the application is<br>
	 * interested in (e.g. EXIF or XMP metadata), in order to conditionally set a<br>
	 * box buffer.<br>
	 * @param dec decoder object<br>
	 * @param type buffer to copy the type into<br>
	 * @param decompressed which box type to get: JXL_FALSE to get the raw box type,<br>
	 *     which can be "brob", JXL_TRUE, get the underlying box type.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref JXL_DEC_ERROR if<br>
	 *     not, for example the JXL file does not use the container format.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetBoxType(JxlDecoder*, JxlBoxType, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:1331</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetBoxType(com.sun.jna.ptr.PointerByReference, JxlBoxType, int)} instead
	 */
	@Deprecated 
	int JxlDecoderGetBoxType(Pointer dec, JxlBoxType type, int /* JXL_BOOL */ decompressed);
	/**
	 * Outputs the type of the current box, after a @ref JXL_DEC_BOX event occurred,<br>
	 * as 4 characters without null termination character. In case of a compressed<br>
	 * "brob" box, this will return "brob" if the decompressed argument is<br>
	 * JXL_FALSE, or the underlying box type if the decompressed argument is<br>
	 * JXL_TRUE.<br>
	 * The following box types are currently described in ISO/IEC 18181-2:<br>
	 *  - "Exif": a box with EXIF metadata.  Starts with a 4-byte tiff header offset<br>
	 *    (big-endian uint32) that indicates the start of the actual EXIF data<br>
	 *    (which starts with a tiff header). Usually the offset will be zero and the<br>
	 *    EXIF data starts immediately after the offset field. The Exif orientation<br>
	 *    should be ignored by applications; the JPEG XL codestream orientation<br>
	 *    takes precedence and libjxl will by default apply the correct orientation<br>
	 *    automatically (see @ref JxlDecoderSetKeepOrientation).<br>
	 *  - "xml ": a box with XML data, in particular XMP metadata.<br>
	 *  - "jumb": a JUMBF superbox (JPEG Universal Metadata Box Format, ISO/IEC<br>
	 *    19566-5).<br>
	 *  - "JXL ": mandatory signature box, must come first, 12 bytes long including<br>
	 *    the box header<br>
	 *  - "ftyp": a second mandatory signature box, must come second, 20 bytes long<br>
	 *    including the box header<br>
	 *  - "jxll": a JXL level box. This indicates if the codestream is level 5 or<br>
	 *    level 10 compatible. If not present, it is level 5. Level 10 allows more<br>
	 *    features such as very high image resolution and bit-depths above 16 bits<br>
	 *    per channel. Added automatically by the encoder when<br>
	 *    JxlEncoderSetCodestreamLevel is used<br>
	 *  - "jxlc": a box with the image codestream, in case the codestream is not<br>
	 *    split across multiple boxes. The codestream contains the JPEG XL image<br>
	 *    itself, including the basic info such as image dimensions, ICC color<br>
	 *    profile, and all the pixel data of all the image frames.<br>
	 *  - "jxlp": a codestream box in case it is split across multiple boxes.<br>
	 *    The contents are the same as in case of a jxlc box, when concatenated.<br>
	 *  - "brob": a Brotli-compressed box, which otherwise represents an existing<br>
	 *    type of box such as Exif or "xml ". When @ref JxlDecoderSetDecompressBoxes<br>
	 *    is set to JXL_TRUE, these boxes will be transparently decompressed by the<br>
	 *    decoder.<br>
	 *  - "jxli": frame index box, can list the keyframes in case of a JPEG XL<br>
	 *    animation allowing the decoder to jump to individual frames more<br>
	 *    efficiently.<br>
	 *  - "jbrd": JPEG reconstruction box, contains the information required to<br>
	 *    byte-for-byte losslessly recontruct a JPEG-1 image. The JPEG DCT<br>
	 *    coefficients (pixel content) themselves as well as the ICC profile are<br>
	 *    encoded in the JXL codestream (jxlc or jxlp) itself. EXIF, XMP and JUMBF<br>
	 *    metadata is encoded in the corresponding boxes. The jbrd box itself<br>
	 *    contains information such as the remaining app markers of the JPEG-1 file<br>
	 *    and everything else required to fit the information together into the<br>
	 *    exact original JPEG file.<br>
	 * Other application-specific boxes can exist. Their typename should not begin<br>
	 * with "jxl" or "JXL" or conflict with other existing typenames.<br>
	 * The signature, jxl* and jbrd boxes are processed by the decoder and would<br>
	 * typically be ignored by applications. The typical way to use this function is<br>
	 * to check if an encountered box contains metadata that the application is<br>
	 * interested in (e.g. EXIF or XMP metadata), in order to conditionally set a<br>
	 * box buffer.<br>
	 * @param dec decoder object<br>
	 * @param type buffer to copy the type into<br>
	 * @param decompressed which box type to get: JXL_FALSE to get the raw box type,<br>
	 *     which can be "brob", JXL_TRUE, get the underlying box type.<br>
	 * @return @ref JXL_DEC_SUCCESS if the value is available, @ref JXL_DEC_ERROR if<br>
	 *     not, for example the JXL file does not use the container format.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetBoxType(JxlDecoder*, JxlBoxType, JXL_BOOL)</code><br>
	 * <i>native declaration : jxl/decode.h:1331</i>
	 */
	int JxlDecoderGetBoxType(PointerByReference dec, JxlBoxType type, int /* JXL_BOOL */ decompressed);
	/**
	 * Returns the size of a box as it appears in the container file, after the @ref<br>
	 * JXL_DEC_BOX event. For a non-compressed box, this is the size of the<br>
	 * contents, excluding the 4 bytes indicating the box type. For a compressed<br>
	 * "brob" box, this is the size of the compressed box contents plus the<br>
	 * additional 4 byte indicating the underlying box type, but excluding the 4<br>
	 * bytes indicating "brob". This function gives the size of the data that will<br>
	 * be written in the output buffer when getting boxes in the default raw<br>
	 * compressed mode. When @ref JxlDecoderSetDecompressBoxes is enabled, the<br>
	 * return value of function does not change, and the decompressed size is not<br>
	 * known before it has already been decompressed and output.<br>
	 * @param dec decoder object<br>
	 * @param size raw size of the box in bytes<br>
	 * @return @ref JXL_DEC_ERROR if no box size is available, @ref JXL_DEC_SUCCESS<br>
	 *     otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetBoxSizeRaw(const JxlDecoder*, uint64_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:1352</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderGetBoxSizeRaw(com.sun.jna.ptr.PointerByReference, java.nio.LongBuffer)} and {@link #JxlDecoderGetBoxSizeRaw(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.LongByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderGetBoxSizeRaw(Pointer dec, LongByReference size);
	/**
	 * Returns the size of a box as it appears in the container file, after the @ref<br>
	 * JXL_DEC_BOX event. For a non-compressed box, this is the size of the<br>
	 * contents, excluding the 4 bytes indicating the box type. For a compressed<br>
	 * "brob" box, this is the size of the compressed box contents plus the<br>
	 * additional 4 byte indicating the underlying box type, but excluding the 4<br>
	 * bytes indicating "brob". This function gives the size of the data that will<br>
	 * be written in the output buffer when getting boxes in the default raw<br>
	 * compressed mode. When @ref JxlDecoderSetDecompressBoxes is enabled, the<br>
	 * return value of function does not change, and the decompressed size is not<br>
	 * known before it has already been decompressed and output.<br>
	 * @param dec decoder object<br>
	 * @param size raw size of the box in bytes<br>
	 * @return @ref JXL_DEC_ERROR if no box size is available, @ref JXL_DEC_SUCCESS<br>
	 *     otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetBoxSizeRaw(const JxlDecoder*, uint64_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:1352</i>
	 */
	int JxlDecoderGetBoxSizeRaw(PointerByReference dec, LongBuffer size);
	/**
	 * Returns the size of a box as it appears in the container file, after the @ref<br>
	 * JXL_DEC_BOX event. For a non-compressed box, this is the size of the<br>
	 * contents, excluding the 4 bytes indicating the box type. For a compressed<br>
	 * "brob" box, this is the size of the compressed box contents plus the<br>
	 * additional 4 byte indicating the underlying box type, but excluding the 4<br>
	 * bytes indicating "brob". This function gives the size of the data that will<br>
	 * be written in the output buffer when getting boxes in the default raw<br>
	 * compressed mode. When @ref JxlDecoderSetDecompressBoxes is enabled, the<br>
	 * return value of function does not change, and the decompressed size is not<br>
	 * known before it has already been decompressed and output.<br>
	 * @param dec decoder object<br>
	 * @param size raw size of the box in bytes<br>
	 * @return @ref JXL_DEC_ERROR if no box size is available, @ref JXL_DEC_SUCCESS<br>
	 *     otherwise.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderGetBoxSizeRaw(const JxlDecoder*, uint64_t*)</code><br>
	 * <i>native declaration : jxl/decode.h:1352</i>
	 */
	int JxlDecoderGetBoxSizeRaw(PointerByReference dec, LongByReference size);
	/**
	 * Configures at which progressive steps in frame decoding these @ref<br>
	 * JXL_DEC_FRAME_PROGRESSION event occurs. The default value for the level<br>
	 * of detail if this function is never called is `kDC`.<br>
	 * @param dec decoder object<br>
	 * @param detail at which level of detail to trigger @ref<br>
	 *     JXL_DEC_FRAME_PROGRESSION<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     an invalid value for the progressive detail.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetProgressiveDetail(JxlDecoder*, JxlProgressiveDetail)</code><br>
	 * <i>native declaration : jxl/decode.h:1366</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderSetProgressiveDetail(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	int JxlDecoderSetProgressiveDetail(Pointer dec, int detail);
	/**
	 * Configures at which progressive steps in frame decoding these @ref<br>
	 * JXL_DEC_FRAME_PROGRESSION event occurs. The default value for the level<br>
	 * of detail if this function is never called is `kDC`.<br>
	 * @param dec decoder object<br>
	 * @param detail at which level of detail to trigger @ref<br>
	 *     JXL_DEC_FRAME_PROGRESSION<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     an invalid value for the progressive detail.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetProgressiveDetail(JxlDecoder*, JxlProgressiveDetail)</code><br>
	 * <i>native declaration : jxl/decode.h:1366</i>
	 */
	int JxlDecoderSetProgressiveDetail(PointerByReference dec, int detail);
	/**
	 * Returns the intended downsampling ratio for the progressive frame produced<br>
	 * by @ref JxlDecoderFlushImage after the latest @ref JXL_DEC_FRAME_PROGRESSION<br>
	 * event.<br>
	 * @param dec decoder object<br>
	 * @return The intended downsampling ratio, can be 1, 2, 4 or 8.<br>
	 * Original signature : <code>size_t JxlDecoderGetIntendedDownsamplingRatio(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:1377</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderGetIntendedDownsamplingRatio(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	NativeLong JxlDecoderGetIntendedDownsamplingRatio(Pointer dec);
	/**
	 * Returns the intended downsampling ratio for the progressive frame produced<br>
	 * by @ref JxlDecoderFlushImage after the latest @ref JXL_DEC_FRAME_PROGRESSION<br>
	 * event.<br>
	 * @param dec decoder object<br>
	 * @return The intended downsampling ratio, can be 1, 2, 4 or 8.<br>
	 * Original signature : <code>size_t JxlDecoderGetIntendedDownsamplingRatio(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:1377</i>
	 */
	NativeLong JxlDecoderGetIntendedDownsamplingRatio(PointerByReference dec);
	/**
	 * Outputs progressive step towards the decoded image so far when only partial<br>
	 * input was received. If the flush was successful, the buffer set with @ref<br>
	 * JxlDecoderSetImageOutBuffer will contain partial image data.<br>
	 * Can be called when @ref JxlDecoderProcessInput returns @ref<br>
	 * JXL_DEC_NEED_MORE_INPUT, after the @ref JXL_DEC_FRAME event already occurred<br>
	 * and before the @ref JXL_DEC_FULL_IMAGE event occurred for a frame.<br>
	 * @param dec decoder object<br>
	 * @return @ref JXL_DEC_SUCCESS if image data was flushed to the output buffer,<br>
	 *     or @ref JXL_DEC_ERROR when no flush was done, e.g. if not enough image<br>
	 *     data was available yet even for flush, or no output buffer was set yet.<br>
	 *     This error is not fatal, it only indicates no flushed image is available<br>
	 *     right now. Regular decoding can still be performed.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderFlushImage(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:1395</i><br>
	 * @deprecated use the safer method {@link #JxlDecoderFlushImage(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int JxlDecoderFlushImage(Pointer dec);
	/**
	 * Outputs progressive step towards the decoded image so far when only partial<br>
	 * input was received. If the flush was successful, the buffer set with @ref<br>
	 * JxlDecoderSetImageOutBuffer will contain partial image data.<br>
	 * Can be called when @ref JxlDecoderProcessInput returns @ref<br>
	 * JXL_DEC_NEED_MORE_INPUT, after the @ref JXL_DEC_FRAME event already occurred<br>
	 * and before the @ref JXL_DEC_FULL_IMAGE event occurred for a frame.<br>
	 * @param dec decoder object<br>
	 * @return @ref JXL_DEC_SUCCESS if image data was flushed to the output buffer,<br>
	 *     or @ref JXL_DEC_ERROR when no flush was done, e.g. if not enough image<br>
	 *     data was available yet even for flush, or no output buffer was set yet.<br>
	 *     This error is not fatal, it only indicates no flushed image is available<br>
	 *     right now. Regular decoding can still be performed.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderFlushImage(JxlDecoder*)</code><br>
	 * <i>native declaration : jxl/decode.h:1395</i>
	 */
	int JxlDecoderFlushImage(PointerByReference dec);
	/**
	 * Sets the bit depth of the output buffer or callback.<br>
	 * Can be called after @ref JxlDecoderSetImageOutBuffer or @ref<br>
	 * JxlDecoderSetImageOutCallback. For float pixel data types, only the default<br>
	 * @ref JXL_BIT_DEPTH_FROM_PIXEL_FORMAT setting is supported.<br>
	 * @param dec decoder object<br>
	 * @param bit_depth the bit depth setting of the pixel output<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     incompatible custom bit depth and pixel data type.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutBitDepth(JxlDecoder*, const JxlBitDepth*)</code><br>
	 * <i>native declaration : jxl/decode.h:1409</i><br>
	 * @deprecated use the safer methods {@link #JxlDecoderSetImageOutBitDepth(com.sun.jna.ptr.PointerByReference, JxlBitDepth[])} and {@link #JxlDecoderSetImageOutBitDepth(com.sun.jna.ptr.PointerByReference, JxlBitDepth)} instead
	 */
	@Deprecated 
	int JxlDecoderSetImageOutBitDepth(Pointer dec, JxlBitDepth bit_depth);
	/**
	 * Sets the bit depth of the output buffer or callback.<br>
	 * Can be called after @ref JxlDecoderSetImageOutBuffer or @ref<br>
	 * JxlDecoderSetImageOutCallback. For float pixel data types, only the default<br>
	 * @ref JXL_BIT_DEPTH_FROM_PIXEL_FORMAT setting is supported.<br>
	 * @param dec decoder object<br>
	 * @param bit_depth the bit depth setting of the pixel output<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     incompatible custom bit depth and pixel data type.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutBitDepth(JxlDecoder*, const JxlBitDepth*)</code><br>
	 * <i>native declaration : jxl/decode.h:1409</i>
	 */
	int JxlDecoderSetImageOutBitDepth(PointerByReference dec, JxlBitDepth bit_depth[]);
	/**
	 * Sets the bit depth of the output buffer or callback.<br>
	 * Can be called after @ref JxlDecoderSetImageOutBuffer or @ref<br>
	 * JxlDecoderSetImageOutCallback. For float pixel data types, only the default<br>
	 * @ref JXL_BIT_DEPTH_FROM_PIXEL_FORMAT setting is supported.<br>
	 * @param dec decoder object<br>
	 * @param bit_depth the bit depth setting of the pixel output<br>
	 * @return @ref JXL_DEC_SUCCESS on success, @ref JXL_DEC_ERROR on error, such as<br>
	 *     incompatible custom bit depth and pixel data type.<br>
	 * Original signature : <code>JxlDecoderStatus JxlDecoderSetImageOutBitDepth(JxlDecoder*, const JxlBitDepth*)</code><br>
	 * <i>native declaration : jxl/decode.h:1409</i>
	 */
	int JxlDecoderSetImageOutBitDepth(PointerByReference dec, JxlBitDepth bit_depth);
	class JxlDecoder extends PointerType {
		public JxlDecoder(Pointer address) {
			super(address);
		}
		public JxlDecoder() {
			super();
		}
	}
}
